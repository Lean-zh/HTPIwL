# Proofs

## 3.1 & 3.2. Proofs Involving Negations and Conditionals

Sections 3.1 and 3.2 of *How To Prove It* present strategies for dealing with givens and goals involving negations and conditionals.  We restate those strategies here, and explain how to use them with Lean.

Section 3.1 gives two strategies for proving a goal of the form `P â†’ Q`:

#### To prove a goal of the form `P â†’ Q`:

1.  Assume `P` is true and prove `Q`.
2.  Assume `Q` is false and prove that `P` is false.

We've already seen how to carry out both of these strategies in Lean.  For the first strategy, use the `assume` tactic to introduce the assumption `P` and assign an identifier to it; Lean will automaticall set `Q` as the goal.  We can summarize the effect of using this strategy by showing how the tactic state changes if you use the tactic `assume h : P`:

::: {.lftrt}
::: {.bef}
```state
!! â‹®
âŠ¢ P â†’ Q
```
:::

::: {.aft}
```state
!! â‹®
h : P
âŠ¢ Q
```
:::
:::

The second strategy is justified by the contrapositive law.  In Lean, you can use the `contrapos` tactic to rewrite the goal as `Â¬Q â†’ Â¬P` and then use the tactic `assume h : Â¬Q`.  The net effect of these two tactics is:

::: {.lftrt}
::: {.bef}
```state
!! â‹®
âŠ¢ P â†’ Q
```
:::

::: {.aft}
```state
!! â‹®
h : Â¬Q
âŠ¢ Â¬P
```
:::
:::

Section 3.2 gives two strategies for using givens of the form `P â†’ Q`, with the second once again being a variation on the first based on the contrapositive law:

#### To use a given of the form `P â†’ Q`:

1.  If you are also given `P`, or you can prove that `P` is true, then you can use this given to conclude that `Q` is true.
2.  If you are also given `Â¬Q`, or you can prove that `Q` is false, then you can use this given to conclude that `P` is false.

The first strategy is the modus ponens rule of inference, and we saw in the last chapter that if you have `h1 : P â†’ Q` and `h2 : P`, then `h1 h2` is a (term-mode) proof of `Q`; often we use this rule with the `have` or `show` tactic.  For the second strategy, if you have `h1 : P â†’ Q` and `h2 : Â¬Q`, then the `contrapos at h1` tactic will change `h1` to `h1 : Â¬Q â†’ Â¬P`, and then `h1 h2` will be a proof of `Â¬P`.

All of the strategies listed above for working with conditional statements as givens or goals were illustrated in examples in the last chapter.

Section 3.2 of *HTPI* offers two strategies for proving negative goals:

#### To prove a goal of the form `Â¬P`:

1.  Reexpress the goal in some other form.
2.  Use proof by contradiction: assume `P` is true and try to deduce a contradiction.

For the first strategy, the tactics `demorgan`, `conditional`, and `double_neg` may be useful, and we saw how those tactics work in the last chapter.  But how do you write a proof by contradiction in Lean?  The answer is to use a tactic called `by_contra`.  If the goal is `Â¬P`, then the tactic `by_contra h` will introduce the assumption `h : P` and set the goal to be `False`, like this:

::: {.lftrt}
::: {.bef}
```state
!! â‹®
âŠ¢ Â¬P
```
:::

::: {.aft}
```state
!! â‹®
h : P
âŠ¢ False
```
:::
:::

In Lean, `False` represents a statement that is always false---that is, a contradiction, as that term is defined in Section 1.2 of *HTPI*.  The `by_contra` tactic can actually be used even if the goal is not a negative statement.  If the goal is a statement `P` that is not a negative statement, then `by_contra h` will initiate a proof by contradiction by introducing the assumption `h : Â¬P` and setting the goal to be `False`.

You will usually complete a proof by contradiction by deducing two contradictory statements---say, `h1 : Q` and `h2 : Â¬Q`.  But how do you convince Lean that the proof is over?  You must be able to prove the goal `False` from the two givens `h1` and `h2`.  There are two ways to do this.  The first is based on the fact that Lean treats a statement of the form `Â¬Q` as meaning the same thing as `Q â†’ False`.  This makes sense, because these statements are logically equivalent, as shown by the following truth table:

::: {style="margin: 0% 20%"}
| `Q` | `Â¬Q` | `(Q` | `â†’` | `False)`|
|:----------:|:----------:|-:|:-:|:-|
| F | T | F | T | &nbsp;&nbsp;[&nbsp;]{.excl} F |
| T | F | T | F | &nbsp;&nbsp;[&nbsp;]{.excl} F |
:::

Thinking of `h2 : Â¬Q` as meaning `h2 : Q â†’ False`, we can combine it with `h1 : Q` using modus ponens to deduce `False`.  In other words, `h2 h1` is a proof of `False`.

But there is a second way of completing the proof that it is worthwhile to know about.  From contradictory statements `h1 : Q` and `h2 : Â¬Q` you can validly deduce *any* statement.  This follows from the definition of a *valid argument* in Section 1.1 of *HTPI*.  According to that definition, you can validly infer a conclusion `R` from premises `h1 : Q` and `h2 : Â¬Q` if the premises cannot both be true without the conclusion also being true.  In this case, that standard is met, for the simple reason that the premises cannot both be true!  (This gives part of the answer to exercise 18 in Section 1.2 of *HTPI*.)  Thus, Lean has a rule that allows you to prove any statement from contradictory premises.  If you have `h1 : Q` and `h2 : Â¬Q`, then Lean will recognize `absurd h1 h2` as a (term-mode) proof of *any* statement.

To summarize, if you have `h1 : Q` and `h2 : Â¬Q`, then there are two ways to prove `False`.  Lean will recognize `h2 h1` as a proof of `False`, and it will recognize `absurd h1 h2` as a proof of any statement, including `False`.  Notice the difference in the order in which `h1` and `h2` are listed in these two proofs: In the first one, the negative statement `h2` must come first, just as the conditional statement must come first in an application of modus ponens.  But in a proof using `absurd`, the negative statement must come second.

To illustrate proof by contradiction in Lean, let's redo our first example from the last Chapter in a different way.  That example was based on Example 3.2.4 in *HTPI*.  We'll begin with the same first two steps, introducing two assumptions.  (We won't bother to include the `done` line in the displays below.)

::: {.inout}
::: {.inpt}
```lean
theorem Example_3_2_4_v2 (P Q R : Prop)
(h : P â†’ (Q â†’ R)) : Â¬R â†’ (P â†’ Â¬Q) := by
  assume h2 : Â¬R
  assume h3 : P
```
:::

::: {.outpt}
```state
P Q R : Prop
h : P â†’ Q â†’ R
h2 : Â¬R
h3 : P
âŠ¢ Â¬Q
```
:::
:::

Now the goal is a negative statement, so we use the tactic `by_contra h4` to introduce the assumption `h4 : Q` and set the goal to be `False`:

::: {.inout}
::: {.inpt}
```lean
theorem Example_3_2_4_v2 (P Q R : Prop)
(h : P â†’ (Q â†’ R)) : Â¬R â†’ (P â†’ Â¬Q) := by
  assume h2 : Â¬R
  assume h3 : P
  by_contra h4
```
:::

::: {.outpt}
```state
P Q R : Prop
h : P â†’ Q â†’ R
h2 : Â¬R
h3 : P
h4 : Q
âŠ¢ False
```
:::
:::

Using the givens `h`, `h3`, and `h4` we can deduce first `Q â†’ R` and then `R` by two applications of modus ponens:

::: {.inout}
::: {.inpt}
```lean
theorem Example_3_2_4_v2 (P Q R : Prop)
(h : P â†’ (Q â†’ R)) : Â¬R â†’ (P â†’ Â¬Q) := by
  assume h2 : Â¬R
  assume h3 : P
  by_contra h4
  have h5 : Q â†’ R := h h3
  have h6 : R := h5 h4
```
:::

::: {.outpt}
```state
P Q R : Prop
h : P â†’ Q â†’ R
h2 : Â¬R
h3 : P
h4 : Q
h5 : Q â†’ R
h6 : R
âŠ¢ False
```
:::
:::

Now we have a contradiction: `h2 : Â¬R` and `h6 : R`.  To complete the proof, we deduce `False` from these two givens.  Either `h2 h6` or `absurd h6 h2` would be accepted by Lean as a proof of `False`:

::: {.inout}
::: {.inpt}
```lean
theorem Example_3_2_4_v2 (P Q R : Prop)
(h : P â†’ (Q â†’ R)) : Â¬R â†’ (P â†’ Â¬Q) := by
  assume h2 : Â¬R
  assume h3 : P
  by_contra h4
  have h5 : Q â†’ R := h h3
  have h6 : R := h5 h4
  show False from h2 h6
```
:::

::: {.outpt}
```state
!!Goals accomplished ðŸŽ‰
```
:::
:::

Finally, we have two strategies for using a given that is a negative statement:

#### To use a given of the form `Â¬P`:

1.  Reexpress the given in some other form.
2.  If you are doing a proof by contradiction, you can achieve a contradiction by proving `P`, since that would contradict the given `Â¬P`.

Of course, strategy 1 suggests the use of the `demorgan`, `conditional`, and `double_neg` tactics, if they apply.  For strategy 2, if you are doing a proof by contradiction and you have a given `h : Â¬P`, then the tactic `contradict h` will set the goal to be `P`, which will complete the proof by contradicting `h`.  In fact, this tactic can be used with any given; if you have a given `h : P`, where `P` is not a negative statement, then `contradict h` will set the goal to be `Â¬P`.  If you're not doing a proof by contradiction, then the tactic `contradict h with h'` will first initiate a proof by contradiction by assuming the negation of the goal, giving that assumption the identifier `h'`, and then it will set the goal to be the negation of `h`.  In other words, `contradict h with h'` is shorthand for `by_contra h'; contradict h`.

We can illustrate this with yet another way to write the proof from Example 3.2.4.  Our first three steps will be the same as last time:

::: {.inout}
::: {.inpt}
```lean
theorem Example_3_2_4_v3 (P Q R : Prop)
(h : P â†’ (Q â†’ R)) : Â¬R â†’ (P â†’ Â¬Q) := by
  assume h2 : Â¬R
  assume h3 : P
  by_contra h4
```
:::

::: {.outpt}
```state
P Q R : Prop
h : P â†’ Q â†’ R
h2 : Â¬R
h3 : P
h4 : Q
âŠ¢ False
```
:::
:::

Since we are now doing a proof by contradiction and the given `h2 : Â¬R` is a negative statement, a likely way to proceed is to try to prove `R`, which would contradict `h2`.  So we use the tactic `contradict h2`:

::: {.inout}
::: {.inpt}
```lean
theorem Example_3_2_4_v3 (P Q R : Prop)
(h : P â†’ (Q â†’ R)) : Â¬R â†’ (P â†’ Â¬Q) := by
  assume h2 : Â¬R
  assume h3 : P
  by_contra h4
  contradict h2
```
:::

::: {.outpt}
```state
P Q R : Prop
h : P â†’ Q â†’ R
h2 : Â¬R
h3 : P
h4 : Q
âŠ¢ R
```
:::
:::

As before, we can now prove `R` by combining `h`, `h3`, and `h4`.  In fact, we could do it in one step: by modus ponens, `h h3` is a proof of `Q â†’ R`, and therefore, by another application of modus ponens, `(h h3) h4` is a proof of `R`.  The parentheses here are not necessary; Lean will interpret `h h3 h4` as `(h h3) h4`, so we can complete the proof like this:

::: {.inout}
::: {.inpt}
```lean
theorem Example_3_2_4_v3 (P Q R : Prop)
(h : P â†’ (Q â†’ R)) : Â¬R â†’ (P â†’ Â¬Q) := by
  assume h2 : Â¬R
  assume h3 : P
  by_contra h4
  contradict h2
  show R from h h3 h4
```
:::

::: {.outpt}
```state
!!Goals accomplished ðŸŽ‰
```
:::
:::

You could shorten this proof slightly by replacing the lines `by_contra h4` and `contradict h2` with the single line `contradict h2 with h4`.

There is one more idea that is introduced in Section 3.2 of *HTPI*.  The last example in that section illustrates how you can sometimes use rules of inference to work backwards.  Here's a similar example in Lean:

::: {.inout}
::: {.inpt}
```lean
theorem Like_Example_3_2_5
(U : Type) (A B C : Set U) (a : U)
(h1 : a âˆˆ A) (h2 : a âˆ‰ A \ B)
(h3 : a âˆˆ B â†’ a âˆˆ C) : a âˆˆ C := by
```
:::

::: {.outpt}
```state
U : Type
A B C : Set U
a : U
h1 : a âˆˆ A
h2 : Â¬a âˆˆ A \ B
h3 : a âˆˆ B â†’ a âˆˆ C
âŠ¢ a âˆˆ C
```
:::
:::

The goal is `a âˆˆ C`, and the only given that even mentions `C` is `h3 : a âˆˆ B â†’ a âˆˆ C`.  If only we could prove `a âˆˆ B`, then we could apply `h3`, using modus ponens, to reach our goal.  So it would make sense to work toward the goal of proving `a âˆˆ B`.

To get Lean to use this proof strategy, we use the tactic `apply h3 _`.  The underscore here represents a blank to be filled in by Lean.  You might think of this tactic as asking Lean the question: If we want `h3 _` to be a proof of the goal `a âˆˆ C`, what do we have to put in the blank?  Lean is able to figure out that the answer is: a proof of `a âˆˆ B`.  So it sets the goal to be `a âˆˆ B`, since a proof of that goal, when inserted into the blank in `h3 _`, would prove the original goal `a âˆˆ C`:

::: {.inout}
::: {.inpt}
```lean
theorem Like_Example_3_2_5
(U : Type) (A B C : Set U) (a : U)
(h1 : a âˆˆ A) (h2 : a âˆ‰ A \ B)
(h3 : a âˆˆ B â†’ a âˆˆ C) : a âˆˆ C := by
  apply h3 _
```
:::

::: {.outpt}
```state
U : Type
A B C: Set U
a : U
h1 : a âˆˆ A
h2 : Â¬a âˆˆ A \ B
h3 : a âˆˆ B â†’ a âˆˆ C
âŠ¢ a âˆˆ B
```
:::
:::

It may not be clear what to do next, but the given `h2` is a negative statement, so perhaps reexpressing it will help.  Writing out the definition of set difference, `h2` means `Â¬(a âˆˆ A âˆ§ a âˆ‰ B)`, and then one of De Morgan's laws and a conditional law allow us to rewrite it first as `(a âˆ‰ A âˆ¨ a âˆˆ B)` and then as `(a âˆˆ A â†’ a âˆˆ B)`.  Of course, we have tactics to accomplish all of these reexpressions:

::: {.inout}
::: {.inpt}
```lean
theorem Like_Example_3_2_5
(U : Type) (A B C : Set U) (a : U)
(h1 : a âˆˆ A) (h2 : a âˆ‰ A \ B)
(h3 : a âˆˆ B â†’ a âˆˆ C) : a âˆˆ C := by
  apply h3 _
  define at h2
  demorgan at h2; conditional at h2
```
:::

::: {.outpt}
```state
U : Type
A B C : Set U
a : U
h1 : a âˆˆ A
h2 : a âˆˆ A â†’ a âˆˆ B
h3 : a âˆˆ B â†’ a âˆˆ C
âŠ¢ a âˆˆ B
```
:::
:::

And now it is easy to complete the proof by applying modus ponens, using `h2` and `h1`:

::: {.inout}
::: {.inpt}
```lean
theorem Like_Example_3_2_5
(U : Type) (A B C : Set U) (a : U)
(h1 : a âˆˆ A) (h2 : a âˆ‰ A \ B)
(h3 : a âˆˆ B â†’ a âˆˆ C) : a âˆˆ C := by
  apply h3 _
  define at h2
  demorgan at h2; conditional at h2
  show a âˆˆ B from h2 h1
```
:::

::: {.outpt}
```state
!!Goals accomplished ðŸŽ‰
```
:::
:::

We will see many more uses of the `apply` tactic later in this book.

Sections 3.1 and 3.2 of *HTPI* contain several proofs that involve algebraic reasoning.  Although one can do such proofs in Lean, it requires ideas that we are not ready to introduce yet.  So for the moment we will stick to proofs involving only logic and set theory.

## 3.3. Proofs Involving Quantifiers

In the notation used in *HTPI*, if $P(x)$ is a statement about $x$, then $\forall x\, P(x)$ means "for all $x$, $P(x)$" and $\exists x\, P(x)$ means "there exists at least one $x$ such that $P(x)$."  The letter $P$ here is not a proposition; it is only when it is applied to some object $x$ that we get a proposition.  We will say that $P$ is a *predicate*, and when we apply $P$ to an object $x$ we get a proposition $P(x)$.  You might want to think of the predicate $P$ as representing some property that an object might have, and the proposition $P(x)$ asserts that $x$ has that property.

To use a predicate in Lean, you must tell Lean the type of objects to which it applies.  If `U` is a type, then `Pred U` is the type of predicates that apply to objects of type `U`.  If `P` has type `Pred U` (that is, `P` is a predicate applying to objects of type `U`) and `x` has type `U`, then to apply `P` to `x` we just write `P x` (with a space but no parentheses).  Thus, if we have `P : Pred U` and `x : U`, then `P x` is an expression of type `Prop`.  That is, `P x` is a proposition, and its meaning is that `x` has the property represented by the predicate `P`.

There are a few differences between the way quantified statements are written in *HTPI* and the way they are written in Lean.  First of all, when we apply a quantifier to a variable in Lean we will specify the type of the variable explicitly.  Also, Lean requires that after specifying the variable and its type, you must put a comma before the proposition to which the quantifier is applied.  Thus, if `P` has type `Pred U`, then to say that `P` holds for all objects of type `U` we would write `âˆ€ (x : U), P x`.  Similarly, `âˆƒ (x : U), P x` is the proposition asserting that there exists at least one `x` of type `U` such that `P x`.

And there is one more important difference between the way quantified statements are written in *HTPI* and Lean.  In *HTPI*, a quantifier is interpreted as applying to as little as possible.  Thus, $\forall x\, P(x) \wedge Q(x)$ is interpreted as $(\forall x\, P(x)) \wedge Q(x)$; if you want the quantifier $\forall x$ to apply to the entire statement $P(x) \wedge Q(x)$ you must use parentheses and write $\forall x(P(x) \wedge Q(x))$.  The convention in Lean is exactly the opposite:  a quantifier applies to as much as possible.  Thus, Lean will interpret `âˆ€ (x : U), P x âˆ§ Q x` as meaning `âˆ€ (x : U), (P x âˆ§ Q x)`.  If you want the quantifier to apply to only `P x`, then you must use parentheses and write `(âˆ€ (x : U), P x) âˆ§ Q x`.

With this preparation, we are ready to consider how to write proofs involving quantifiers in Lean.  The most common way to prove a goal of the form `âˆ€ (x : U), P x` is to use the following strategy:

#### To prove a goal of the form `âˆ€ (x : U), P x`:

::: {.ind}
Let `x` stand for an arbitrary object of type `U` and prove `P x`.  If the letter `x` is already being used in the proof to stand for something, then you must choose an unused variable, say `y`, to stand for the arbitrary object, and prove `P y`.
:::

To do this in Lean, you should use the tactic `fix x : U`, which tells Lean to treat `x` as standing for some fixed but arbitrary object of type `U`.  This has the following effect on the tactic state:

::: {.lftrt}
::: {.bef}
```state
!! â‹®
âŠ¢ âˆ€ (x : U), P x
```
:::

::: {.aft}
```state
!! â‹®
x : U
âŠ¢ P x
```
:::
:::

To use a given of the form `âˆ€ (x : U), P x`, we usually apply a rule of inference called *universal instantiation*, which is described by the following proof strategy:

#### To use a given of the form `âˆ€ (x : U), P x`:

::: {.ind}
You may plug in any value of type `U`, say `a`, for `x` and use this given to conclude that `P a` is true.
:::

This strategy says that if you have `h : âˆ€ (x : U), P x` and `a : U`, then you can infer `P a`.  Indeed, in this situation Lean will recognize `h a` as a proof of `P a`.  For example, you can write `have h' : P a := h a` in a Lean tactic-mode proof, and Lean will add `h' : P a` to the tactic state.

Let's try these strategies out in a Lean proof.  Consider the following theorem:

::: {.inout}
::: {.inpt}
```lean
theorem two_pred (U : Type) (P Q : Pred U)
(h1 : âˆ€ (x : U), P x â†’ Â¬Q x)
(h2 : âˆ€ (x : U), Q x) :
Â¬âˆƒ (x : U), P x := by
```
:::

::: {.outpt}
```state
U : Type
P Q : Pred U
h1 : âˆ€ (x : U), P x â†’ Â¬Q x
h2 : âˆ€ (x : U), Q x
âŠ¢ Â¬âˆƒ (x : U), P x
```
:::
:::

To use the givens `h1` and `h2`, we will probably want to use universal instantiation.  But to do that we would need an object of type `U` to plug in for `x` in `h1` and `h2`, and there is no object of type `U` in the tactic state.  So at this point, we can't apply universal instantiation to `h1` and `h2`.  We should watch for an object of type `U` to come up in the course of the proof, and consider applying universal instantiation if one does.  Until then, we turn our attention to the goal.

The goal is a negative statement, so we begin by reexpressing it as an equivalent positive statement, using a quantifier negation law.  The tactic `quant_neg` applies a quantifier negation law to rewrite the goal in the equivalent form `âˆ€ (x : U), Â¬P x`.  As with the other tactics for applying logical equivalences, you can write `quant_neg at h` if you want to apply a quantifier negation law to a given `h`.

::: {.inout}
::: {.inpt}
```lean
theorem two_pred (U : Type) (P Q : Pred U)
(h1 : âˆ€ (x : U), P x â†’ Â¬Q x)
(h2 : âˆ€ (x : U), Q x) :
Â¬âˆƒ (x : U), P x := by
  quant_neg     --Goal is now âˆ€ (x : U), Â¬P x
```
:::

::: {.outpt}
```state
U : Type
P Q : Pred U
h1 : âˆ€ (x : U), P x â†’ Â¬Q x
h2 : âˆ€ (x : U), Q x
âŠ¢ âˆ€ (x : U), Â¬P x
```
:::
:::

Now the goal starts with `âˆ€`, so we use the strategy above and introduce an arbitrary object of type `U`.  Since the variable `x` occurs as a bound variable in several statements in this theorem, it might be best to use a different letter for the arbitrary object; this isn't absolutely necessary, but it may help to avoid confusion.  So our next tactic is `fix y : U`, and it has the following effect.

::: {.inout}
::: {.inpt}
```lean
theorem two_pred (U : Type) (P Q : Pred U)
(h1 : âˆ€ (x : U), P x â†’ Â¬Q x)
(h2 : âˆ€ (x : U), Q x) :
Â¬âˆƒ (x : U), P x := by
  quant_neg     --Goal is now âˆ€ (x : U), Â¬P x
  fix y : U
```
:::

::: {.outpt}
```state
U : Type
P Q : Pred U
h1 : âˆ€ (x : U), P x â†’ Â¬Q x
h2 : âˆ€ (x : U), Q x
y : U
âŠ¢ Â¬P y
```
:::
:::

Now we have an object of type `U` in the tactic state, namely, `y`.  So let's try applying universal instantiation to `h1` and `h2` and see if it helps.

::: {.inout}
::: {.inpt}
```lean
theorem two_pred (U : Type) (P Q : Pred U)
(h1 : âˆ€ (x : U), P x â†’ Â¬Q x)
(h2 : âˆ€ (x : U), Q x) :
Â¬âˆƒ (x : U), P x := by
  quant_neg     --Goal is now âˆ€ (x : U), Â¬P x
  fix y : U
  have h3 : P y â†’ Â¬Q y := h1 y
  have h4 : Q y := h2 y
```
:::

::: {.outpt}
```state
U : Type
P Q : Pred U
h1 : âˆ€ (x : U), P x â†’ Â¬Q x
h2 : âˆ€ (x : U), Q x
y : U
h3 : P y â†’ Â¬Q y
h4 : Q y
âŠ¢ Â¬P y
```
:::
:::

We're almost done, because the goal now follows easily from `h3` and `h4`.  If we use the contrapositive law to rewrite `h3` as `Q y â†’ Â¬P y`, then we can apply modus ponens to the rewritten `h3` and `h4` to reach the goal:

::: {.inout}
::: {.inpt}
```lean
theorem two_pred (U : Type) (P Q : Pred U)
(h1 : âˆ€ (x : U), P x â†’ Â¬Q x)
(h2 : âˆ€ (x : U), Q x) :
Â¬âˆƒ (x : U), P x := by
  quant_neg     --Goal is now âˆ€ (x : U), Â¬P x
  fix y : U
  have h3 : P y â†’ Â¬Q y := h1 y
  have h4 : Q y := h2 y
  contrapos at h3  --Now h3 : Q y â†’ Â¬P y
  show Â¬P y from h3 h4
```
:::

::: {.outpt}
```state
!!Goals accomplished ðŸŽ‰
```
:::
:::