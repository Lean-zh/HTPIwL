<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>How To Prove It With Lean - 4&nbsp; Relations</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Chap3.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="HTPIwLstyles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Relations</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">How To Prove It With Lean</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Sentential Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Quantificational Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./IntroLean.html" class="sidebar-item-text sidebar-link">Introduction to Lean</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap3.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Proofs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap4.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Relations</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul class="collapse">
  <li><a href="#ordered-pairs-and-cartesian-products" id="toc-ordered-pairs-and-cartesian-products" class="nav-link active" data-scroll-target="#ordered-pairs-and-cartesian-products">4.1. Ordered Pairs and Cartesian Products</a></li>
  <li><a href="#relations" id="toc-relations" class="nav-link" data-scroll-target="#relations">4.2. Relations</a></li>
  <li><a href="#more-about-relations" id="toc-more-about-relations" class="nav-link" data-scroll-target="#more-about-relations">4.3. More About Relations</a></li>
  <li><a href="#ordering-relations" id="toc-ordering-relations" class="nav-link" data-scroll-target="#ordering-relations">4.4. Ordering Relations</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<div class="hidden">
$$
\newcommand{\setmin}{\mathbin{\backslash}}
\newcommand{\symmdiff}{\bigtriangleup}
$$
</div>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Relations</span></h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<section id="ordered-pairs-and-cartesian-products" class="level2">
<h2 class="anchored" data-anchor-id="ordered-pairs-and-cartesian-products">4.1. Ordered Pairs and Cartesian Products</h2>
<p>Section 4.1 of <em>How To Prove It</em> defines the <em>Cartesian product</em> <span class="math inline">\(A \times B\)</span> of two sets <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> to be the set of all ordered pairs <span class="math inline">\((a, b)\)</span>, where <span class="math inline">\(a \in A\)</span> and <span class="math inline">\(b \in B\)</span>. However, in Lean, Cartesian product is an operation on <em>types</em>, not sets. If <code>A</code> and <code>B</code> are types, then <code>A × B</code> is the type of ordered pairs <code>(a, b)</code>, where <code>a</code> has type <code>A</code> and <code>b</code> has type <code>B</code>. In other words, if you have <code>a : A</code> and <code>b : B</code>, then <code>(a, b)</code> is an object of type <code>A × B</code>. There is also notation for the first and second coordinates of an ordered pair. If <code>p</code> has type <code>A × B</code>, then <code>p.1</code> is the first coordinate of <code>p</code>, and <code>p.2</code> is the second coordinate. This means that <code>p = (p.1, p.2)</code>. You can also use the notation <code>p.fst</code> for the first coordinate of <code>p</code> and <code>p.snd</code> for the second coordinate.</p>
</section>
<section id="relations" class="level2">
<h2 class="anchored" data-anchor-id="relations">4.2. Relations</h2>
<p>Section 4.2 of <em>HTPI</em> defines a <em>relation from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span></em> to be a subset of <span class="math inline">\(A \times B\)</span>. In other words, if <span class="math inline">\(R\)</span> is a relation from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span>, then <span class="math inline">\(R\)</span> is a set whose element are ordered pairs <span class="math inline">\((a, b)\)</span>, where <span class="math inline">\(a \in A\)</span> and <span class="math inline">\(b \in B\)</span>. We will see in the next section that in Lean, it is convenient to use a somewhat different definition of relations. Nevertheless, we will take some time in this section to study sets of ordered pairs. If <code>A</code> and <code>B</code> are types, and <code>R</code> is a set whose elements are ordered pairs <code>(a, b)</code>, where <code>a</code> has type <code>A</code> and <code>b</code> has type <code>B</code>, then <code>R</code> has type <code>Set (A × B)</code>.</p>
<p>Section 4.2 of <em>HTPI</em> discusses several concepts concerning relations. Here is how these concepts are defined in <em>HTPI</em>:</p>
<div class="ndfn" data-arguments="Definition 4.2.3">
<p>Suppose <span class="math inline">\(R\)</span> is a relation from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span>. Then the <em>domain</em> of <span class="math inline">\(R\)</span> is the set</p>
<div class="quote">
<p><span class="math inline">\(\text{Dom}(R) = \{a \in A \mid \exists b \in B((a, b) \in R)\}\)</span>.</p>
</div>
<p>The <em>range</em> of <span class="math inline">\(R\)</span> is the set</p>
<div class="quote">
<p><span class="math inline">\(\text{Ran}(R) = \{b \in B \mid \exists a \in A((a, b) \in R)\}\)</span>.</p>
</div>
<p>The <em>inverse</em> of <span class="math inline">\(R\)</span> is the relation <span class="math inline">\(R^{-1}\)</span> from <span class="math inline">\(B\)</span> to <span class="math inline">\(A\)</span> define as follows:</p>
<div class="quote">
<p><span class="math inline">\(R^{-1} = \{(b, a) \in B \times A \mid (a, b) \in R\}\)</span>.</p>
</div>
<p>Finally, suppose <span class="math inline">\(R\)</span> is a relation from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span> and <span class="math inline">\(S\)</span> is a relation from <span class="math inline">\(B\)</span> to <span class="math inline">\(C\)</span>. Then the <em>composition</em> of <span class="math inline">\(S\)</span> and <span class="math inline">\(R\)</span> is the relation <span class="math inline">\(S \circ R\)</span> from <span class="math inline">\(A\)</span> to <span class="math inline">\(C\)</span> defined as follows:</p>
<div class="quote">
<p><span class="math inline">\(S \circ R = \{(a, c) \in A \times C \mid \exists b \in B((a, b) \in R \text{ and } (b, c) \in S)\}\)</span>.</p>
</div>
</div>
<p>There are several examples in <em>HTPI</em> that illustrate these definitions. We will focus here on seeing how to work with these concepts in Lean.</p>
<p>We can write corresponding definitions in Lean as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Dom {A B : <span class="kw">Type</span>} (R : Set (A × B)) : Set A :=</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    {a : A | ∃ (b : B), (a, b) ∈ R}</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Ran {A B : <span class="kw">Type</span>} (R : Set (A × B)) : Set B :=</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    {b : B | ∃ (a : A), (a, b) ∈ R}</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> inv {A B : <span class="kw">Type</span>} (R : Set (A × B)) : Set (B × A) :=</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    {(b, a) : B × A | (a, b) ∈ R}</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> comp {A B C : <span class="kw">Type</span>} (S : Set (B × C)) (R : Set (A × B)) :</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    Set (A × C) := {(a, c) : A × C | ∃ (x : B), (a, x) ∈ R ∧ (x, c) ∈ S}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Definitions in Lean are introduced with the keyword <code>def</code>. In the definition of <code>Dom</code>, we have declared that <code>A</code> and <code>B</code> are implicit arguments and <code>R</code> is an explicit argument. That means that if we have <code>R : Set (A × B)</code>, then we can just write <code>Dom R</code> for the domain of <code>R</code>, and Lean will figure out for itself what <code>A</code> and <code>B</code> are. After the list of arguments there is a colon and then the type of <code>Dom R</code>, which is <code>Set A</code>. This is followed by <code>:=</code> and then the definition of <code>Dom R</code>. The definition says that <code>Dom R</code> is the set of all objects <code>a</code> of type <code>A</code> such that there is some <code>b</code> of type <code>B</code> with <code>(a, b) ∈ R</code>. This is a direct translation, into Lean’s type-theory language, of the first part of Definition 4.2.3. The other three definitions are similar; they define <code>Ran R</code> to be the range of <code>R</code>, <code>inv R</code> to be the inverse of <code>R</code>, and <code>comp S R</code> to be the composition of <code>S</code> and <code>R</code>.</p>
<p>Here is the main theorem about these concepts, as stated in <em>HTPI</em>:</p>
<div class="nthm" data-arguments="Theorem 4.2.5">
<p>Suppose <span class="math inline">\(R\)</span> is a relation from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span>, <span class="math inline">\(S\)</span> is a relation from <span class="math inline">\(B\)</span> to <span class="math inline">\(C\)</span>, and <span class="math inline">\(T\)</span> is a relation from <span class="math inline">\(C\)</span> to <span class="math inline">\(D\)</span>. Then:</p>
<ol type="1">
<li><span class="math inline">\((R^{-1})^{-1} = R\)</span>.</li>
<li><span class="math inline">\(\mathrm{Dom}(R^{-1}) = \mathrm{Ran}(R)\)</span>.</li>
<li><span class="math inline">\(\mathrm{Ran}(R^{-1}) = \mathrm{Dom}(R)\)</span>.</li>
<li><span class="math inline">\(T \circ (S \circ R) = (T \circ S) \circ R\)</span>.</li>
<li><span class="math inline">\((S \circ R)^{-1} = R^{-1} \circ S^{-1}\)</span>.</li>
</ol>
</div>
<p>All five parts of this theorem follow directly from the definitions of the relevant concepts. In fact, in the first three parts, Lean recognizes the two sides of the equation as being definitionally equal, and therefore the tactic <code>rfl</code> proves those parts:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_2_5_1 {A B : <span class="kw">Type</span>}</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    (R : Set (A × B)) : inv (inv R) = R := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_2_5_2 {A B : <span class="kw">Type</span>}</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    (R : Set (A × B)) : Dom (inv R) = Ran R := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_2_5_3 {A B : <span class="kw">Type</span>}</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    (R : Set (A × B)) : Ran (inv R) = Dom R := <span class="kw">by</span> <span class="kw">rfl</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The fourth part will take a little more work to prove. We start the proof like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_2_5_4 {A B C D : <span class="kw">Type</span>}</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    (R : Set (A × B)) (S : Set (B × C)) (T : Set (C × D)) :</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    comp T (comp S R) = comp (comp T S) R := <span class="kw">by</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> (a, d) : A × D</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>After the <code>apply Set.ext</code> tactic, the goal is</p>
<div class="quote">
<p><code>∀ (x : A × D), x ∈ comp T (comp S R) ↔︎ x ∈ comp (comp T S) R</code></p>
</div>
<p>The next step should be to introduce an arbitrary object of type <code>A × D</code>. We could just call this object <code>x</code>, but Lean let’s us use a shortcut here. An object of type <code>A × D</code> must have the form of an ordered pair, where the first coordinate has type <code>A</code> and the second has type <code>D</code>. So Lean let’s us write it as an ordered pair right away. That’s what we’ve done in the second step, <code>fix (a, d) : A × D</code>. This tactic introduces two new variables into the proof, <code>a : A</code> and <code>d : D</code>. (The proof in <em>HTPI</em> uses a similar shortcut. And we used a similar shortcut in the definitions of <code>inv R</code> and <code>comp R</code>, where the elements of these sets were written as ordered pairs.)</p>
<p>Here is the complete proof.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_2_5_4 {A B C D : <span class="kw">Type</span>}</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    (R : Set (A × B)) (S : Set (B × C)) (T : Set (C × D)) :</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    comp T (comp S R) = comp (comp T S) R := <span class="kw">by</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> (a, d) : A × D</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (→)</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : (a, d) ∈ comp T (comp S R)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>                     <span class="co">--Goal:  (a, d) ∈ comp (comp T S) R</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>             <span class="co">--Goal: ∃ (x : B), (a, x) ∈ R ∧ (x, d) ∈ comp T S</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1       <span class="co">--h1: ∃ (x : C), (a, x) ∈ comp S R ∧ (x, d) ∈ T</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (c : C) (h2 : (a, c) ∈ comp S R ∧ (c, d) ∈ T) <span class="kw">from</span> h1</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : (a, c) ∈ comp S R := h2.left</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h3       <span class="co">--h3: ∃ (x : B), (a, x) ∈ R ∧ (x, c) ∈ S</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (b : B) (h4 : (a, b) ∈ R ∧ (b, c) ∈ S) <span class="kw">from</span> h3</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro b    <span class="co">--Goal:  (a, b) ∈ R ∧ (b, d) ∈ comp T S</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro h4.left <span class="co">--Goal:  (b, d) ∈ comp T S</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>                  <span class="co">--Goal:  ∃ (x : C), (b, x) ∈ S ∧ (x, d) ∈ T</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ∃ (x : C), (b, x) ∈ S ∧ (x, d) ∈ T <span class="kw">from</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    Exists.intro c (And.intro h4.right h2.right)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (←)</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : (a, d) ∈ comp (comp T S) R</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>; <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (b : B) (h2 : (a, b) ∈ R ∧ (b, d) ∈ comp T S) <span class="kw">from</span> h1</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : (b, d) ∈ comp T S := h2.right</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h3</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (c : C) (h4 : (b, c) ∈ S ∧ (c, d) ∈ T) <span class="kw">from</span> h3</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro c</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro _ h4.right</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ∃ (x : B), (a, x) ∈ R ∧ (x, c) ∈ S <span class="kw">from</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    Exists.intro b (And.intro h2.left h4.left)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Of course, if you have trouble reading this proof, you can type it into Lean and see how the tactic state changes over the course of the proof.</p>
<p>The proof of part 5 of the theorem is similar. We’ll leave it as an exercise for you.</p>
</section>
<section id="more-about-relations" class="level2">
<h2 class="anchored" data-anchor-id="more-about-relations">4.3. More About Relations</h2>
<p>Section 4.3 of <em>HTPI</em> introduces new notation for working with relations. If <span class="math inline">\(R \subseteq A \times B\)</span>, <span class="math inline">\(a \in A\)</span>, and <span class="math inline">\(b \in B\)</span>, then <em>HTPI</em> introduces the notation <span class="math inline">\(aRb\)</span> as an alternative way of saying <span class="math inline">\((a, b) \in R\)</span>.</p>
<p>The notation we will use in Lean is slightly different. Corresponding to the notation <span class="math inline">\(aRb\)</span> in <em>HTPI</em>, in Lean we will use the notation <code>R a b</code>. And we cannot use this notation when <code>R</code> has type <code>Set (A × B)</code>. Rather, we will need to introduce a new type for the variable <code>R</code> in the notation <code>R a b</code>. The name we will use for this new type is <code>Rel A B</code>. Thus, if <code>R</code> has type <code>Rel A B</code>, <code>a</code> has type <code>A</code>, and <code>b</code> has type <code>B</code>, then <code>R a b</code> is a proposition. This should remind you of the way predicates work in Lean. If we have <code>P : Pred A</code>, then we think of <code>P</code> as representing a property that an object of type <code>A</code> might have, and if we also have <code>a : A</code>, then <code>P a</code> is the proposition asserting that <code>a</code> has the property represented by <code>P</code>. Similarly, if we have <code>R : Rel A B</code>, then we can think of <code>R</code> as representing a relationship that might hold between an object of type <code>A</code> and an object of type <code>B</code>, and if we also have <code>a : A</code> and <code>b : B</code>, then <code>R a b</code> is the proposition asserting that the relationship represented by <code>R</code> holds between <code>a</code> and <code>b</code>.</p>
<p>Notice that in <em>HTPI</em>, the same variable <span class="math inline">\(R\)</span> is used in both the notation <span class="math inline">\(aRb\)</span> and <span class="math inline">\((a, b) \in R\)</span>. But in Lean, the notation <code>R a b</code> is used when <code>R</code> has type <code>Rel A B</code>, and the notation <code>(a, b) ∈ R</code> is used when <code>R</code> has type <code>Set (A × B)</code>. The types <code>Rel A B</code> and <code>Set (A × B)</code> are different, so we cannot use the same variable <code>R</code> in the two notations. However, there is a correspondence between the two types. Suppose <code>R</code> has type <code>Rel A B</code>. If we let <code>R'</code> denote the set of all ordered pairs <code>(a, b) : A × B</code> such that the proposition <code>R a b</code> is true, then <code>R'</code> has type <code>Set (A × B)</code>. And there is then a simple relationship between <code>R</code> and <code>R'</code>: for any objects <code>a : A</code> and <code>b : B</code>, the propositions <code>R a b</code> and <code>(a, b) ∈ R'</code> are equivalent. For our work in Lean, we will say that <code>R</code> is a <em>relation</em> from <code>A</code> to <code>B</code>, and <code>R'</code> is the <em>extension</em> of <code>R</code>.</p>
<p>We can define the extension of a relation in Lean as follows:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> extension {A B : <span class="kw">Type</span>} (R : Rel A B) : Set (A × B) :=</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    {(a, b) : A × B | R a b}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The rest of Chapter 4 of <em>HTPI</em> focuses on relations from a set to itself; in Lean, the corresponding idea is a relation from a type to itself. If <code>A</code> is any type and <code>R</code> has type <code>Rel A A</code>, then we will say that <code>R</code> is a <em>binary relation on <code>A</code></em>. We define <code>BinRel A</code> to be the type of binary relations on <code>A</code>. In other words, <code>BinRel A</code> is just an abbreviation for <code>Rel A A</code>. If <code>R</code> is a binary relation on <code>A</code>, then we say that <code>R</code> is <em>reflexive</em> if for every <code>a</code> of type <code>A</code>, <code>R a a</code> holds. It is <em>symmetric</em> if for all <code>a</code> and <code>b</code> of type <code>A</code>, if <code>R a b</code> then <code>R b a</code>. And it is <em>transitive</em> if for all <code>a</code>, <code>b</code>, and <code>c</code> of type <code>A</code>, if <code>R a b</code> and <code>R b c</code> then <code>R a c</code>. Of course, we can tell Lean about these definitions:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reflexive {A : <span class="kw">Type</span>} (R : BinRel A) : <span class="kw">Prop</span> :=</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    ∀ (a : A), R a a</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> symmetric {A : <span class="kw">Type</span>} (R : BinRel A) : <span class="kw">Prop</span> :=</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    ∀ (a b : A), R a b → R b a</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> transitive {A : <span class="kw">Type</span>} (R : BinRel A) : <span class="kw">Prop</span> :=</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    ∀ (a b c : A), R a b → R b c → R a c</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Once again, we refer you to <em>HTPI</em> to see examples of these concepts, and we focus here on proving theorems about these concepts in Lean. The main theorem about these concepts in Section 4.3 of <em>HTPI</em> is Theorem 4.3.4. Here is what it says:</p>
<div class="nthm" data-arguments="Theorem 4.3.4">
<p>Suppose <span class="math inline">\(R\)</span> is a relation on a set <span class="math inline">\(A\)</span>.</p>
<ol type="1">
<li><span class="math inline">\(R\)</span> is reflexive iff <span class="math inline">\(\{(x, y) \in A \times A \mid x = y\} \subseteq R\)</span>.</li>
<li><span class="math inline">\(R\)</span> is symmetric iff <span class="math inline">\(R = R^{-1}\)</span>.</li>
<li><span class="math inline">\(R\)</span> is transitive iff <span class="math inline">\(R \circ R \subseteq R\)</span>.</li>
</ol>
</div>
<p>We can prove corresponding statements in Lean, but we’ll have to be careful to distinguish between the types <code>BinRel A</code> and <code>Set (A × A)</code>. In <em>HTPI</em>, each of the three statements in the theorem uses the same letter <span class="math inline">\(R\)</span> on both sides of the “iff”, but we can’t write the statements that way in Lean. In each statement, the part before “iff” uses a concept that was defined for objects of type <code>BinRel A</code>, whereas the part after “iff” uses concepts that only make sense for objects of type <code>Set (A × A)</code>. So we’ll have to rephrase the statements by using the correspondence between a relation <code>R</code> of type <code>BinRel A</code> and its extension, which has type <code>Set (A × A)</code>. Here’s the Lean theorem corresponding to statement 2 of Theorem 4.3.4:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_3_4_2 {A : <span class="kw">Type</span>} (R : BinRel A) :</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    symmetric R ↔ extension R = inv (extension R) := <span class="kw">by</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (→)</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : symmetric R</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> (a, b) : A × A</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">--Goal:  (a, b) ∈ extension R ↔ (a, b) ∈ inv (extension R)</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">--Next we fill in the definitions of both sides of the goal</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> : (a, b) ∈ extension R</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> : (a, b) ∈ inv (extension R)  <span class="co">--Goal:  R a b ↔ R b a</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1  <span class="co">--h1: ∀ (a b : A), R a b → R b a</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> R a b ↔ R b a <span class="kw">from</span> Iff.intro (h1 a b) (h1 b a)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (←)</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : extension R = inv (extension R)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>  <span class="co">--Goal:  ∀ (a b : A), R a b → R b a</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : A; <span class="kw">fix</span> b : A</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : R a b  <span class="co">--Goal:  R b a</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : (a, b) ∈ extension R := h2  <span class="co">--h2, h3 are definitionally equal</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h1] <span class="kw">at</span> h3</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h3</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> R b a <span class="kw">from</span> h3</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We’ll leave the proofs of the other two statements as exercises for you.</p>
</section>
<section id="ordering-relations" class="level2">
<h2 class="anchored" data-anchor-id="ordering-relations">4.4. Ordering Relations</h2>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Chap3.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Proofs</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->



</body></html>