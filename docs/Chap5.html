<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>How To Prove It With Lean - 5&nbsp; Functions</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Chap4.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="HTPIwLstyles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Functions</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">How To Prove It With Lean</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Sentential Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Quantificational Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./IntroLean.html" class="sidebar-item-text sidebar-link">Introduction to Lean</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap3.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Proofs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap4.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Relations</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap5.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Functions</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul class="collapse">
  <li><a href="#functions" id="toc-functions" class="nav-link active" data-scroll-target="#functions">5.1. Functions</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<div class="hidden">
$$
\newcommand{\setmin}{\mathbin{\backslash}}
\newcommand{\symmdiff}{\bigtriangleup}
$$
</div>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Functions</span></h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<section id="functions" class="level2">
<h2 class="anchored" data-anchor-id="functions">5.1. Functions</h2>
<p>The first definition in Chapter 5 of <em>HTPI</em> says that if <span class="math inline">\(F \subseteq A \times B\)</span>, then <span class="math inline">\(F\)</span> is called a <em>function</em> from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span> if for every <span class="math inline">\(a \in A\)</span> there is exactly one <span class="math inline">\(b \in B\)</span> such that <span class="math inline">\((a, b) \in F\)</span>. The notation <span class="math inline">\(F : A \to B\)</span> means that <span class="math inline">\(F\)</span> is a function from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span>. If <span class="math inline">\(F\)</span> is a function from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span> and <span class="math inline">\(a \in A\)</span>, then <em>HTPI</em> introduces the notation <span class="math inline">\(F(a)\)</span> for the unique <span class="math inline">\(b \in B\)</span> such that <span class="math inline">\((a, b) \in F\)</span>. Thus, if <span class="math inline">\(F : A \to B\)</span>, <span class="math inline">\(a \in A\)</span>, and <span class="math inline">\(b \in B\)</span>, then <span class="math inline">\(F(a) = b\)</span> means the same thing as <span class="math inline">\((a, b) \in F\)</span>. We sometimes call <span class="math inline">\(F(a)\)</span> the <em>value of <span class="math inline">\(F\)</span> at <span class="math inline">\(a\)</span></em>, or the <em>result of applying <span class="math inline">\(F\)</span> to <span class="math inline">\(a\)</span></em>.</p>
<p>This might remind you of the situation we faced in Chapter 4. If <span class="math inline">\(R \subseteq A \times B\)</span>, <span class="math inline">\(a \in A\)</span>, and <span class="math inline">\(b \in B\)</span>, then Chapter 4 of <em>HTPI</em> uses the notation <span class="math inline">\(aRb\)</span> to mean the same thing as <span class="math inline">\((a, b) \in R\)</span>. But in Lean, we found it necessary to change this notation. Instead of using <em>HTPI</em>’s notation <span class="math inline">\(aRb\)</span>, we introduced the notation <code>R a b</code>, which we use when <code>R</code> has type <code>Rel A B</code>, <code>a</code> has type <code>A</code>, and <code>b</code> has type <code>B</code>. (The notation <code>(a, b) ∈ R</code>, in contrast, can be used only when <code>R</code> has type <code>Set (A × B)</code>.) If <code>R</code> has type <code>Rel A B</code>, then we think of <code>R</code> as representing some relationship that might hold between <code>a</code> and <code>b</code>, and <code>R a b</code> as the proposition saying that this relationship holds. And although <code>R</code> is not a set of ordered pairs, there is a corresponding set, <code>extension R</code>, of type <code>Set (A × B)</code>, with the property that <code>(a, b) ∈ extension R</code> if and only if <code>R a b</code>.</p>
<p>We will take a similar approach to functions in this chapter. For any types <code>A</code> and <code>B</code>, we introduce a new type <code>A → B</code>. If <code>f</code> has type <code>A → B</code>, then we think of <code>f</code> as representing some operation that can be applied to an object of type <code>A</code> to produce a corresponding object of type <code>B</code>. We will say that <code>f</code> is a <em>function</em> from <code>A</code> to <code>B</code>, and if <code>a</code> has type <code>A</code>, then we write <code>f a</code> (with a space but no parentheses) for the result of applying the operation represented by <code>f</code> to the object <code>a</code>. Thus, if we have <code>f : A → B</code> and <code>a : A</code>, then <code>f a</code> has type <code>B</code>. As with relations, if <code>f</code> has type <code>A → B</code>, then <code>f</code> is not a set of ordered pairs. But there is a corresponding set of ordered pairs, which we will call the <em>graph</em> of <code>f</code>, whose elements are the ordered pairs <code>(a, b)</code> for which <code>f a = b</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> graph {A B : <span class="kw">Type</span>} (f : A → B) : Set (A × B) :=</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    { (a, b) : A × B | f a = b }</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> simp_graph {A B : <span class="kw">Type</span>} (f : A → B) (a : A) (b : B) :</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    (a, b) ∈ graph f ↔ f a = b := <span class="kw">by</span> <span class="kw">rfl</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Every set of type <code>Set (A × B)</code> is the extension of some relation from <code>A</code> to <code>B</code>, but not every such set is the graph of a function from <code>A</code> to <code>B</code>. To be the graph of a function, it must have the property that was used to define functions in <em>HTPI</em>: each object of type <code>A</code> must be paired in the set with exactly one object of type <code>B</code>. Let’s give this property a name:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_func_graph {A B : <span class="kw">Type</span>} (F : Set (A × B)) : <span class="kw">Prop</span> :=</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    ∀ (x : A), ∃! (y : B), (x, y) ∈ F</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>And now we can say that the sets of type <code>Set (A × B)</code> that are graphs of functions from <code>A</code> to <code>B</code> are precisely the ones that have the property <code>is_func_graph</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> func_from_graph {A B : <span class="kw">Type</span>} (F : Set (A × B)) :</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    (∃ (f : A → B), graph f = F) ↔ is_func_graph F</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We will ask you to prove the left-to-right direction of this theorem in the exercises. The right-to-left direction can also be proven in Lean, but the proof requires methods that go beyond the scope of this book. Nevertheless, we will go ahead and use the theorem when we find it useful.</p>
<p>Section 5.1 of <em>HTPI</em> proves two theorems about functions. The first gives a convenient way of proving that two functions are equal:</p>
<div class="nthm" data-arguments="Theorem 5.1.4">
<p>Suppose <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span> are functions from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span>. If <span class="math inline">\(\forall a \in A(f(a) = g(a))\)</span>, then <span class="math inline">\(f = g\)</span>.</p>
</div>
<p>The proof of this theorem in <em>HTPI</em> is based on the axiom of extensionality for sets. But in Lean, functions aren’t sets of ordered pairs, so this method of proof won’t work. Fortunately, Lean has a similar axiom of extensionality for functions. The axiom is called <code>funext</code>, and it proves Theorem 5.1.4.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_5_1_4 {A B : <span class="kw">Type</span>} (f g : A → B) :</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    (∀ (a : A), f a = g a) → f = g := funext</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We saw previously that if we are trying to prove <code>X = Y</code>, where <code>X</code> and <code>Y</code> both have type <code>Set U</code>, then often the best first step is the tactic <code>apply Set.ext</code>, which converts the goal to <code>∀ (x : U), x ∈ X ↔︎ x ∈ Y</code>. Similary, if we are trying to prove <code>f = g</code>, where <code>f</code> and <code>g</code> both have type <code>A → B</code>, then we will usually start with the tactic <code>apply funext</code>, which will convert the goal to <code>∀ (x : A), f x = g x</code>. By Theorem_5_1_4, this implies the original goal <code>f = g</code>. For example, here is a proof that if two functions have the same graph, then they are equal:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A B : <span class="kw">Type</span>} (f g : A → B) :</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    graph f = graph g → f = g := <span class="kw">by</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : graph f = graph g  <span class="co">--Goal: f = g</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> funext                   <span class="co">--Goal: ∀ (x : A), f x = g x</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : A</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : (x, f x) ∈ graph f := <span class="kw">by</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>                       <span class="co">--Goal: f x = f x</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h1] <span class="kw">at</span> h2             <span class="co">--h2: (x, f x) ∈ graph g</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2                   <span class="co">--h2: g x = f x</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> f x = g x <span class="kw">from</span> h2.symm</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The axiom of extensionality for sets says that a set is completely determined by its elements. This is what justifies our usual method of defining a set: we specify what its elements are, using notation like <code>{0, 1, 2}</code> or <code>{ x : Nat | x &lt; 3 }</code>. Similarly, the axiom of extensionality for functions says that a function is completely determined by its values, and therefore we can define a function by specifying its values. For instance, we can define a function from <code>Nat</code> to <code>Nat</code> by specifying, for any <code>n : Nat</code>, the result of applying the function to <code>n</code>. As an example of this, we could define the “squaring function” from <code>Nat</code> to <code>Nat</code> to be the function that, when applied to any <code>n : Nat</code>, produces the result <code>n^2</code>. Here are two ways to define this function in Lean:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> square1 (n : Nat) : Nat := n^2</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> square2 : Nat → Nat := fun (n : Nat) =&gt; n^2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The first of these definitions uses notation we have used before; it says that if <code>n</code> has type <code>Nat</code>, then the expression <code>square1 n</code> also has type <code>Nat</code>, and it is definitionally equal to <code>n^2</code>. The second definition introduces new Lean notation. It says that <code>square2</code> has type <code>Nat → Nat</code>, and it defines it to be the function that, when applied to any <code>n : Nat</code>, yields the result <code>n^2</code>. Of course, this also means that <code>square2 n</code> is definitionally equal to <code>n^2</code>. In general, the notation <code>fun (x : A) =&gt; ...</code> means “the function which, when applied to any <code>x</code> of type <code>A</code>, yields the result …” The two definitions above are equivalent. You can ask Lean to confirm this, and try out the squaring function, as follows:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> : square1 = square2 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> : square1 7 = 49 := <span class="kw">by</span> <span class="kw">rfl</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>There is one more theorem in Section 5.1 of <em>HTPI</em>. Theorem 5.1.5 says that if <span class="math inline">\(f\)</span> is a function from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span> and <span class="math inline">\(g\)</span> is a function from <span class="math inline">\(B\)</span> to <span class="math inline">\(C\)</span>, then the composition of <span class="math inline">\(g\)</span> and <span class="math inline">\(f\)</span> is a function from <span class="math inline">\(A\)</span> to <span class="math inline">\(C\)</span>. To state this theorem in Lean, we will have to make adjustments for the differences between the treatment of functions in <em>HTPI</em> and Lean. In Chapter 4, we defined <code>comp S R</code> to be the composition of <code>S</code> and <code>R</code>, where <code>R</code> has type <code>Set (A × B)</code> and <code>S</code> had type <code>Set (B × C)</code>. But functions in Lean are not sets of ordered pairs, so we cannot apply the operation <code>comp</code> to them. We can, however, apply it to their graphs. So the theorem corresponding to Theorem 5.1.5 in <em>HTPI</em> is this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_5_1_5 {A B C : <span class="kw">Type</span>} (f : A → B) (g : B → C) :</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    ∃ (h : A → C), graph h = comp (graph g) (graph f) := <span class="kw">by</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> h : A → C := fun (x : A) =&gt; g (f x)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro h</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> (a, c) : A × C</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Proof that (a, c) ∈ graph h → (a, c) ∈ comp (graph g) (graph f)</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : (a, c) ∈ graph h</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1    <span class="co">--h1: h a = c</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>          <span class="co">--Goal:  ∃ (x : B), (a, x) ∈ graph f ∧ (x, c) ∈ graph g</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (f a)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Proof that (a, f a) ∈ graph f</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>; <span class="kw">rfl</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Proof that (f a, c) ∈ graph g</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> g (f a) = c <span class="kw">from</span> h1</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Proof that (a, c) ∈ comp (graph g) (graph f) → (a, c) ∈ graph h</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : (a, c) ∈ comp (graph g) (graph f)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>          <span class="co">--Goal: h a = c</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1    <span class="co">--h1: ∃ (x : B), (a, x) ∈ graph f ∧ (x, c) ∈ graph g</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (b : B) (h2 : (a, b) ∈ graph f ∧ (b, c) ∈ graph g) <span class="kw">from</span> h1</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : (a, b) ∈ graph f := h2.left</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : (b, c) ∈ graph g := h2.right</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h3          <span class="co">--h3: f a = b</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h4          <span class="co">--h4: g b = c</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←h3] <span class="kw">at</span> h4   <span class="co">--h4: g (f a) = c</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> h a = c <span class="kw">from</span> h4</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Notice that the proof of <code>Theorem_5_1_5</code> begins by defining the function <code>h</code> for which <code>graph h = comp (graph g) (graph f)</code>. The definition says that for all <code>x</code> of type <code>A</code>, <code>h x = g (f x)</code>. This function <code>h</code> is called the <em>composition</em> of <code>g</code> and <code>f</code>, and it is denoted <code>g ∘ f</code>. (To type <code>∘</code> in VSCode, type <code>\circ</code>.) In other words, <code>g ∘ f</code> has type <code>A → C</code>, and for all <code>x</code> of type <code>A</code>, <code>(g ∘ f) x</code> is definitionally equal to <code>g (f x)</code>. In <em>HTPI</em>, functions are sets of ordered pairs, and the operation of composition of functions is literally the same as the operation <code>comp</code> that we used in Chapter 4. But in Lean, we distinguish among functions, relations, and sets of ordered pairs, so all we can say is that the operation of composition of functions corresponds to the operation <code>comp</code> from Chapter 4. The correspondence is that, as shown in the proof of <code>Theorem_5_1_5</code>, if <code>h = g ∘ f</code>, then <code>graph h = comp (graph g) (graph f)</code>.</p>
<section id="exercises" class="level3">
<h3 class="anchored" data-anchor-id="exercises">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb9"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> func_from_graph_ltr {A B : <span class="kw">Type</span>} (F : Set (A × B)) :</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    (∃ (f : A → B), graph f = F) → is_func_graph F := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb10"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_1_13a</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    {A B C : <span class="kw">Type</span>} (R : Set (A × B)) (S : Set (B × C))</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (b : B), b ∈ Ran R ∧ b ∈ Dom S)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    (h2 : is_func_graph (comp S R)) :</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    is_func_graph S := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb11"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_1_14a</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    {A B : <span class="kw">Type</span>} (f : A → B) (R : BinRel A) (S : BinRel B)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    (h : ∀ (x y : A), R x y ↔ S (f x) (f y)) :</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    reflexive S → reflexive R := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>4. Here is a putative theorem:</p>
<div class="nthm" data-arguments="Theorem?">
<p>Suppose <span class="math inline">\(f : A \to B\)</span>, <span class="math inline">\(R\)</span> is a binary relation on <span class="math inline">\(A\)</span>, and <span class="math inline">\(S\)</span> is the binary relation on <span class="math inline">\(B\)</span> defined as follows: <span class="math display">\[
\forall x \in B \forall y \in B(xSy \leftrightarrow \exists u \in A\exists v \in A(f(u) = x \wedge f(v) = y \wedge uRv)).
\]</span> If <span class="math inline">\(R\)</span> is symmetric then <span class="math inline">\(S\)</span> is symmetric.</p>
</div>
<p>Is the theorem correct? Try to prove it in Lean. If you can’t prove it, see if you can find a counterexample.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">--You might not be able to complete this proof</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_1_15b</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    {A B : <span class="kw">Type</span>} (f : A → B) (R : BinRel A) (S : BinRel B)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    (h : ∀ (x y : B), S x y ↔ ∃ (u v : A), f u = x ∧ f v = y ∧ R u v) :</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    symmetric R → symmetric S := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>5. Here is a putative theorem with an incorrect proof:</p>
<div class="nthm" data-arguments="Theorem?">
<p>Suppose <span class="math inline">\(f : A \to B\)</span>, <span class="math inline">\(R\)</span> is a binary relation on <span class="math inline">\(A\)</span>, and <span class="math inline">\(S\)</span> is the binary relation on <span class="math inline">\(B\)</span> defined as follows: <span class="math display">\[
\forall x \in B \forall y \in B(xSy \leftrightarrow \exists u \in A\exists v \in A(f(u) = x \wedge f(v) = y \wedge uRv)).
\]</span> If <span class="math inline">\(R\)</span> is transitive then <span class="math inline">\(S\)</span> is transitive.</p>
</div>
<div class="npf" data-arguments="Incorrect Proof">
<p>Suppose <span class="math inline">\(R\)</span> is transitive. Let <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, and <span class="math inline">\(z\)</span> be arbitrary elements of <span class="math inline">\(B\)</span>. Assume that <span class="math inline">\(xSy\)</span> and <span class="math inline">\(ySz\)</span>. By the definition of <span class="math inline">\(S\)</span>, this means that there are <span class="math inline">\(u\)</span>, <span class="math inline">\(v\)</span>, and <span class="math inline">\(w\)</span> in <span class="math inline">\(A\)</span> such that <span class="math inline">\(f(u) = x\)</span>, <span class="math inline">\(f(v) = y\)</span>, <span class="math inline">\(f(w) = z\)</span>, <span class="math inline">\(uRv\)</span>, and <span class="math inline">\(vRw\)</span>. Since <span class="math inline">\(R\)</span> is transitive, it follows that <span class="math inline">\(uRw\)</span>. Since <span class="math inline">\(f(u) = x\)</span>, <span class="math inline">\(f(w) = z\)</span>, and <span class="math inline">\(uRw\)</span>, <span class="math inline">\(xSz\)</span>. Therefore <span class="math inline">\(S\)</span> is transitive. <span class="excl">&nbsp;□</span></p>
</div>
<p>Find the mistake in the proof by attempting to write the proof in Lean. Is the theorem correct?</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">--You might not be able to complete this proof</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_1_15c</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    {A B : <span class="kw">Type</span>} (f : A → B) (R : BinRel A) (S : BinRel B)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    (h : ∀ (x y : B), S x y ↔ ∃ (u v : A), f u = x ∧ f v = y ∧ R u v) :</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    transitive R → transitive S := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb14"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_1_16b</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    {A B : <span class="kw">Type</span>} (R : BinRel B) (S : BinRel (A → B))</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    (h : ∀ (f g : A → B), S f g ↔ ∀ (x : A), R (f x) (g x)) :</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    symmetric R → symmetric S := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="7">
<div class="sourceCode" id="cb15"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_1_17a {A : <span class="kw">Type</span>} (f : A → A) (a : A)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    (h : ∀ (x : A), f x = a) : ∀ (g : A → A), f ∘ g = f := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="8">
<div class="sourceCode" id="cb16"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_1_17b {A : <span class="kw">Type</span>} (f : A → A) (a : A)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    (h : ∀ (g : A → A), f ∘ g = f) :</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    ∃ (y : A), ∀ (x : A), f x = y := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Chap4.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Relations</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->



</body></html>