<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>How To Prove It With Lean - 7&nbsp; Number Theory</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Chap6.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="HTPIwLstyles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Number Theory</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">How To Prove It With Lean</a> 
        <div class="sidebar-tools-main">
    <a href="./How-To-Prove-It-With-Lean.pdf" title="Download PDF" class="sidebar-tool px-1"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Sentential Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Quantificational Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./IntroLean.html" class="sidebar-item-text sidebar-link">Introduction to Lean</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap3.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Proofs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap4.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Relations</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap5.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Functions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap6.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Mathematical Induction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap7.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Number Theory</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">In This Chapter</h2>
   
  <ul class="collapse">
  <li><a href="#greatest-common-divisors" id="toc-greatest-common-divisors" class="nav-link active" data-scroll-target="#greatest-common-divisors">7.1. Greatest Common Divisors</a></li>
  <li><a href="#prime-factorization" id="toc-prime-factorization" class="nav-link" data-scroll-target="#prime-factorization">7.2. Prime Factorization</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<div class="hidden">
$$
\newcommand{\setmin}{\mathbin{\backslash}}
\newcommand{\symmdiff}{\bigtriangleup}
$$
</div>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Number Theory</span></h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<section id="greatest-common-divisors" class="level2">
<h2 class="anchored" data-anchor-id="greatest-common-divisors">7.1. Greatest Common Divisors</h2>
<p>Section 7.1 of <em>HTPI</em> introduces the Euclidean algorithm for computing the greatest common divisor (gcd) of two positive integers <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. The motivation for the algorithm is the fact that if <span class="math inline">\(r\)</span> is the remainder when <span class="math inline">\(a\)</span> is divided by <span class="math inline">\(b\)</span>, then any natural number that divides both <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> also divides <span class="math inline">\(r\)</span>, and any natural number that divides both <span class="math inline">\(b\)</span> and <span class="math inline">\(r\)</span> also divides <span class="math inline">\(a\)</span>.</p>
<p>Let’s prove these statements in Lean. Recall that in Lean, the remainder when <code>a</code> is divided by <code>b</code> is called <code>a</code> mod <code>b</code>, and it is denoted <code>a % b</code>. We’ll prove the first statement, and leave the second as an exercise for you. It will be convenient for our work with greatest common divisors in Lean to let <code>a</code> and <code>b</code> be natural numbers rather than positive integers (thus allowing either of them to be zero).</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> dvd_mod_of_dvd_a_b {a b d : Nat}</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    (h1 : d ∣ a) (h2 : d ∣ b) : d ∣ (a % b) := <span class="kw">by</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> q : Nat := a / b</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : b * q + a % b = a := Nat.div_add_mod a b</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (j : Nat) (h4 : a = d * j) <span class="kw">from</span> h1</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (k : Nat) (h5 : b = d * k) <span class="kw">from</span> h2</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>    <span class="co">--Goal : ∃ (c : Nat), a % b = d * c</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (j - k * q)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a % b = d * (j - k * q) <span class="kw">from</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> a % b</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>      _ = b * q + a % b - b * q := (Nat.add_sub_cancel_left _ _).symm</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>      _ = a - b * q := <span class="kw">by</span> <span class="kw">rw</span> [h3]</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>      _ = d * j - d * (k * q) := <span class="kw">by</span> <span class="kw">rw</span> [h4, h5, mul_assoc]</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>      _ = d * (j - k * q) := (Nat.mul_sub_left_distrib _ _ _).symm</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> dvd_a_of_dvd_b_mod {a b d : Nat}</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    (h1 : d ∣ b) (h2 : d ∣ (a % b)) : d ∣ a := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>These theorems tell us that the gcd of <code>a</code> and <code>b</code> is the same as the gcd of <code>b</code> and <code>a % b</code>, which suggests that the following recursive definition should compute the gcd of <code>a</code> and <code>b</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="sc">**</span><span class="er">gcd</span><span class="sc">::</span> (a b : Nat) : Nat :=</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> b <span class="kw">with</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; a</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    | n + 1 =&gt; gcd (n + 1) (a % (n + 1))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Unfortunately, Lean puts a red squiggle under <code>gcd</code>, and it displays in the Infoview a long error message that begins <code>fail to show termination</code>. What is Lean complaining about?</p>
<p>The problem is that recursive definitions are dangerous. To understand the danger, consider the following recursive definition:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> loop (n : Nat) : Nat := loop (n + 1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Suppose we try to use this definition to compute <code>loop 3</code>. The definition would lead us to perform the following calculation:</p>
<div class="ind">
<p><code>loop 3 = loop 4 = loop 5 = loop 6 = ...</code></p>
</div>
<p>Clearly this calculation will go on forever and will never produce an answer. So the definition of <code>loop</code> does not actually succeed in defining a function from <code>Nat</code> to <code>Nat</code>.</p>
<p>Lean insists that recursive definitions must avoid such non-terminating calculations. Why did it accept all of our previous recursive definitions? The reason is that in each case, the definition of the value of the function at a natural number <code>n</code> referred only to values of the function at numbers smaller than <code>n</code>. Since a decreasing list of natural numbers cannot go on forever, such definitions lead to calculations that are guaranteed to terminate.</p>
<p>What about our recusive definition of <code>gcd a b</code>? This function has two arguments, <code>a</code> and <code>b</code>, and when <code>b = n + 1</code>, the definition asks us to compute <code>gcd (n + 1) (a % (n + 1))</code>. The first argument here could actually be larger than the first argument in the value we are trying to compute, <code>gcd a b</code>. But the second argument will always be smaller, and that will suffice to guarantee that the calculation terminates. We can tell Lean to focus on the second argument by adding a <code>termination_by</code> clause to the end of our recursive definition:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gcd (a b : Nat) : Nat :=</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> b <span class="kw">with</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; a</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    | n + 1 =&gt; <span class="sc">**</span><span class="er">gcd (n + 1) (a % (n + 1))</span><span class="sc">::</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">termination_by</span> gcd a b =&gt; b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Unfortunately, Lean still isn’t satisfied, but the error message this time is more helpful. The message says that Lean failed to prove termination, and at the end of the message it says that the goal it failed to prove is <code>a % (n + 1) &lt; Nat.succ n</code>. Here <code>Nat.succ n</code> denotes the successor of <code>n</code>—that is, <code>n + 1</code>—so Lean was trying to prove that <code>a % (n + 1) &lt; n + 1</code>, which is precisely what is needed to show that the second argument of <code>gcd (n + 1) (a % (n + 1))</code> is smaller than the second argument of <code>gcd a b</code> when <code>b = n + 1</code>. We’ll need to provide a proof of this goal to convince Lean to accept our recursive definition. Fortunately, it’s not hard to prove:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> mod_succ_lt (a n : Nat) : a % (n + 1) &lt; n + 1 := <span class="kw">by</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h : n + 1 &gt; 0 := Nat.succ_pos n</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a % (n + 1) &lt; n + 1 <span class="kw">from</span> Nat.mod_lt a h</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Lean’s error message suggests several ways to fix the problem with our recursive definition. We’ll use the first suggestion: <code>Use `have` expressions to prove the remaining goals</code>. Here, finally, is the definition of <code>gcd</code> that Lean is willing to accept:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gcd (a b : Nat) : Nat :=</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> b <span class="kw">with</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; a</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    | n + 1 =&gt;</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> : a % (n + 1) &lt; n + 1 := mod_succ_lt a n</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>      gcd (n + 1) (a % (n + 1))</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">termination_by</span> gcd a b =&gt; b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Notice that in the <code>have</code> expression, we have not bothered to specify an identifier for the assertion being proven, since we never need to refer to it. Let’s try out our <code>gcd</code> function:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="sc">++</span><span class="do">#eval</span><span class="sc">::</span> gcd 672 161    <span class="co">--Answer: 7.  Note 672 = 7 * 96 and 161 = 7 * 23.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To establish the main properties of <code>gcd a b</code> we’ll need several lemmas. We prove some of them and leave others as exercises.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> gcd_base (a : Nat) : gcd a 0 = a := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> plus_one_of_ne {n : Nat} (h : n ≠ 0) :</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    ∃ (k : Nat), n = k + 1 := <span class="cn">sorry</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> gcd_nonzero (a : Nat) {b : Nat} (h : b ≠ 0) :</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    gcd a b = gcd b (a % b) := <span class="kw">by</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (n : Nat) (h2 : b = n + 1) <span class="kw">from</span> plus_one_of_ne h</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h2]   <span class="co">--Goal : gcd a (n + 1) = gcd (n + 1) (a % (n + 1))</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rfl</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> mod_nonzero_lt (a : Nat) {b : Nat} (h : b ≠ 0) : a % b &lt; b := <span class="cn">sorry</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> dvd_self (n : Nat) : n ∣ n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>One of the most important properties of <code>gcd a b</code> is that it divides both <code>a</code> and <code>b</code>. We prove it by strong induction on <code>b</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> gcd_dvd : ∀ (b a : Nat), (gcd a b) ∣ a ∧ (gcd a b) ∣ b := <span class="kw">by</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_strong_induc</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> b : Nat</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> ih : ∀ (b_1 : Nat), b_1 &lt; b →</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    ∀ (a : Nat), (gcd a b_1) ∣ a ∧ (gcd a b_1) ∣ b_1</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : Nat</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h1 : b = 0</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h1 : b = 0</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h1, gcd_base]   <span class="co">--Goal: a ∣ a ∧ a ∣ 0</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro (dvd_self a)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro 0</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h1 : b ≠ 0</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [gcd_nonzero a h1]</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>      <span class="co">--Goal : gcd b (a % b) ∣ a ∧ gcd b (a % b) ∣ b</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : a % b &lt; b := mod_nonzero_lt a h1</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : (gcd b (a % b)) ∣ b ∧ (gcd b (a % b)) ∣ (a % b) :=</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>      ih (a % b) h2 b</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro _ h3.left</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> (gcd b (a % b)) ∣ a <span class="kw">from</span> dvd_a_of_dvd_b_mod h3.left h3.right</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You may wonder why we didn’t start the proof like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> gcd_dvd : ∀ (a b : Nat), (gcd a b) ∣ a ∧ (gcd a b) ∣ b := <span class="kw">by</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : Nat</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_strong_induc</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> b : Nat</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> ih : ∀ (b_1 : Nat), b_1 &lt; b → (gcd a b_1) ∣ a ∧ (gcd a b_1) ∣ b_1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In fact, this approach wouldn’t have worked. It is an interesting exercise to try to complete this version of the proof and see why it fails.</p>
<p>Another interesting question is why we asserted both <code>(gcd a b) ∣ a</code> and <code>(gcd a b) ∣ b</code> in the same theorem. Wouldn’t it have been easier to give separate proofs of the statements <code>∀ (b a : Nat), (gcd a b) ∣ a</code> and <code>∀ (b a : Nat), (gcd a b) ∣ b</code>? Again, you might find it enlightening to see why that wouldn’t have worked. However, now that we have proven both divisibility statements, we can state them as separate theorems:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> gcd_dvd_left (a b : Nat) : (gcd a b) ∣ a := (gcd_dvd b a).left</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> gcd_dvd_right (a b : Nat) : (gcd a b) ∣ b := (gcd_dvd b a).right</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Next we turn to Theorem 7.1.4 in <em>HTPI</em>, which says that there are integers <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span> such that <span class="math inline">\(\text{gcd}(a, b) = s a + t b\)</span>. (We say that <span class="math inline">\(\text{gcd}(a, b)\)</span> can be written as a <em>linear combination</em> of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.) In <em>HTPI</em>, this is proven by using an extended version of the Euclidean algorithm to compute the coefficients <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span>. Here we will use a different recursive procedure to compute <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span>. If <span class="math inline">\(b = 0\)</span>, then <span class="math inline">\(\text{gcd}(a, b) = a = 1 \cdot a + 0 \cdot b\)</span>, so we can use the values <span class="math inline">\(s = 1\)</span> and <span class="math inline">\(t = 0\)</span>. Otherwise, let <span class="math inline">\(q\)</span> and <span class="math inline">\(r\)</span> be the quotient and remainder when <span class="math inline">\(a\)</span> is divided by <span class="math inline">\(b\)</span>. Then <span class="math inline">\(a = bq + r\)</span> and <span class="math inline">\(\text{gcd}(a, b) = \text{gcd}(b, r)\)</span>. Now suppose that we have already computed integers <span class="math inline">\(s'\)</span> and <span class="math inline">\(t'\)</span> such that <span class="math display">\[
\text{gcd}(b, r) = s' b + t' r.
\]</span> Then <span class="math display">\[\begin{align*}
\text{gcd}(a, b) &amp;= \text{gcd}(b, r) = s' b + t' r\\
&amp;= s' b + t' (a - bq) = t' a + (s' - t'q)b.
\end{align*}\]</span> Thus, to write <span class="math inline">\(\text{gcd}(a, b) = s a + t b\)</span> we can use the values <span class="math display">\[\begin{equation}\tag{$*$}
s = t', \qquad t = s' - t'q.
\end{equation}\]</span></p>
<p>We will use these equations as the basis for recursive definitions of Lean functions <code>gcd_c1</code> and <code>gcd_c2</code> such that the required coefficients can be obtained from the formulas <code>s = gcd_c1 a b</code> and <code>t = gcd_c2 a b</code>. Notice that <code>s</code> and <code>t</code> could be negative, so they must have type <code>Int</code>, not <code>Nat</code>. As a result, in definitions and theorems involving <code>gcd_c1</code> and <code>gcd_c2</code> we will sometimes have to deal with coercion of natural numbers to integers.</p>
<p>The functions <code>gcd_c1</code> and <code>gcd_c2</code> will be <em>mutually recursive</em>; in other words, each will be defined not only in terms of itself but also in terms of the other. Fortunately, Lean allows for such mutual recursion. Here are the definitions we will use.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">mutual</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> gcd_c1 (a b : Nat) : Int :=</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> b <span class="kw">with</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>      | 0 =&gt; 1</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>      | n + 1 =&gt; </span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">have</span> : a % (n + 1) &lt; n + 1 := mod_succ_lt a n</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        gcd_c2 (n + 1) (a % (n + 1))</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>          <span class="co">--Corresponds to s = t' in (*)</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> gcd_c2 (a b : Nat) : Int :=</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> b <span class="kw">with</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>      | 0 =&gt; 0</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>      | n + 1 =&gt;</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">have</span> : a % (n + 1) &lt; n + 1 := mod_succ_lt a n</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        gcd_c1 (n + 1) (a % (n + 1)) -</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>          (gcd_c2 (n + 1) (a % (n + 1))) * ↑(a / (n + 1))</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>          <span class="co">--Corresponds to t = s' - t'q in (*)</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">termination_by</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    gcd_c1 a b =&gt; b</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>    gcd_c2 a b =&gt; b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Notice that in the definition of <code>gcd_c2</code>, the quotient <code>a / (n + 1)</code> is computed using natural-number division, but it is then coerced to be an integer so that it can be multiplied by the integer <code>gcd_c2 (n + 1) (a % (n + 1))</code>.</p>
<p>Our main theorem about these functions is that they give the coefficients needed to write <code>gcd a b</code> as a linear combination of <code>a</code> and <code>b</code>. As usual, stating a few lemmas first helps with the proof. We leave the proofs of two of them as exercises for you (hint: imitate the proof of <code>gcd_nonzero</code> above).</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> gcd_c1_base (a : Nat) : gcd_c1 a 0 = 1 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> gcd_c1_nonzero (a : Nat) {b : Nat} (h : b ≠ 0) :</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    gcd_c1 a b = gcd_c2 b (a % b) := <span class="cn">sorry</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> gcd_c2_base (a : Nat) : gcd_c2 a 0 = 0 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> gcd_c2_nonzero (a : Nat) {b : Nat} (h : b ≠ 0) :</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    gcd_c2 a b = gcd_c1 b (a % b) - (gcd_c2 b (a % b)) * ↑(a / b) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With that preparation, we are ready to prove that <code>gcd_c1 a b</code> and <code>gcd_c2 a b</code> give coefficients for expressing <code>gcd a b</code> as a linear combination of <code>a</code> and <code>b</code>. Of course, the theorem is proven by strong induction. We’ll make a few comments after the proof that may help you follow the details.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> gcd_lin_comb : ∀ (b a : Nat),</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    (gcd_c1 a b) * a + (gcd_c2 a b) * b = gcd a b := <span class="kw">by</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_strong_induc</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> b : Nat</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> ih : ∀ (b_1 : Nat), b_1 &lt; b → ∀ (a : Nat),</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    (gcd_c1 a b_1) * ↑a + (gcd_c2 a b_1) * ↑b_1 = ↑(gcd a b_1)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : Nat</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h1 : b = 0</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h1 : b = 0</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h1, gcd_c1_base, gcd_c2_base, gcd_base]</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>      <span class="co">--Goal : 1 * ↑a + 0 * ↑0 = ↑a</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">norm_num</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h1 : b ≠ 0</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [gcd_c1_nonzero a h1, gcd_c2_nonzero a h1, gcd_nonzero a h1]</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r : Nat := a % b</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> q : Nat := a / b</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s : Int := gcd_c1 b r</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> t : Int := gcd_c2 b r</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> hr : a % b = r := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> hq : a / b = q := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> hs : gcd_c1 b r = s := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> ht : gcd_c2 b r = t := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : r &lt; b := mod_nonzero_lt a h1</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : (gcd_c1 b r) * ↑b + (gcd_c2 b r )* ↑r = ↑(gcd b r) :=</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>      ih r h2 b</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [hr, ←h3, hs, ht, hq]</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>      <span class="co">--Goal : t * ↑a + (s - t * ↑q) * ↑b = s * ↑b + t * ↑r</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : (↑a : Int) = ↑b * ↑q + ↑r := <span class="kw">by</span></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [←Nat.div_add_mod a b, Nat.cast_add, Nat.cast_mul]</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rfl</span></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h4]</span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>      <span class="co">--Goal : t * (↑b * ↑q + ↑r) + (s - t * ↑q) * ↑b = s * ↑b + t * ↑r</span></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">ring</span></span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In the statement of the theorem, we have left it up to Lean to insert the required coercions. You can see the coercions by looking at the tactic state at the beginning of the proof, where the equation to be proven is displayed as</p>
<div class="ind">
<p><code>gcd_c1 a b * ↑a + gcd_c2 a b * ↑b = ↑(gcd a b)</code></p>
</div>
<p>For clarity, we have written the coercions explicitly in the statement of the inductive hypothesis. In case 2, we have introduced the variables <code>r</code>, <code>q</code>, <code>s</code>, and <code>t</code> to simplify the notation. In the statement <code>h4</code>, Lean wouldn’t have known what type to coerce the variables to if we hadn’t specified the type of <code>↑a</code> on the left side of the equation; with that hint, Lean figured out that for the equation to make sense, the variables on the right side also had to be coerced to type <code>Int</code>. In the proof of <code>h4</code>, the rewrite rule <code>←Nat.div_add_mod a b</code> converts the left side of the goal to <code>↑(b * q + r)</code>. You can use the <code>#check</code> command to see why <code>Nat.cast_add</code> and <code>Nat.cast_mul</code> then convert the left side to first <code>↑(b * q) + ↑r</code> and then <code>↑b * ↑q + ↑r</code>.</p>
<p>We can try out the functions <code>gcd_c1</code> and <code>gcd_c2</code> as follows:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="sc">++</span><span class="do">#eval</span><span class="sc">::</span> gcd_c1 672 161  <span class="co">--Answer: 6</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="sc">++</span><span class="do">#eval</span><span class="sc">::</span> gcd_c2 672 161  <span class="co">--Answer: -25</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">--Note 6 * 672 - 25 * 161 = 4032 - 4025 = 7 = gcd 672 161</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, we turn to Theorem 7.1.6 in <em>HTPI</em>, which expresses one of the senses in which <code>gcd a b</code> is the <em>greatest</em> common divisor of <code>a</code> and <code>b</code>. Our proof follows the strategy of the proof in <em>HTPI</em>, with one additional step: we begin by using the theorem <code>Int.coe_nat_dvd</code> to change the goal from <code>d ∣ gcd a b</code> to <code>↑d ∣ ↑(gcd a b)</code>, so that the rest of the proof can work with integer algebra rather than natural-number algebra.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_1_6 {d a b : Nat} (h1 : d ∣ a) (h2 : d ∣ b) :</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    d ∣ gcd a b := <span class="kw">by</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←Int.coe_nat_dvd]    <span class="co">--Goal : ↑d ∣ ↑(gcd a b)</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s : Int := gcd_c1 a b</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> t : Int := gcd_c2 a b</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : s * ↑a + t * ↑b = ↑(gcd a b) := gcd_lin_comb b a</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←h3]                 <span class="co">--Goal : ↑d ∣ s * ↑a + t * ↑b</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (j : Nat) (h4 : a = d * j) <span class="kw">from</span> h1</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (k : Nat) (h5 : b = d * k) <span class="kw">from</span> h2</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h4, h5, Nat.cast_mul, Nat.cast_mul]</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">--Goal : ↑d ∣ s * (↑d * ↑j) + t * (↑d * ↑k)</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (s * ↑j + t * ↑k)</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">ring</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="prime-factorization" class="level2">
<h2 class="anchored" data-anchor-id="prime-factorization">7.2. Prime Factorization</h2>
<p>A natural number <span class="math inline">\(n\)</span> is said to be <em>prime</em> if it is at least 2 and it cannot be written as a product of two smaller natural numbers. Two natural numbers are <em>relatively prime</em> if their greatest common divisor is 1. Of course, we can write these definitions in Lean.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prime (n : Nat) : <span class="kw">Prop</span> :=</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  2 ≤ n ∧ ¬∃ (a b : Nat), a * b = n ∧ a &lt; n ∧ b &lt; n</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rel_prime (a b : Nat) : <span class="kw">Prop</span> := gcd a b = 1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The main goal of Section 7.2 of <em>HTPI</em> is to prove that every positive integer can be written in a unique way as a product of prime numbers. In preparation for that goal, <em>HTPI</em> proves two theorems, 7.2.2 and 7.2.3. Here are similar proofs of those theorems in Lean, with the proof of one lemma left as an exercise. In the proof of Theorem 7.2.2, we begin, as we did in the proof of Theorem 7.1.6, by converting the goal from natural numbers to integers so that we can use integer algebra.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_2_2 {a b c : Nat}</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    (h1 : c ∣ a * b) (h2 : rel_prime a c) : c ∣ b := <span class="kw">by</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←Int.coe_nat_dvd]  <span class="co">--Goal : ↑c ∣ ↑b</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1; <span class="kw">define</span> <span class="kw">at</span> h2; <span class="kw">define</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (j : Nat) (h3 : a * b = c * j) <span class="kw">from</span> h1</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s : Int := gcd_c1 a c</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> t : Int := gcd_c2 a c</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : s * ↑a + t * ↑c = ↑(gcd a c) := gcd_lin_comb c a</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h2, Nat.cast_one] <span class="kw">at</span> h4  <span class="co">--h4 : s * ↑a + t * ↑c = (1 : Int)</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (s * ↑j + t * ↑b)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ↑b = ↑c * (s * ↑j + t * ↑b) <span class="kw">from</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> ↑b</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>      _ = (1 : Int) * ↑b := (one_mul _).symm</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>      _ = (s * ↑a + t * ↑c) * ↑b := <span class="kw">by</span> <span class="kw">rw</span> [h4]</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>      _ = s * (↑a * ↑b) + t * ↑c * ↑b := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>      _ = s * (↑c * ↑j) + t * ↑c * ↑b := <span class="kw">by</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>          <span class="kw">rw</span> [←Nat.cast_mul a b, h3, Nat.cast_mul c j]</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>      _ = ↑c * (s * ↑j + t * ↑b) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> dvd_prime {a p : Nat}</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    (h1 : prime p) (h2 : a ∣ p) : a = 1 ∨ a = p := <span class="cn">sorry</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> rel_prime_of_prime_not_dvd {a p : Nat}</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>    (h1 : prime p) (h2 : ¬p ∣ a) : rel_prime a p := <span class="kw">by</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : gcd a p ∣ a := gcd_dvd_left a p</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : gcd a p ∣ p := gcd_dvd_right a p</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : gcd a p = 1 ∨ gcd a p = p := dvd_prime h1 h4</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : gcd a p ≠ p := <span class="kw">by</span></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">contradict</span> h2 <span class="kw">with</span> h6</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h6] <span class="kw">at</span> h3</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> p ∣ a <span class="kw">from</span> h3</span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">disj_syll</span> h5 h6</span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> rel_prime a p <span class="kw">from</span> h5</span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_2_3 {a b p : Nat}</span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>    (h1 : prime p) (h2 : p ∣ a * b) : p ∣ a ∨ p ∣ b := <span class="kw">by</span></span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">or_right</span> <span class="kw">with</span> h3</span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : rel_prime a p := rel_prime_of_prime_not_dvd h1 h3</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> p ∣ b <span class="kw">from</span> Theorem_7_2_2 h2 h4</span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Defining the prime factorization of a natural number <code>n</code> in Lean will take several steps. For <code>n ≥ 2</code>, we begin by searching for the smallest prime factor of <code>n</code>. A natural approach is to test whether <code>n</code> is divisible by 2, then 3, then 4, and so on, until we find a divisor of <code>n</code>. However, we have to be careful how we describe this calculation to Lean: since we are testing larger and larger potential divisors, Lean may fear that the calculation may not terminate. To avoid this problem, we will ask Lean to test whether or not <code>(n - k) ∣ n</code> for various values of <code>k</code>. By performing this test for smaller and smaller values of <code>k</code>, we will test larger and larger potential divisors of <code>n</code>. Since <code>k</code> is decreasing, the search is guaranteed to terminate. If <code>k</code> reaches 0, then we will test whether or not <code>n ∣ n</code>, and of course the answer will be yes.</p>
<p>We begin by defining a function <code>first_div_ge</code> such that for any <code>n</code> and <code>k</code>, <code>first_div_ge n k</code> is the smallest divisor of <code>n</code> that is greater than or equal to <code>n - k</code>.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> first_div_ge (n k : Nat) : Nat :=</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> k <span class="kw">with</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; n</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    | j + 1 =&gt; if n - (j + 1) ∣ n then n - (j+ 1) else first_div_ge n j</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This is the first time we have used an <code>if ... then ... else</code> expression in a Lean definition. To prove theorems about such expressions, we will need two theorems from Lean’s library, <code>if_pos</code> and <code>if_neg</code>. The <code>#check</code> command tells us what they say:</p>
<div class="ind">
<pre><code>@if_pos : ∀ {c : Prop} {h : Decidable c},
          c → ∀ {α : Sort u_1} {t e : α}, (if c then t else e) = t
@if_neg : ∀ {c : Prop} {h : Decidable c},
          ¬c → ∀ {α : Sort u_1} {t e : α}, (if c then t else e) = e</code></pre>
</div>
<p>Ignoring the implicit arguments, this tells us that if <code>h</code> is a proof of a proposition <code>c</code>, then <code>if_pos h</code> is a proof of <code>(if c then t else e) = t</code>, and if <code>h</code> is a proof of <code>¬c</code>, then <code>if_neg h</code> is a proof of <code>(if c then t else e) = e</code>. (Technically, the implicit arguments say that <code>c</code> must be a “decidable” proposition, but we won’t worry about that detail.) We often use these theorems with the <code>rewrite</code> tactic to rewrite an expression of the form <code>if c then t else e</code> as either <code>t</code> or <code>e</code>, depending on whether <code>c</code> is true or false.</p>
<p>The important properties of <code>first_div_ge</code> are that <code>first_div_ge n k</code> divides <code>n</code>, it is greater than or equal to <code>n - k</code>, and it is the smallest number with those two properties. All three can be proven by induction on <code>k</code>. We prove the first, and leave the other two as exercises.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fdge_base (n : Nat) : first_div_ge n 0 = n := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fdge_step (n j : Nat) :</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    first_div_ge n (j + 1) =</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>      if n - (j + 1) ∣ n then n - (j + 1) else first_div_ge n j := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fdge_dvd (n : Nat) : ∀ (k : Nat), first_div_ge n k ∣ n := <span class="kw">by</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [fdge_base]  <span class="co">--Goal : n ∣ n</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> n ∣ n <span class="kw">from</span> dvd_self n</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> k : Nat</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : first_div_ge n k ∣ n</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [fdge_step]  <span class="co">--Goal :</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- (if n - (k + 1) ∣ n then n - (k + 1) else first_div_ge n k) ∣ n</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_cases</span> h1 : n - (k + 1) ∣ n</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 1. h1 : n - (k + 1) ∣ n</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [if_pos h1]  <span class="co">--Goal : n - (k + 1) ∣ n</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> n - (k + 1) ∣ n <span class="kw">from</span> h1</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2. h1 : ¬n - (k + 1) ∣ n</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [if_neg h1]  <span class="co">--Goal : first_div_ge n k ∣ n</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> first_div_ge n k ∣ n <span class="kw">from</span> ih</span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fdge_ge (n : Nat) : ∀ (k : Nat), n - k ≤ first_div_ge n k := <span class="cn">sorry</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  You may find the theorem Nat.sub_le_sub_left useful</span></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fdge_least (d n : Nat) : ∀ (k : Nat),</span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>    d ∣ n → n - k ≤ d → first_div_ge n k ≤ d := <span class="cn">sorry</span></span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a><span class="co">--Hints:</span></span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a><span class="co">--1. n - (k + 1) is definitionally equal to n - k - 1</span></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a><span class="co">--2. You may find the theorems le_tsub_add and lt_of_le_of_ne' useful</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now we can define a Lean function that finds the smallest nontrivial divisor of <code>n</code>. We will call it the <em>first divisor</em> of <code>n</code>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> first_div (n : Nat) : Nat :=</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> n <span class="kw">with</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; 0</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    | 1 =&gt; 1</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    | j + 2 =&gt; first_div_ge (j + 2) j</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In the case <code>n = j + 2</code>, this function finds the smallest divisor of <code>n</code> that is greater than or equal to <code>(j + 2) - j = 2</code>. The most important properties of <code>first_div</code> follow from the properties of <code>first_div_ge</code> that we proved earlier:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fd_zero : first_div 0 = 0 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fd_one : first_div 1 = 1 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fd_plus_two (j : Nat) :</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    first_div (j + 2) = first_div_ge (j + 2) j := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> fd_dvd (n : Nat) : first_div n ∣ n := <span class="kw">by</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h1 : n = 0</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h1 : n = 0</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h1, fd_zero]</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> 0 ∣ 0 <span class="kw">from</span> dvd_self 0</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h1 : n ≠ 0</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_cases</span> h2 : n = 1</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2.1. h2 : n = 1</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [h2, fd_one]</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> 1 ∣ 1 <span class="kw">from</span> dvd_self 1</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2.2. h2 : n ≠ 1</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">obtain</span> (j : Nat) (h3 : n = j + 2) <span class="kw">from</span> plus_two_of_ne h1 h2</span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [h3, fd_plus_two j]</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> first_div_ge (j + 2) j ∣ (j + 2) <span class="kw">from</span> fdge_dvd (j + 2) j</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> fd_nontriv (n : Nat) : first_div (n + 2) ≥ 2 := <span class="cn">sorry</span></span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> fd_least {n d : Nat} (h1 : d ∣ (n + 2)) (h2 : d ≥ 2) :</span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a>    first_div (n + 2) ≤ d := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Since <code>first_div n</code> divides <code>n</code>, there is some number <code>c</code> such that <code>c * (first_div n) = n</code>. It will be useful to give this number a name. We will call it the <em>first codivisor</em> of <code>n</code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> first_codiv (n : Nat) : Nat := n / (first_div n)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fc_mul_fd (n : Nat) : (first_codiv n) * (first_div n) = n :=</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    Nat.div_mul_cancel (fd_dvd n)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fd_mul_fc (n : Nat) : (first_div n) * (first_codiv n) = n := <span class="cn">sorry</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fc_dvd (n : Nat) : first_codiv n ∣ n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With this preparation, we can prove one more crucial property of <code>first_div</code>, namely, that when it is applied to a number that is at least 2, the result is prime:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> fd_prime (n : Nat) : prime (first_div (n + 2)) := <span class="kw">by</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro (fd_nontriv n)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h1</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : Nat) (h2 : ∃ (b : Nat), a * b = first_div (n + 2) ∧</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    a &lt; first_div (n + 2) ∧ b &lt; first_div (n + 2)) <span class="kw">from</span> h1</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (b : Nat) (h3 : a * b = first_div (n + 2) ∧</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    a &lt; first_div (n + 2) ∧ b &lt; first_div (n + 2)) <span class="kw">from</span> h2</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : a * b = first_div (n + 2) := h3.left</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : a ≠ 0 := <span class="kw">by</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_contra</span> h5</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h5] <span class="kw">at</span> h4</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h6 : first_div (n + 2) ≥ 2 := fd_nontriv n</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">linarith</span>   <span class="co">--h4 contradicts h6</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : a ≠ 1 := <span class="kw">by</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_contra</span> h6</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h6] <span class="kw">at</span> h4</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">linarith</span>   <span class="co">--h4 contradicts h3.right.right</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h7 : a ≥ 2 := ge_two_of_ne h5 h6</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h8 : a ∣ (n + 2) := <span class="kw">by</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro (b * (first_codiv (n + 2)))</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←mul_assoc, h4]</span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> n + 2 = first_div (n + 2) * first_codiv (n + 2) <span class="kw">from</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>      (fd_mul_fc (n + 2)).symm</span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h9 : first_div (n + 2) ≤ a := fd_least h8 h7</span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">linarith</span>   <span class="co">--h9 contradicts h3.right.left</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To define the prime factorization of a positive integer, we will need a new type. If <code>U</code> is any type, then <code>List U</code> is the type of lists of objects of type <code>U</code>. Such a list is written in square brackets, with the entries separated by commas. For example, <code>[3, 7, 1]</code> has type <code>List Nat</code>. The notation <code>[]</code> denotes the empty list, and if <code>a</code> has type <code>U</code> and <code>l</code> has type <code>List U</code>, then <code>a :: l</code> denotes the list consisting of <code>a</code> followed by the entries of <code>l</code>. The empty list is sometimes called the <code>nil</code> list, and the operation of constructing a list <code>a :: l</code> from <code>a</code> and <code>l</code> is called <code>cons</code> (short for <em>construct</em>). Every list can be constructed by applying the <code>cons</code> operation repeatedly, starting with the <code>nil</code> list. For example,</p>
<div class="ind">
<pre><code>[3, 7, 1] = 3 :: [7, 1] = 3 :: (7 :: [1]) = 3 :: (7 :: (1 :: []))</code></pre>
</div>
<p>We can now define the prime factorization of a natural number <code>n</code>. We use the lemma <code>fc_dec</code> to help Lean see that the calculation terminates.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fc_dec (n : Nat) : first_codiv (n + 2) &lt; n + 2 := <span class="cn">sorry</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prime_fac (n : Nat) : List Nat :=</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> n <span class="kw">with</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; []</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    | 1 =&gt; []</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    | j + 2 =&gt; </span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> : first_codiv (j + 2) &lt; j + 2 := fc_dec j</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>      first_div (j + 2) :: (prime_fac (first_codiv (j + 2)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For example, here is how this definition computes the prime factorization of 276:</p>
<div class="ind">
<pre><code>prime_fac 276 = (first_div 276) :: (prime_fac (first_codiv 276))
              = 2 :: (prime_fac 138)
              = 2 :: ((first_div 138) :: (prime_fac (first_codiv 138)))
              = 2 :: (2 :: (prime_fac 69))
              = 2 :: (2 :: (3 :: (prime_fac 23)))
              = 2 :: (2 :: (3 :: (23 :: (prime_fac 1))))
              = 2 :: (2 :: (3 :: (23 :: []))) = [2, 2, 3, 23]</code></pre>
</div>
<p>Notice that <code>2</code>, <code>3</code>, and <code>23</code> are all prime, and <code>2 * 2 * 3 * 23 = 276</code>.</p>
<p>If <code>l</code> has type <code>List U</code> and <code>a</code> has type <code>U</code>, then <code>a ∈ l</code> means that <code>a</code> is one of the entries in the list <code>l</code>. Lean knows several theorems about this notation:</p>
<div class="ind">
<pre><code>@List.not_mem_nil : ∀ {α : Type u_1} (a : α),
                        ¬a ∈ []
@List.mem_cons : ∀ {α : Type u_1} {a b : α} {l : List α},
                        a ∈ b :: l ↔ a = b ∨ a ∈ l
@List.mem_cons_self : ∀ {α : Type u_1} (a : α) (l : List α),
                        a ∈ a :: l
@List.mem_cons_of_mem : ∀ {α : Type u_1} (y : α) {a : α} {l : List α},
                        a ∈ l → a ∈ y :: l</code></pre>
</div>
<p>The first two theorems give the conditions under which something is a member of the <code>nil</code> list or a list constructed by <code>cons</code>, and the last two are easy consequences of the second.</p>
<p>The most important properties of <code>prime_fac n</code>, for <code>n ≥ 1</code>, are that it is a nondecreasing list of prime numbers whose product is <code>n</code>. Let’s start by proving that all members of the list <code>prime_fac n</code> are prime.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> prime_fac_zero : prime_fac 0 = [] := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> prime_fac_one : prime_fac 1 = [] := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> prime_fac_step (j : Nat) : prime_fac (j + 2) =</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    (first_div (j + 2)) :: prime_fac (first_codiv (j + 2)) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> all_prime (l : List Nat) : <span class="kw">Prop</span> := ∀ (p : Nat), p ∈ l → prime p</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> all_prime_nil : all_prime [] := <span class="kw">by</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>     <span class="co">--Goal : ∀ (p : Nat), p ∈ [] → prime p</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> p : Nat</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">contrapos</span>  <span class="co">--Goal : ¬prime p → ¬p ∈ []</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : ¬prime p</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ¬p ∈ [] <span class="kw">from</span> List.not_mem_nil p</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> all_prime_cons (n : Nat) (l : List Nat) :</span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>    all_prime (n :: l) ↔ prime n ∧ all_prime l := <span class="kw">by</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : all_prime (n :: l)  <span class="co">--Goal : prime n ∧ all_prime l</span></span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1  <span class="co">--h1 : ∀ (p : Nat), p ∈ n :: l → prime p</span></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro (h1 n (List.mem_cons_self n l))</span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>        <span class="co">--Goal : ∀ (p : Nat), p ∈ l → prime p</span></span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> p : Nat</span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : p ∈ l</span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> prime p <span class="kw">from</span> h1 p (List.mem_cons_of_mem n h2)</span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : prime n ∧ all_prime l  <span class="co">--Goal : all_prime (n :: l)</span></span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> : all_prime l <span class="kw">at</span> h1</span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> p : Nat</span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : p ∈ n :: l</span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [List.mem_cons] <span class="kw">at</span> h2   <span class="co">--h2 : p = n ∨ p ∈ l</span></span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_cases</span> <span class="kw">on</span> h2</span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 1. h2 : p = n</span></span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [h2]</span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> prime n <span class="kw">from</span> h1.left</span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2. h2 : p ∈ l</span></span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> prime p <span class="kw">from</span> h1.right p h2</span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb30-45"><a href="#cb30-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb30-46"><a href="#cb30-46" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb30-47"><a href="#cb30-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-48"><a href="#cb30-48" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> prime_fac_all_prime : ∀ (n : Nat), all_prime (prime_fac n) := <span class="kw">by</span></span>
<span id="cb30-49"><a href="#cb30-49" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_strong_induc</span></span>
<span id="cb30-50"><a href="#cb30-50" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> n : Nat</span>
<span id="cb30-51"><a href="#cb30-51" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> ih : ∀ (n_1 : Nat), n_1 &lt; n → all_prime (prime_fac n_1)</span>
<span id="cb30-52"><a href="#cb30-52" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h1 : n = 0</span>
<span id="cb30-53"><a href="#cb30-53" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h1 : n = 0</span></span>
<span id="cb30-54"><a href="#cb30-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h1, prime_fac_zero]</span>
<span id="cb30-55"><a href="#cb30-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> all_prime [] <span class="kw">from</span> all_prime_nil</span>
<span id="cb30-56"><a href="#cb30-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb30-57"><a href="#cb30-57" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h1 : n ≠ 0</span></span>
<span id="cb30-58"><a href="#cb30-58" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_cases</span> h2 : n = 1</span>
<span id="cb30-59"><a href="#cb30-59" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2.1. h2 : n = 1</span></span>
<span id="cb30-60"><a href="#cb30-60" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [h2, prime_fac_one]</span>
<span id="cb30-61"><a href="#cb30-61" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> all_prime [] <span class="kw">from</span> all_prime_nil</span>
<span id="cb30-62"><a href="#cb30-62" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb30-63"><a href="#cb30-63" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2.2. h2 : n ≠ 1</span></span>
<span id="cb30-64"><a href="#cb30-64" aria-hidden="true" tabindex="-1"></a>      <span class="kw">obtain</span> (j : Nat) (h3 : n = j + 2) <span class="kw">from</span> plus_two_of_ne h1 h2</span>
<span id="cb30-65"><a href="#cb30-65" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [h3, prime_fac_step, all_prime_cons]</span>
<span id="cb30-66"><a href="#cb30-66" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> And.intro (fd_prime j)</span>
<span id="cb30-67"><a href="#cb30-67" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [h3] <span class="kw">at</span> ih</span>
<span id="cb30-68"><a href="#cb30-68" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> all_prime (prime_fac (first_codiv (j + 2))) <span class="kw">from</span></span>
<span id="cb30-69"><a href="#cb30-69" aria-hidden="true" tabindex="-1"></a>        ih (first_codiv (j + 2)) (fc_dec j)</span>
<span id="cb30-70"><a href="#cb30-70" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb30-71"><a href="#cb30-71" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb30-72"><a href="#cb30-72" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Next we define <code>prod l</code> to be the product of the entries in the list <code>l</code>, and we show that for <code>n ≥ 1</code>, the product of the numbers in the prime factorization of <code>n</code> is <code>n</code>.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prod (l : List Nat) : Nat :=</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    | [] =&gt; 1</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    | n :: L =&gt; n * (prod L)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> prod_nil : prod [] = 1 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> prod_cons : prod (n :: l) = n * (prod l) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fc_ge_one (n : Nat) : first_codiv (n + 2) ≥ 1 := <span class="cn">sorry</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> prime_fac_prod : ∀ n ≥ 1, prod (prime_fac n) = n := <span class="kw">by</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_strong_induc</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> n : Nat</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> ih : ∀ (n_1 : Nat), n_1 &lt; n →</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>    n_1 ≥ 1 → prod (prime_fac n_1) = n_1</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : n ≥ 1</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h2 : n = 1</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h2 : n = 1</span></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h2, prime_fac_one, prod_nil]</span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h2 : n ≠ 1</span></span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : n ≥ 2 := lt_of_le_of_ne' h1 h2</span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (j : Nat) (h4 : n = j + 2) <span class="kw">from</span> plus_two_of_ge h3</span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h4, prime_fac_step, prod_cons]</span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h4] <span class="kw">at</span> ih</span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h5 : prod (prime_fac (first_codiv (j + 2))) =</span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a>      first_codiv (j + 2) :=</span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true" tabindex="-1"></a>      ih (first_codiv (j + 2)) (fc_dec j) (fc_ge_one j)</span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h5]</span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> first_div (j + 2) * first_codiv (j + 2) = j + 2 <span class="kw">from</span></span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true" tabindex="-1"></a>      fd_mul_fc (j + 2)</span>
<span id="cb31-34"><a href="#cb31-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The third important property of <code>prime_fac n</code> is that it is a nondecreasing list. Once again, we first define this property and then prove that <code>prime_fac n</code> has the property, leaving the proof of one lemma as an exercise.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> le_list (n : Nat) (l : List Nat) : <span class="kw">Prop</span> :=</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  ∀ (m : Nat), m ∈ l → n ≤ m</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nondec (l : List Nat) : <span class="kw">Prop</span> :=</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    | [] =&gt; True</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    | n :: L =&gt; le_list n L ∧ nondec L</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> nondec_nil : nondec [] := <span class="kw">by</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>  <span class="co">--Goal : True</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">trivial</span> <span class="co">--trivial proves some obviously true statements, such as True</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> nondec_cons (n : Nat) (l : List Nat) :</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>    nondec (n :: l) ↔ le_list n l ∧ nondec l := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fd_le_prime_fac (n : Nat) : ∀ (k : Nat),</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>    k ∣ (n + 2) → le_list (first_div (n + 2)) (prime_fac k) := <span class="cn">sorry</span></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  Use strong induction</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> prime_fac_nondec : ∀ (n : Nat), nondec (prime_fac n) := <span class="kw">by</span></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_strong_induc</span></span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> n : Nat</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> ih : ∀ (n_1 : Nat), n_1 &lt; n → nondec (prime_fac n_1)</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h1 : n = 0</span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h1 : n = 0</span></span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h1, prime_fac_zero]</span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> nondec [] <span class="kw">from</span> nondec_nil</span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h1 : n ≠ 0</span></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_cases</span> h2 : n = 1</span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2.1. h2 : n = 1</span></span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [h2, prime_fac_one]</span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> nondec [] <span class="kw">from</span> nondec_nil</span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2.2. h2 : n ≠ 1</span></span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a>      <span class="kw">obtain</span> (j : Nat) (h3 : n = j + 2) <span class="kw">from</span> plus_two_of_ne h1 h2</span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [h3, prime_fac_step, nondec_cons]</span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> And.intro</span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a>      · <span class="co">-- Proof that first_div n ≤ rest of list</span></span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a>        <span class="kw">have</span> h4 : first_codiv (j + 2) ∣ j + 2 := fc_dvd (j + 2)</span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a>        <span class="kw">show</span> le_list (first_div (j + 2))</span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a>          (prime_fac (first_codiv (j + 2))) <span class="kw">from</span></span>
<span id="cb32-44"><a href="#cb32-44" aria-hidden="true" tabindex="-1"></a>          fd_le_prime_fac j (first_codiv (j + 2)) h4</span>
<span id="cb32-45"><a href="#cb32-45" aria-hidden="true" tabindex="-1"></a>        <span class="kw">done</span></span>
<span id="cb32-46"><a href="#cb32-46" aria-hidden="true" tabindex="-1"></a>      · <span class="co">-- Proof that rest of list is nondecreasing</span></span>
<span id="cb32-47"><a href="#cb32-47" aria-hidden="true" tabindex="-1"></a>        <span class="kw">have</span> h4 : first_codiv (j + 2) &lt; j + 2 := fc_dec j</span>
<span id="cb32-48"><a href="#cb32-48" aria-hidden="true" tabindex="-1"></a>        <span class="kw">rewrite</span> [h3] <span class="kw">at</span> ih</span>
<span id="cb32-49"><a href="#cb32-49" aria-hidden="true" tabindex="-1"></a>        <span class="kw">show</span> nondec (prime_fac (first_codiv (j + 2))) <span class="kw">from</span></span>
<span id="cb32-50"><a href="#cb32-50" aria-hidden="true" tabindex="-1"></a>          ih (first_codiv (j + 2)) h4</span>
<span id="cb32-51"><a href="#cb32-51" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb32-52"><a href="#cb32-52" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb32-53"><a href="#cb32-53" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, we turn to the proof of the uniqueness of prime factorizations. One key ingredient in this proof is Theorem 7.2.4 of <em>HTPI</em>, which says that if a prime number divides a product of a list of numbers, then it divides one of the numbers in the list. The proof is by induction on the length of the list, so we will need to know how to work with lengths of lists in Lean. If <code>l</code> is a list, then the length of <code>l</code> is <code>List.length l</code>, which can also be written more briefly as <code>l.length</code>. We’ll need a few more theorems about lists:</p>
<div class="ind">
<pre><code>@List.length_eq_zero : ∀ {α : Type u_1} {l : List α},
                      List.length l = 0 ↔ l = []
@List.length_cons : ∀ {α : Type u_1} (a : α) (as : List α),
                      List.length (a :: as) = Nat.succ (List.length as)
@List.exists_cons_of_ne_nil : ∀ {α : Type u_1} {l : List α},
                      l ≠ [] → ∃ (b : α), ∃ (L : List α), l = b :: L</code></pre>
</div>
<p>And we’ll leave a few lemmas as exercises for you:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> exists_cons_of_length_eq_succ</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    {l : List Nat} {n : Nat} (h : l.length = n + 1) :</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    ∃ (a : Nat) (L : List Nat), l = a :: L ∧ L.length = n := <span class="cn">sorry</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> eq_one_of_dvd_one {n : Nat} (h : n ∣ 1) : n = 1 := <span class="cn">sorry</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> prime_not_one {p : Nat} (h : prime p) : p ≠ 1 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We now have everything we need to prove Theorem 7.2.4.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_2_4_by_length {p : Nat} (h1 : prime p) :</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    ∀ (k : Nat) (l : List Nat), l.length = k →</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    p ∣ prod l → ∃ (a : Nat), a ∈ l ∧ p ∣ a := <span class="kw">by</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> l : List Nat</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : l.length = 0</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [List.length_eq_zero] <span class="kw">at</span> h2</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h2, prod_nil]</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h3 : p ∣ 1</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ∃ (a : Nat), a ∈ [] ∧ p ∣ a <span class="kw">from</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>      absurd (eq_one_of_dvd_one h3) (prime_not_one h1)</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> k : Nat</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : ∀ (l : List Nat), l.length = k →</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>      p ∣ prod l → ∃ (a : Nat), a ∈ l ∧ p ∣ a</span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> l : List Nat</span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : l.length = k + 1</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (a : Nat) (h3 : ∃ (L : List Nat),</span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>      l = a :: L ∧ L.length = k) <span class="kw">from</span> exists_cons_of_length_eq_succ h2</span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (L : List Nat) (h4 : l = a :: L ∧ L.length = k) <span class="kw">from</span> h3</span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h4.left, prod_cons]</span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h5 : p ∣ (a * prod L)</span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h6 : p ∣ a ∨ p ∣ prod L := Theorem_7_2_3 h1 h5</span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_cases</span> <span class="kw">on</span> h6</span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 1. h6 : p ∣ a</span></span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro a</span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> a ∈ a :: L ∧ p ∣ a <span class="kw">from</span></span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a>        And.intro (List.mem_cons_self a L) h6</span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb35-32"><a href="#cb35-32" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2. h6 : p ∣ prod L</span></span>
<span id="cb35-33"><a href="#cb35-33" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h7 : ∃ (a : Nat), a ∈ L ∧ p ∣ a := ih L h4.right h6</span>
<span id="cb35-34"><a href="#cb35-34" aria-hidden="true" tabindex="-1"></a>      <span class="kw">obtain</span> (b : Nat) (h8 : b ∈ L ∧ p ∣ b) <span class="kw">from</span> h7</span>
<span id="cb35-35"><a href="#cb35-35" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro b</span>
<span id="cb35-36"><a href="#cb35-36" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> b ∈ a :: L ∧ p ∣ b <span class="kw">from</span></span>
<span id="cb35-37"><a href="#cb35-37" aria-hidden="true" tabindex="-1"></a>        And.intro (List.mem_cons_of_mem a h8.left) h8.right</span>
<span id="cb35-38"><a href="#cb35-38" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb35-39"><a href="#cb35-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb35-40"><a href="#cb35-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb35-41"><a href="#cb35-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-42"><a href="#cb35-42" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_2_4 {p : Nat} {l : List Nat}</span>
<span id="cb35-43"><a href="#cb35-43" aria-hidden="true" tabindex="-1"></a>    (h1 : prime p) (h2 : p ∣ prod l) : ∃ (a : Nat), a ∈ l ∧ p ∣ a :=</span>
<span id="cb35-44"><a href="#cb35-44" aria-hidden="true" tabindex="-1"></a>  Theorem_7_2_4_by_length h1 l.length l (Eq.refl l.length) h2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In Theorem 7.2.4, if all terms in the list <code>l</code> are prime, then we can conclude not merely that <code>p</code> divides some term, but that <code>p</code> is one of the terms of <code>l</code>.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> prime_in_list {p : Nat} {l : List Nat}</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    (h1 : prime p) (h2 : all_prime l) (h3 : p ∣ prod l) : p ∈ l := <span class="kw">by</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : Nat) (h4 : a ∈ l ∧ p ∣ a) <span class="kw">from</span> Theorem_7_2_4 h1 h3</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : prime a := h2 a h4.left</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : p = 1 ∨ p = a := dvd_prime h5 h4.right</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">disj_syll</span> h6 (prime_not_one h1)</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h6]</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a ∈ l <span class="kw">from</span> h4.left</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Next we’ll need some facts about nondecreasing lists of prime numbers.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nondec_prime_list (l : List Nat) : <span class="kw">Prop</span> := all_prime l ∧ nondec l</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> nondec_prime_list_tail {p : Nat} {l : List Nat}</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    (h : nondec_prime_list (p :: l)) : nondec_prime_list l := <span class="cn">sorry</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> cons_prod_not_one {p : Nat} {l : List Nat}</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    (h : nondec_prime_list (p :: l)) : prod (p :: l) ≠ 1 := <span class="cn">sorry</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> list_nil_iff_prod_one {l : List Nat} (h : nondec_prime_list l) :</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>    l = [] ↔ prod l = 1 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In <em>HTPI</em>, a key step in the proof of the uniqueness of prime factorizations is to show that if two nondecreasing lists of prime numbers have the same product, then the last entry of one list is less than or equal to the last entry of the other. In Lean, because of the way the <code>cons</code> operation works, it is easier to work with the first entries of the lists.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> first_le_first {p q : Nat} {l m : List Nat}</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    (h1 : nondec_prime_list (p :: l)) (h2 : nondec_prime_list (q :: m))</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    (h3 : prod (p :: l) = prod (q :: m)) : p ≤ q := <span class="kw">by</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1; <span class="kw">define</span> <span class="kw">at</span> h2</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : q ∣ prod (p :: l) := <span class="kw">by</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro (prod m)</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←prod_cons]</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> prod (p :: l) = prod (q :: m) <span class="kw">from</span> h3</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : all_prime (q :: m) := h2.left</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [all_prime_cons] <span class="kw">at</span> h5</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : q ∈ p :: l := prime_in_list h5.left h1.left h4</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h7 : nondec (p :: l) := h1.right</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [nondec_cons] <span class="kw">at</span> h7</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [List.mem_cons] <span class="kw">at</span> h6</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> <span class="kw">on</span> h6</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h6 : q = p</span></span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> p ≤ q <span class="kw">from</span> Nat.le_of_eq h6.symm</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2.  h6 : q ∈ l</span></span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h8 : le_list p l := h7.left</span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h8</span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> p ≤ q <span class="kw">from</span> h8 q h6</span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The uniqueness of prime factorizations follows from Theorem 7.2.5 of <em>HTPI</em>, which says that if two nondecreasing lists of prime numbers have the same product, then the two lists must be the same. The proof in <em>HTPI</em> is by induction on the length of the first list, and we could use that method to prove the theorem in Lean. But look back at our proof of <code>Theorem_7_2_4</code>, which also used induction on the length of a list. In the base case, we ended up proving that the <code>nil</code> list has the property stated in the theorem, and in the induction step we proved that if a list <code>l</code> has the property, then so does any list of the form <code>a :: l</code>. We could think of this as a kind of “induction on lists.” As we observed earlier, every list can be constructed by starting with the <code>nil</code> list and applying <code>cons</code> finitely many times. If follows that if the <code>nil</code> list has some property, and applying the <code>cons</code> operation to a list with the property produces another list with the property, then all lists have the property. (In fact, a similar principle was at work in our recursive definitions of <code>prod l</code> and <code>nondec l</code>.)</p>
<p>Lean has a theorem called <code>List.rec</code> that can be used to justify induction on lists. We’ll use it to prove Theorem 7.2.5.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> prime_pos {p : Nat} (h : prime p) : p &gt; 0 := <span class="cn">sorry</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_2_5 :</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    ∀ (l1 l2 : List Nat), nondec_prime_list l1 → nondec_prime_list l2 →</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    prod l1 = prod l2 → l1 = l2 := <span class="kw">by</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> List.rec</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case.  Goal : ∀ (l2 : List Nat), nondec_prime_list [] →</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- nondec_prime_list l2 → prod [] = prod l2 → [] = l2</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> l2 : List Nat</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : nondec_prime_list []</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : nondec_prime_list l2</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h3 : prod [] = prod l2</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [prod_nil, eq_comm, ←list_nil_iff_prod_one h2] <span class="kw">at</span> h3</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> [] = l2 <span class="kw">from</span> h3.symm</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> p : Nat</span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> L1 : List Nat</span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : ∀ (L2 : List Nat), nondec_prime_list L1 →</span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>      nondec_prime_list L2 → prod L1 = prod L2 → L1 = L2</span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Goal : ∀ (l2 : List Nat), nondec_prime_list (p :: L1) →</span></span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- nondec_prime_list l2 → prod (p :: L1) = prod l2 → p :: L1 = l2</span></span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> l2 : List Nat</span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : nondec_prime_list (p :: L1)</span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : nondec_prime_list l2</span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h3 : prod (p :: L1) = prod l2</span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : ¬prod (p :: L1) = 1 := cons_prod_not_one h1</span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h3, ←list_nil_iff_prod_one h2] <span class="kw">at</span> h4</span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (q : Nat) (h5 : ∃ (L : List Nat), l2 = q :: L) <span class="kw">from</span></span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a>      List.exists_cons_of_ne_nil h4</span>
<span id="cb39-31"><a href="#cb39-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (L2 : List Nat) (h6 : l2 = q :: L2) <span class="kw">from</span> h5</span>
<span id="cb39-32"><a href="#cb39-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h6] <span class="kw">at</span> h2    <span class="co">--h2 : nondec_prime_list (q :: L2)</span></span>
<span id="cb39-33"><a href="#cb39-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h6] <span class="kw">at</span> h3    <span class="co">--h3 : prod (p :: L1) = prod (q :: L2)</span></span>
<span id="cb39-34"><a href="#cb39-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h7 : p ≤ q := first_le_first h1 h2 h3</span>
<span id="cb39-35"><a href="#cb39-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h8 : q ≤ p := first_le_first h2 h1 h3.symm</span>
<span id="cb39-36"><a href="#cb39-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h9 : p = q := Nat.le_antisymm h7 h8</span>
<span id="cb39-37"><a href="#cb39-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h9, prod_cons, prod_cons] <span class="kw">at</span> h3</span>
<span id="cb39-38"><a href="#cb39-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h10 : nondec_prime_list L1 := nondec_prime_list_tail h1</span>
<span id="cb39-39"><a href="#cb39-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h11 : nondec_prime_list L2 := nondec_prime_list_tail h2</span>
<span id="cb39-40"><a href="#cb39-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h2</span>
<span id="cb39-41"><a href="#cb39-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h12 : all_prime (q :: L2) := h2.left</span>
<span id="cb39-42"><a href="#cb39-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [all_prime_cons] <span class="kw">at</span> h12</span>
<span id="cb39-43"><a href="#cb39-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h13 : q &gt; 0 := prime_pos h12.left</span>
<span id="cb39-44"><a href="#cb39-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h14 : prod L1 = prod L2 := Nat.eq_of_mul_eq_mul_left h13 h3</span>
<span id="cb39-45"><a href="#cb39-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h15 : L1 = L2 := ih L2 h10 h11 h14</span>
<span id="cb39-46"><a href="#cb39-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h6, h9, h15]</span>
<span id="cb39-47"><a href="#cb39-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb39-48"><a href="#cb39-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb39-49"><a href="#cb39-49" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Putting it all together, we can finally prove the Fundamental Theorem of Arithmetic, which is stated as Theorem 7.2.6 in <em>HTPI</em>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_2_6_Fund_Thm_Arith (n : Nat) (h : n ≥ 1) :</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    ∃! (l : List Nat), nondec_prime_list l ∧ prod l = n := <span class="kw">by</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">exists_unique</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Existence</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro (prime_fac n)</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h1 : nondec_prime_list (prime_fac n) :=</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>      And.intro (prime_fac_all_prime n) (prime_fac_nondec n)</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> nondec_prime_list (prime_fac n) ∧ prod (prime_fac n) = n <span class="kw">from</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>      And.intro h1 (prime_fac_prod n h)</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Uniqueness</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> l1 : List Nat; <span class="kw">fix</span> l2 : List Nat</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : nondec_prime_list l1 ∧ prod l1 = n</span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : nondec_prime_list l2 ∧ prod l2 = n</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : prod l1 = n := h1.right</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←h2.right] <span class="kw">at</span> h3</span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> l1 = l2 <span class="kw">from</span> Theorem_7_2_5 l1 l2 h1.left h2.left h3</span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Chap6.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Mathematical Induction</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
      <div class="nav-footer-center">© 2023 Daniel J. Velleman. Short excerpts from <a href="https://doi.org/10.1017/9781108539890"><i>How To Prove It</i></a>, published by Cambridge University Press, reproduced with permission.</div>
  </div>
</footer>



</body></html>