<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>How To Prove It With Lean - 7&nbsp; Number Theory</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Chap6.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="HTPIwLstyles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Number Theory</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">How To Prove It With Lean</a> 
        <div class="sidebar-tools-main">
    <a href="./How-To-Prove-It-With-Lean.pdf" title="Download PDF" class="sidebar-tool px-1"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Sentential Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Quantificational Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./IntroLean.html" class="sidebar-item-text sidebar-link">Introduction to Lean</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap3.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Proofs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap4.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Relations</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap5.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Functions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap6.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Mathematical Induction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap7.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Number Theory</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">In This Chapter</h2>
   
  <ul class="collapse">
  <li><a href="#greatest-common-divisors" id="toc-greatest-common-divisors" class="nav-link active" data-scroll-target="#greatest-common-divisors">7.1. Greatest Common Divisors</a></li>
  <li><a href="#prime-factorization" id="toc-prime-factorization" class="nav-link" data-scroll-target="#prime-factorization">7.2. Prime Factorization</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<div class="hidden">
$$
\newcommand{\setmin}{\mathbin{\backslash}}
\newcommand{\symmdiff}{\bigtriangleup}
$$
</div>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Number Theory</span></h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<section id="greatest-common-divisors" class="level2">
<h2 class="anchored" data-anchor-id="greatest-common-divisors">7.1. Greatest Common Divisors</h2>
<p>Section 7.1 of <em>HTPI</em> introduces the Euclidean algorithm for computing the greatest common divisor (gcd) of two positive integers <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. The motivation for the algorithm is the fact that if <span class="math inline">\(r\)</span> is the remainder when <span class="math inline">\(a\)</span> is divided by <span class="math inline">\(b\)</span>, then any natural number that divides both <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> also divides <span class="math inline">\(r\)</span>, and any natural number that divides both <span class="math inline">\(b\)</span> and <span class="math inline">\(r\)</span> also divides <span class="math inline">\(a\)</span>.</p>
<p>Let’s prove these statements in Lean. Recall that in Lean, the remainder when <code>a</code> is divided by <code>b</code> is called <code>a</code> mod <code>b</code>, and it is denoted <code>a % b</code>. We’ll prove the first statement, and leave the second as an exercise for you. It will be convenient for our work with greatest common divisors in Lean to let <code>a</code> and <code>b</code> be natural numbers rather than positive integers (thus allowing either of them to be zero).</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> dvd_mod_of_dvd_a_b {a b d : Nat}</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    (h1 : d ∣ a) (h2 : d ∣ b) : d ∣ (a % b) := <span class="kw">by</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> q : Nat := a / b</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : b * q + a % b = a := Nat.div_add_mod a b</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (j : Nat) (h4 : a = d * j) <span class="kw">from</span> h1</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (k : Nat) (h5 : b = d * k) <span class="kw">from</span> h2</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>    <span class="co">--Goal : ∃ (c : Nat), a % b = d * c</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (j - k * q)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a % b = d * (j - k * q) <span class="kw">from</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> a % b</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>      _ = b * q + a % b - b * q := (Nat.add_sub_cancel_left _ _).symm</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>      _ = a - b * q := <span class="kw">by</span> <span class="kw">rw</span> [h3]</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>      _ = d * j - d * (k * q) := <span class="kw">by</span> <span class="kw">rw</span> [h4, h5, mul_assoc]</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>      _ = d * (j - k * q) := (Nat.mul_sub_left_distrib _ _ _).symm</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> dvd_a_of_dvd_b_mod {a b d : Nat}</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    (h1 : d ∣ b) (h2 : d ∣ (a % b)) : d ∣ a := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>These theorems tell us that the gcd of <code>a</code> and <code>b</code> is the same as the gcd of <code>b</code> and <code>a % b</code>, which suggests that the following recursive definition should compute the gcd of <code>a</code> and <code>b</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="sc">**</span><span class="er">gcd</span><span class="sc">::</span> (a b : Nat) : Nat :=</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> b <span class="kw">with</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; a</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    | n + 1 =&gt; gcd (n + 1) (a % (n + 1))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Unfortunately, Lean puts a red squiggle under <code>gcd</code>, and it displays in the Infoview a long error message that begins <code>fail to show termination</code>. What is Lean complaining about?</p>
<p>The problem is that recursive definitions are dangerous. To understand the danger, consider the following recursive definition:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> loop (n : Nat) : Nat := loop (n + 1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Suppose we try to use this definition to compute <code>loop 3</code>. The definition would lead us to perform the following calculation:</p>
<div class="ind">
<p><code>loop 3 = loop 4 = loop 5 = loop 6 = ...</code></p>
</div>
<p>Clearly this calculation will go on forever and will never produce an answer. So the definition of <code>loop</code> does not actually succeed in defining a function from <code>Nat</code> to <code>Nat</code>.</p>
<p>Lean insists that recursive definitions must avoid such non-terminating calculations. Why did it accept all of our previous recursive definitions? The reason is that in each case, the definition of the value of the function at a natural number <code>n</code> referred only to values of the function at numbers smaller than <code>n</code>. Since a decreasing list of natural numbers cannot go on forever, such definitions lead to calculations that are guaranteed to terminate.</p>
<p>What about our recusive definition of <code>gcd a b</code>? This function has two arguments, <code>a</code> and <code>b</code>, and when <code>b = n + 1</code>, the definition asks us to compute <code>gcd (n + 1) (a % (n + 1))</code>. The first argument here could actually be larger than the first argument in the value we are trying to compute, <code>gcd a b</code>. But the second argument will always be smaller, and that will suffice to guarantee that the calculation terminates. We can tell Lean to focus on the second argument by adding a <code>termination_by</code> clause to the end of our recursive definition:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gcd (a b : Nat) : Nat :=</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> b <span class="kw">with</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; a</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    | n + 1 =&gt; <span class="sc">**</span><span class="er">gcd (n + 1) (a % (n + 1))</span><span class="sc">::</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">termination_by</span> gcd a b =&gt; b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Unfortunately, Lean still isn’t satisfied, but the error message this time is more helpful. The message says that Lean failed to prove termination, and at the end of the message it says that the goal it failed to prove is <code>a % (n + 1) &lt; Nat.succ n</code>. Here <code>Nat.succ n</code> denotes the successor of <code>n</code>—that is, <code>n + 1</code>—so Lean was trying to prove that <code>a % (n + 1) &lt; n + 1</code>, which is precisely what is needed to show that the second argument of <code>gcd (n + 1) (a % (n + 1))</code> is smaller than the second argument of <code>gcd a b</code> when <code>b = n + 1</code>. We’ll need to provide a proof of this goal to convince Lean to accept our recursive definition. Fortunately, it’s not hard to prove:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> mod_succ_lt (a n : Nat) : a % (n + 1) &lt; n + 1 := <span class="kw">by</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h : n + 1 &gt; 0 := Nat.succ_pos n</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a % (n + 1) &lt; n + 1 <span class="kw">from</span> Nat.mod_lt a h</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Lean’s error message suggests several ways to fix the problem with our recursive definition. We’ll use the first suggestion: <code>Use `have` expressions to prove the remaining goals</code>. Here, finally, is the definition of <code>gcd</code> that Lean is willing to accept:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gcd (a b : Nat) : Nat :=</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> b <span class="kw">with</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; a</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    | n + 1 =&gt;</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> : a % (n + 1) &lt; n + 1 := mod_succ_lt a n</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>      gcd (n + 1) (a % (n + 1))</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">termination_by</span> gcd a b =&gt; b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Notice that in the <code>have</code> expression, we have not bothered to specify an identifier for the assertion being proven, since we never need to refer to it. Let’s try out our <code>gcd</code> function:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="sc">++</span><span class="do">#eval</span><span class="sc">::</span> gcd 672 161    <span class="co">--Answer: 7.  Note 672 = 7 * 96 and 161 = 7 * 23.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To establish the main properties of <code>gcd a b</code> we’ll need several lemmas. We prove some of them and leave others as exercises.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> gcd_base (a : Nat) : gcd a 0 = a := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> plus_one_of_ne {n : Nat} (h : n ≠ 0) :</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    ∃ (k : Nat), n = k + 1 := <span class="cn">sorry</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> gcd_nonzero (a : Nat) {b : Nat} (h : b ≠ 0) :</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    gcd a b = gcd b (a % b) := <span class="kw">by</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (n : Nat) (h2 : b = n + 1) <span class="kw">from</span> plus_one_of_ne h</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h2]   <span class="co">--Goal : gcd a (n + 1) = gcd (n + 1) (a % (n + 1))</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rfl</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> mod_nonzero_lt (a : Nat) {b : Nat} (h : b ≠ 0) : a % b &lt; b := <span class="cn">sorry</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> dvd_self (n : Nat) : n ∣ n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>One of the most important properties of <code>gcd a b</code> is that it divides both <code>a</code> and <code>b</code>. We prove it by strong induction on <code>b</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> gcd_dvd : ∀ (b a : Nat), (gcd a b) ∣ a ∧ (gcd a b) ∣ b := <span class="kw">by</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_strong_induc</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> b : Nat</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> ih : ∀ (b_1 : Nat), b_1 &lt; b →</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    ∀ (a : Nat), (gcd a b_1) ∣ a ∧ (gcd a b_1) ∣ b_1</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : Nat</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h1 : b = 0</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h1 : b = 0</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h1, gcd_base]   <span class="co">--Goal: a ∣ a ∧ a ∣ 0</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro (dvd_self a)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro 0</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h1 : b ≠ 0</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [gcd_nonzero a h1]</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>      <span class="co">--Goal : gcd b (a % b) ∣ a ∧ gcd b (a % b) ∣ b</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : a % b &lt; b := mod_nonzero_lt a h1</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : (gcd b (a % b)) ∣ b ∧ (gcd b (a % b)) ∣ (a % b) :=</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>      ih (a % b) h2 b</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro _ h3.left</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> (gcd b (a % b)) ∣ a <span class="kw">from</span> dvd_a_of_dvd_b_mod h3.left h3.right</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You may wonder why we didn’t start the proof like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> gcd_dvd : ∀ (a b : Nat), (gcd a b) ∣ a ∧ (gcd a b) ∣ b := <span class="kw">by</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : Nat</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_strong_induc</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> b : Nat</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> ih : ∀ (b_1 : ℕ), b_1 &lt; b → (gcd a b_1) ∣ a ∧ (gcd a b_1) ∣ b_1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In fact, this approach wouldn’t have worked. It is an interesting exercise to try to complete this version of the proof and see why it fails.</p>
<p>Another interesting question is why we asserted both <code>(gcd a b) ∣ a</code> and <code>(gcd a b) ∣ b</code> in the same theorem. Wouldn’t it have been easier to give separate proofs of the statements <code>∀ (b a : Nat), (gcd a b) ∣ a</code> and <code>∀ (b a : Nat), (gcd a b) ∣ b</code>? Again, you might find it enlightening to see why that wouldn’t have worked. However, now that we have proven both divisibility statements, we can state them as separate theorems:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> gcd_dvd_left (a b : Nat) : (gcd a b) ∣ a := (gcd_dvd b a).left</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> gcd_dvd_right (a b : Nat) : (gcd a b) ∣ b := (gcd_dvd b a).right</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Next we turn to Theorem 7.1.4 in <em>HTPI</em>, which says that there are integers <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span> such that <span class="math inline">\(\text{gcd}(a, b) = s a + t b\)</span>. (We say that <span class="math inline">\(\text{gcd}(a, b)\)</span> can be written as a <em>linear combination</em> of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.) In <em>HTPI</em>, this is proven by using an extended version of the Euclidean algorithm to compute the coefficients <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span>. Here we will use a different recursive procedure to compute <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span>. If <span class="math inline">\(b = 0\)</span>, then <span class="math inline">\(\text{gcd}(a, b) = a = 1 \cdot a + 0 \cdot b\)</span>, so we can use the values <span class="math inline">\(s = 1\)</span> and <span class="math inline">\(t = 0\)</span>. Otherwise, let <span class="math inline">\(q\)</span> and <span class="math inline">\(r\)</span> be the quotient and remainder when <span class="math inline">\(a\)</span> is divided by <span class="math inline">\(b\)</span>. Then <span class="math inline">\(a = bq + r\)</span> and <span class="math inline">\(\text{gcd}(a, b) = \text{gcd}(b, r)\)</span>. Now suppose that we have already computed integers <span class="math inline">\(s'\)</span> and <span class="math inline">\(t'\)</span> such that <span class="math display">\[
\text{gcd}(b, r) = s' b + t' r.
\]</span> Then <span class="math display">\[\begin{align*}
\text{gcd}(a, b) &amp;= \text{gcd}(b, r) = s' b + t' r\\
&amp;= s' b + t' (a - bq) = t' a + (s' - t'q)b.
\end{align*}\]</span> Thus, to write <span class="math inline">\(\text{gcd}(a, b) = s a + t b\)</span> we can use the values <span class="math display">\[\begin{equation}\tag{$*$}
s = t', \qquad t = s' - t'q.
\end{equation}\]</span></p>
<p>We will use these equations as the basis for recursive definitions of Lean functions <code>gcd_c1</code> and <code>gcd_c2</code> such that the required coefficients can be obtained from the formulas <code>s = gcd_c1 a b</code> and <code>t = gcd_c2 a b</code>. Notice that <code>s</code> and <code>t</code> could be negative, so they must have type <code>Int</code>, not <code>Nat</code>. As a result, in definitions and theorems involving <code>gcd_c1</code> and <code>gcd_c2</code> we will sometimes have to deal with coercion of natural numbers to integers.</p>
<p>The functions <code>gcd_c1</code> and <code>gcd_c2</code> will be <em>mutually recursive</em>; in other words, each will be defined not only in terms of itself but also in terms of the other. Fortunately, Lean allows for such mutual recursion. Here are the definitions we will use.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">mutual</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> gcd_c1 (a b : Nat) : Int :=</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> b <span class="kw">with</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>      | 0 =&gt; 1</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>      | n + 1 =&gt; </span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">have</span> : a % (n + 1) &lt; n + 1 := mod_succ_lt a n</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        gcd_c2 (n + 1) (a % (n + 1))</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>          <span class="co">--Corresponds to s = t' in (*)</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> gcd_c2 (a b : Nat) : Int :=</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> b <span class="kw">with</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>      | 0 =&gt; 0</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>      | n + 1 =&gt;</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">have</span> : a % (n + 1) &lt; n + 1 := mod_succ_lt a n</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        gcd_c1 (n + 1) (a % (n + 1)) -</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>          (gcd_c2 (n + 1) (a % (n + 1))) * ↑(a / (n + 1))</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>          <span class="co">--Corresponds to t = s' - t'q in (*)</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">termination_by</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    gcd_c1 a b =&gt; b</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>    gcd_c2 a b =&gt; b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Notice that in the definition of <code>gcd_c2</code>, the quotient <code>a / (n + 1)</code> is computed using natural-number division, but it is then coerced to be an integer so that it can be multiplied by the integer <code>gcd_c2 (n + 1) (a % (n + 1))</code>.</p>
<p>Our main theorem about these functions is that they give the coefficients needed to write <code>gcd a b</code> as a linear combination of <code>a</code> and <code>b</code>. As usual, stating a few lemmas first helps with the proof. We leave the proofs of two of them as exercises for you (hint: imitate the proof of <code>gcd_nonzero</code> above).</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> gcd_c1_base (a : Nat) : gcd_c1 a 0 = 1 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> gcd_c1_nonzero (a : Nat) {b : Nat} (h : b ≠ 0) :</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    gcd_c1 a b = gcd_c2 b (a % b) := <span class="cn">sorry</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> gcd_c2_base (a : Nat) : gcd_c2 a 0 = 0 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> gcd_c2_nonzero (a : Nat) {b : Nat} (h : b ≠ 0) :</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    gcd_c2 a b = gcd_c1 b (a % b) - (gcd_c2 b (a % b)) * ↑(a / b) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With that preparation, we are ready to prove that <code>gcd_c1 a b</code> and <code>gcd_c2 a b</code> give coefficients for expressing <code>gcd a b</code> as a linear combination of <code>a</code> and <code>b</code>. Of course, the theorem is proven by strong induction. We’ll make a few comments after the proof that may help you follow the details.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> gcd_lin_comb : ∀ (b a : Nat),</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    (gcd_c1 a b) * a + (gcd_c2 a b) * b = gcd a b := <span class="kw">by</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_strong_induc</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> b : Nat</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> ih : ∀ (b_1 : Nat), b_1 &lt; b → ∀ (a : Nat),</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    (gcd_c1 a b_1) * ↑a + (gcd_c2 a b_1) * ↑b_1 = ↑(gcd a b_1)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : Nat</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h1 : b = 0</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h1 : b = 0</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h1, gcd_c1_base, gcd_c2_base, gcd_base]</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>      <span class="co">--Goal : 1 * ↑a + 0 * ↑0 = ↑a</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">norm_num</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h1 : b ≠ 0</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [gcd_c1_nonzero a h1, gcd_c2_nonzero a h1, gcd_nonzero a h1]</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r : Nat := a % b</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> q : Nat := a / b</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s : Int := gcd_c1 b r</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> t : Int := gcd_c2 b r</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> hr : a % b = r := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> hq : a / b = q := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> hs : gcd_c1 b r = s := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> ht : gcd_c2 b r = t := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : r &lt; b := mod_nonzero_lt a h1</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : (gcd_c1 b r) * ↑b + (gcd_c2 b r )* ↑r = ↑(gcd b r) :=</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>      ih r h2 b</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [hr, ←h3, hs, ht, hq]</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>      <span class="co">--Goal : t * ↑a + (s - t * ↑q) * ↑b = s * ↑b + t * ↑r</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : (↑a : Int) = ↑b * ↑q + ↑r := <span class="kw">by</span></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [←Nat.div_add_mod a b, Nat.cast_add, Nat.cast_mul]</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rfl</span></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h4]</span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>      <span class="co">--Goal : t * (↑b * ↑q + ↑r) + (s - t * ↑q) * ↑b = s * ↑b + t * ↑r</span></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">ring</span></span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In the statement of the theorem, we have left it up to Lean to insert the required coercions. You can see the coercions by looking at the tactic state at the beginning of the proof, where the equation to be proven is displayed as</p>
<div class="ind">
<p><code>gcd_c1 a b * ↑a + gcd_c2 a b * ↑b = ↑(gcd a b)</code></p>
</div>
<p>For clarity, we have written the coercions explicitly in the statement of the inductive hypothesis. In case 2, we have introduced the variables <code>r</code>, <code>q</code>, <code>s</code>, and <code>t</code> to simplify the notation. In the statement <code>h4</code>, Lean wouldn’t have known what type to coerce the variables to if we hadn’t specified the type of <code>↑a</code> on the left side of the equation; with that hint, Lean figured out that for the equation to make sense, the variables on the right side also had to be coerced to type <code>Int</code>. In the proof of <code>h4</code>, the rewrite rule <code>←Nat.div_add_mod a b</code> converts the left side of the goal to <code>↑(b * q + r)</code>. You can use the <code>#check</code> command to see why <code>Nat.cast_add</code> and <code>Nat.cast_mul</code> then convert the left side to first <code>↑(b * q) + ↑r</code> and then <code>↑b * ↑q + ↑r</code>.</p>
<p>We can try out the functions <code>gcd_c1</code> and <code>gcd_c2</code> as follows:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="sc">++</span><span class="do">#eval</span><span class="sc">::</span> gcd_c1 672 161  <span class="co">--Answer: 6</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="sc">++</span><span class="do">#eval</span><span class="sc">::</span> gcd_c2 672 161  <span class="co">--Answer: -25</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">--Note 6 * 672 - 25 * 161 = 4032 - 4025 = 7 = gcd 672 161</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, we turn to Theorem 7.1.6 in <em>HTPI</em>, which expresses one of the senses in which <code>gcd a b</code> is the <em>greatest</em> common divisor of <code>a</code> and <code>b</code>. Our proof follows the strategy of the proof in <em>HTPI</em>, with one additional step: we begin by using the theorem <code>Int.coe_nat_dvd</code> to change the goal from <code>d ∣ gcd a b</code> to <code>↑d ∣ ↑(gcd a b)</code>, so that the rest of the proof can work with integer algebra rather than natural-number algebra.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_1_6 {d a b : Nat} (h1 : d ∣ a) (h2 : d ∣ b) :</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    d ∣ gcd a b := <span class="kw">by</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←Int.coe_nat_dvd]    <span class="co">--Goal : ↑d ∣ ↑(gcd a b)</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s : Int := gcd_c1 a b</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> t : Int := gcd_c2 a b</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : s * ↑a + t * ↑b = ↑(gcd a b) := gcd_lin_comb b a</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←h3]                 <span class="co">--Goal : ↑d ∣ s * ↑a + t * ↑b</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (j : Nat) (h4 : a = d * j) <span class="kw">from</span> h1</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (k : Nat) (h5 : b = d * k) <span class="kw">from</span> h2</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h4, h5, Nat.cast_mul, Nat.cast_mul]</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">--Goal : ↑d ∣ s * (↑d * ↑j) + t * (↑d * ↑k)</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (s * ↑j + t * ↑k)</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">ring</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="prime-factorization" class="level2">
<h2 class="anchored" data-anchor-id="prime-factorization">7.2. Prime Factorization</h2>
<p>A natural number <span class="math inline">\(n\)</span> is said to be <em>prime</em> if it is at least 2 and it cannot be written as a product of two smaller natural numbers. Two natural numbers are <em>relatively prime</em> if their greatest common divisor is 1. Of course, we can write these definitions in Lean.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prime (n : Nat) : <span class="kw">Prop</span> :=</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  2 ≤ n ∧ ¬∃ (a b : Nat), a * b = n ∧ a &lt; n ∧ b &lt; n</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rel_prime (a b : Nat) : <span class="kw">Prop</span> := gcd a b = 1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The main goal of Section 7.2 of <em>HTPI</em> is to prove that every positive integer can be written in a unique way as a product of prime numbers. In preparation for that goal, <em>HTPI</em> proves two theorems, 7.2.2 and 7.2.3. Here are proofs of those theorems in Lean, with the proof of one lemma left as an exercise. In the proof of Theorem 7.2.2, we begin, as we did in the proof of Theorem 7.1.6, by converting the goal from natural numbers to integers so that we can use integer algebra.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_2_2 {a b c : Nat}</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    (h1 : c ∣ a * b) (h2 : rel_prime a c) : c ∣ b := <span class="kw">by</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←Int.coe_nat_dvd]  <span class="co">--Goal : ↑c ∣ ↑b</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1; <span class="kw">define</span> <span class="kw">at</span> h2; <span class="kw">define</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (j : Nat) (h3 : a * b = c * j) <span class="kw">from</span> h1</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s : Int := gcd_c1 a c</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> t : Int := gcd_c2 a c</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : s * ↑a + t * ↑c = ↑(gcd a c) := gcd_lin_comb c a</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h2, Nat.cast_one] <span class="kw">at</span> h4  <span class="co">--h4 : s * ↑a + t * ↑c = (1 : Int)</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (s * ↑j + t * ↑b)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ↑b = ↑c * (s * ↑j + t * ↑b) <span class="kw">from</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> ↑b</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>      _ = (1 : Int) * ↑b := (one_mul _).symm</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>      _ = (s * ↑a + t * ↑c) * ↑b := <span class="kw">by</span> <span class="kw">rw</span> [h4]</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>      _ = s * (↑a * ↑b) + t * ↑c * ↑b := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>      _ = s * (↑c * ↑j) + t * ↑c * ↑b := <span class="kw">by</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>          <span class="kw">rw</span> [←Nat.cast_mul a b, h3, Nat.cast_mul c j]</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>      _ = ↑c * (s * ↑j + t * ↑b) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> dvd_prime {a p : Nat}</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    (h1 : prime p) (h2 : a ∣ p) : a = 1 ∨ a = p := <span class="cn">sorry</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> rel_prime_of_prime_not_dvd {a p : Nat}</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>    (h1 : prime p) (h2 : ¬p ∣ a) : rel_prime a p := <span class="kw">by</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : gcd a p ∣ a := gcd_dvd_left a p</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : gcd a p ∣ p := gcd_dvd_right a p</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : gcd a p = 1 ∨ gcd a p = p := dvd_prime h1 h4</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : gcd a p ≠ p := <span class="kw">by</span></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">contradict</span> h2 <span class="kw">with</span> h6</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h6] <span class="kw">at</span> h3</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> p ∣ a <span class="kw">from</span> h3</span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">disj_syll</span> h5 h6</span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> rel_prime a p <span class="kw">from</span> h5</span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_2_3 {a b p : Nat}</span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>    (h1 : prime p) (h2 : p ∣ a * b) : p ∣ a ∨ p ∣ b := <span class="kw">by</span></span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">or_right</span> <span class="kw">with</span> h3</span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : rel_prime a p := rel_prime_of_prime_not_dvd h1 h3</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> p ∣ b <span class="kw">from</span> Theorem_7_2_2 h2 h4</span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Defining the prime factorization of a natural number <code>n</code> in Lean will take several steps. For <code>n ≥ 2</code>, we begin by searching for the smallest prime factor of <code>n</code>. A natural approach is to test whether <code>n</code> is divisible by 2, then 3, then 4, and so on, until we find a divisor of <code>n</code>. However, we have to be careful how we describe this calculation to Lean: since we are testing larger and larger potential divisors, Lean may fear that the calculation may not terminate. To avoid this problem, we will ask Lean to test whether or not <code>(n - k) ∣ n</code> for various values of <code>k</code>. By performing this test for smaller and smaller values of <code>k</code>, we will test larger and larger potential divisors of <code>n</code>. Since <code>k</code> is decreasing, the search is guaranteed to terminate. If <code>k</code> reaches 0, then we will test whether or not <code>n ∣ n</code>, and of course the answer will be yes.</p>
<p>We begin by defining a function <code>first_div_ge</code> such that for any <code>n</code> and <code>k</code>, <code>first_div_ge n k</code> is the smallest divisor of <code>n</code> that is greater than or equal to <code>n - k</code>.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> first_div_ge (n k : Nat) : Nat :=</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> k <span class="kw">with</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; n</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    | j + 1 =&gt; if n - (j + 1) ∣ n then n - (j+ 1) else first_div_ge n j</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This is the first time we have used an <code>if ... then ... else</code> expression in a Lean definition. To prove theorems about such expressions, we will need two theorems from Lean’s library, <code>if_pos</code> and <code>if_neg</code>. The <code>#check</code> command tells us what they say:</p>
<div class="ind">
<pre><code>@if_pos : ∀ {c : Prop} {h : Decidable c},
          c → ∀ {α : Sort u_1} {t e : α}, (if c then t else e) = t
@if_neg : ∀ {c : Prop} {h : Decidable c},
          ¬c → ∀ {α : Sort u_1} {t e : α}, (if c then t else e) = e</code></pre>
</div>
<p>Ignoring the implicit arguments, this tells us that if <code>h</code> is a proof of a proposition <code>c</code>, then <code>if_pos h</code> is a proof of <code>(if c then t else e) = t</code>, and if <code>h</code> is a proof of <code>¬c</code>, then <code>if_neg h</code> is a proof of <code>(if c then t else e) = e</code>. (Technically, the implicit arguments say that <code>c</code> must be a “decidable” proposition, but we won’t worry about that detail.)</p>
<p>The important properties of <code>first_div_ge</code> are that <code>first_div_ge n k</code> divides <code>n</code>, it is greater than or equal to <code>n - k</code>, and it is the smallest number with those two properties. All three can be proven by induction on <code>k</code>. We prove the first, and leave the other two as exercises.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fdge_base (n : Nat) : first_div_ge n 0 = n := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fdge_step (n j : Nat) :</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    first_div_ge n (j + 1) =</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>      if n - (j + 1) ∣ n then n - (j + 1) else first_div_ge n j := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fdge_dvd (n : Nat) : ∀ (k : Nat), first_div_ge n k ∣ n := <span class="kw">by</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [fdge_base]  <span class="co">--Goal : n ∣ n</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> n ∣ n <span class="kw">from</span> dvd_self n</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> k : Nat</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : first_div_ge n k ∣ n</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [fdge_step]  <span class="co">--Goal :</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- (if n - (k + 1) ∣ n then n - (k + 1) else first_div_ge n k) ∣ n</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_cases</span> h1 : n - (k + 1) ∣ n</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 1. h1: n - (k + 1) ∣ n</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [if_pos h1]  <span class="co">--Goal : n - (k + 1) ∣ n</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> n - (k + 1) ∣ n <span class="kw">from</span> h1</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2. h1: ¬n - (k + 1) ∣ n</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [if_neg h1]  <span class="co">--Goal : first_div_ge n k ∣ n</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> first_div_ge n k ∣ n <span class="kw">from</span> ih</span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fdge_ge (n : Nat) : ∀ (k : Nat), n - k ≤ first_div_ge n k := <span class="cn">sorry</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  You may find the theorem Nat.sub_le_sub_left useful</span></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fdge_least (d n : Nat) : ∀ (k : Nat),</span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>    d ∣ n → n - k ≤ d → first_div_ge n k ≤ d := <span class="cn">sorry</span></span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a><span class="co">--Hints:</span></span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a><span class="co">--1. n - (k + 1) is definitionally equal to n - k - 1</span></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a><span class="co">--2. You may find the theorems le_tsub_add and lt_of_le_of_ne' useful</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Chap6.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Mathematical Induction</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
      <div class="nav-footer-center">© 2023 Daniel J. Velleman. Short excerpts from <a href="https://doi.org/10.1017/9781108539890"><i>How To Prove It</i></a>, published by Cambridge University Press, reproduced with permission.</div>
  </div>
</footer>



</body></html>