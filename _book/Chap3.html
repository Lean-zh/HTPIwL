<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>How To Prove It With Lean - 3&nbsp; Proofs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./IntroLean.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="HTPIwLstyles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Proofs</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">How To Prove It With Lean</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Sentential Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Quantificational Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./IntroLean.html" class="sidebar-item-text sidebar-link">Introduction to Lean</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap3.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Proofs</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul class="collapse">
  <li><a href="#proofs-involving-negations-and-conditionals" id="toc-proofs-involving-negations-and-conditionals" class="nav-link active" data-scroll-target="#proofs-involving-negations-and-conditionals">3.1 &amp; 3.2. Proofs Involving Negations and Conditionals</a></li>
  <li><a href="#proofs-involving-quantifiers" id="toc-proofs-involving-quantifiers" class="nav-link" data-scroll-target="#proofs-involving-quantifiers">3.3. Proofs Involving Quantifiers</a></li>
  <li><a href="#proofs-involving-conjunctions-and-biconditionals" id="toc-proofs-involving-conjunctions-and-biconditionals" class="nav-link" data-scroll-target="#proofs-involving-conjunctions-and-biconditionals">3.4. Proofs Involving Conjunctions and Biconditionals</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<div class="hidden">
$$
\newcommand{\setmin}{\mathbin{\backslash}}
$$
</div>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Proofs</span></h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<section id="proofs-involving-negations-and-conditionals" class="level2">
<h2 class="anchored" data-anchor-id="proofs-involving-negations-and-conditionals">3.1 &amp; 3.2. Proofs Involving Negations and Conditionals</h2>
<p>Sections 3.1 and 3.2 of <em>How To Prove It</em> present strategies for dealing with givens and goals involving negations and conditionals. We restate those strategies here, and explain how to use them with Lean.</p>
<p>Section 3.1 gives two strategies for proving a goal of the form <code>P → Q</code>:</p>
<section id="to-prove-a-goal-of-the-form-p-q" class="level4">
<h4 class="anchored" data-anchor-id="to-prove-a-goal-of-the-form-p-q">To prove a goal of the form <code>P → Q</code>:</h4>
<ol type="1">
<li>Assume <code>P</code> is true and prove <code>Q</code>.</li>
<li>Assume <code>Q</code> is false and prove that <code>P</code> is false.</li>
</ol>
<p>We’ve already seen how to carry out both of these strategies in Lean. For the first strategy, use the <code>assume</code> tactic to introduce the assumption <code>P</code> and assign an identifier to it; Lean will automaticall set <code>Q</code> as the goal. We can summarize the effect of using this strategy by showing how the tactic state changes if you use the tactic <code>assume h : P</code>:</p>
<div class="lftrt">
<div class="bef">
<div class="sourceCode" id="cb1"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span> ⋮</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>⊢ P → Q</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="aft">
<div class="sourceCode" id="cb2"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span> ⋮</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="in">h </span>: P</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>⊢ Q</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The second strategy is justified by the contrapositive law. In Lean, you can use the <code>contrapos</code> tactic to rewrite the goal as <code>¬Q → ¬P</code> and then use the tactic <code>assume h : ¬Q</code>. The net effect of these two tactics is:</p>
<div class="lftrt">
<div class="bef">
<div class="sourceCode" id="cb3"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span> ⋮</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>⊢ P → Q</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="aft">
<div class="sourceCode" id="cb4"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span> ⋮</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="in">h </span>: ¬Q</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>⊢ ¬P</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Section 3.2 gives two strategies for using givens of the form <code>P → Q</code>, with the second once again being a variation on the first based on the contrapositive law:</p>
</section>
<section id="to-use-a-given-of-the-form-p-q" class="level4">
<h4 class="anchored" data-anchor-id="to-use-a-given-of-the-form-p-q">To use a given of the form <code>P → Q</code>:</h4>
<ol type="1">
<li>If you are also given <code>P</code>, or you can prove that <code>P</code> is true, then you can use this given to conclude that <code>Q</code> is true.</li>
<li>If you are also given <code>¬Q</code>, or you can prove that <code>Q</code> is false, then you can use this given to conclude that <code>P</code> is false.</li>
</ol>
<p>The first strategy is the modus ponens rule of inference, and we saw in the last chapter that if you have <code>h1 : P → Q</code> and <code>h2 : P</code>, then <code>h1 h2</code> is a (term-mode) proof of <code>Q</code>; often we use this rule with the <code>have</code> or <code>show</code> tactic. For the second strategy, if you have <code>h1 : P → Q</code> and <code>h2 : ¬Q</code>, then the <code>contrapos at h1</code> tactic will change <code>h1</code> to <code>h1 : ¬Q → ¬P</code>, and then <code>h1 h2</code> will be a proof of <code>¬P</code>.</p>
<p>All of the strategies listed above for working with conditional statements as givens or goals were illustrated in examples in the last chapter.</p>
<p>Section 3.2 of <em>HTPI</em> offers two strategies for proving negative goals:</p>
</section>
<section id="to-prove-a-goal-of-the-form-p" class="level4">
<h4 class="anchored" data-anchor-id="to-prove-a-goal-of-the-form-p">To prove a goal of the form <code>¬P</code>:</h4>
<ol type="1">
<li>Reexpress the goal in some other form.</li>
<li>Use proof by contradiction: assume <code>P</code> is true and try to deduce a contradiction.</li>
</ol>
<p>For the first strategy, the tactics <code>demorgan</code>, <code>conditional</code>, and <code>double_neg</code> may be useful, and we saw how those tactics work in the last chapter. But how do you write a proof by contradiction in Lean? The answer is to use a tactic called <code>by_contra</code>. If the goal is <code>¬P</code>, then the tactic <code>by_contra h</code> will introduce the assumption <code>h : P</code> and set the goal to be <code>False</code>, like this:</p>
<div class="lftrt">
<div class="bef">
<div class="sourceCode" id="cb5"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span> ⋮</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>⊢ ¬P</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="aft">
<div class="sourceCode" id="cb6"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span> ⋮</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="in">h </span>: P</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>⊢ False</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>In Lean, <code>False</code> represents a statement that is always false—that is, a contradiction, as that term is defined in Section 1.2 of <em>HTPI</em>. The <code>by_contra</code> tactic can actually be used even if the goal is not a negative statement. If the goal is a statement <code>P</code> that is not a negative statement, then <code>by_contra h</code> will initiate a proof by contradiction by introducing the assumption <code>h : ¬P</code> and setting the goal to be <code>False</code>.</p>
<p>You will usually complete a proof by contradiction by deducing two contradictory statements—say, <code>h1 : Q</code> and <code>h2 : ¬Q</code>. But how do you convince Lean that the proof is over? You must be able to prove the goal <code>False</code> from the two givens <code>h1</code> and <code>h2</code>. There are two ways to do this. The first is based on the fact that Lean treats a statement of the form <code>¬Q</code> as meaning the same thing as <code>Q → False</code>. This makes sense, because these statements are logically equivalent, as shown by the following truth table:</p>
<div style="margin: 0% 20%">
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;"><code>Q</code></th>
<th style="text-align: center;"><code>¬Q</code></th>
<th style="text-align: right;"><code>(Q</code></th>
<th style="text-align: center;"><code>→</code></th>
<th style="text-align: left;"><code>False)</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
<td style="text-align: right;">F</td>
<td style="text-align: center;">T</td>
<td style="text-align: left;">&nbsp;&nbsp;<span class="excl">&nbsp;</span> F</td>
</tr>
<tr class="even">
<td style="text-align: center;">T</td>
<td style="text-align: center;">F</td>
<td style="text-align: right;">T</td>
<td style="text-align: center;">F</td>
<td style="text-align: left;">&nbsp;&nbsp;<span class="excl">&nbsp;</span> F</td>
</tr>
</tbody>
</table>
</div>
<p>Thinking of <code>h2 : ¬Q</code> as meaning <code>h2 : Q → False</code>, we can combine it with <code>h1 : Q</code> using modus ponens to deduce <code>False</code>. In other words, <code>h2 h1</code> is a proof of <code>False</code>.</p>
<p>But there is a second way of completing the proof that it is worthwhile to know about. From contradictory statements <code>h1 : Q</code> and <code>h2 : ¬Q</code> you can validly deduce <em>any</em> statement. This follows from the definition of a <em>valid argument</em> in Section 1.1 of <em>HTPI</em>. According to that definition, you can validly infer a conclusion <code>R</code> from premises <code>h1 : Q</code> and <code>h2 : ¬Q</code> if the premises cannot both be true without the conclusion also being true. In this case, that standard is met, for the simple reason that the premises cannot both be true! (This gives part of the answer to exercise 18 in Section 1.2 of <em>HTPI</em>.) Thus, Lean has a rule that allows you to prove any statement from contradictory premises. If you have <code>h1 : Q</code> and <code>h2 : ¬Q</code>, then Lean will recognize <code>absurd h1 h2</code> as a (term-mode) proof of <em>any</em> statement.</p>
<p>To summarize, if you have <code>h1 : Q</code> and <code>h2 : ¬Q</code>, then there are two ways to prove <code>False</code>. Lean will recognize <code>h2 h1</code> as a proof of <code>False</code>, and it will recognize <code>absurd h1 h2</code> as a proof of any statement, including <code>False</code>. Notice the difference in the order in which <code>h1</code> and <code>h2</code> are listed in these two proofs: In the first one, the negative statement <code>h2</code> must come first, just as the conditional statement must come first in an application of modus ponens. But in a proof using <code>absurd</code>, the negative statement must come second.</p>
<p>To illustrate proof by contradiction in Lean, let’s redo our first example from the last Chapter in a different way. That example was based on Example 3.2.4 in <em>HTPI</em>. We’ll begin with the same first two steps, introducing two assumptions. (We won’t bother to include the <code>done</code> line in the displays below.)</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb7"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_2_4_v2 (P Q R : <span class="kw">Prop</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>(h : P → (Q → R)) : ¬R → (P → ¬Q) := <span class="kw">by</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ¬R</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : P</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb8"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="in">P Q R </span>: Prop</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="in">h </span>: P → Q → R</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬R</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: P</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>⊢ ¬Q</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now the goal is a negative statement, so we use the tactic <code>by_contra h4</code> to introduce the assumption <code>h4 : Q</code> and set the goal to be <code>False</code>:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb9"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_2_4_v2 (P Q R : <span class="kw">Prop</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>(h : P → (Q → R)) : ¬R → (P → ¬Q) := <span class="kw">by</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ¬R</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : P</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h4</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb10"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="in">P Q R </span>: Prop</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="in">h </span>: P → Q → R</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬R</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: P</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: Q</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>⊢ False</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Using the givens <code>h</code>, <code>h3</code>, and <code>h4</code> we can deduce first <code>Q → R</code> and then <code>R</code> by two applications of modus ponens:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb11"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_2_4_v2 (P Q R : <span class="kw">Prop</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>(h : P → (Q → R)) : ¬R → (P → ¬Q) := <span class="kw">by</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ¬R</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : P</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h4</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : Q → R := h h3</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : R := h5 h4</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb12"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="in">P Q R </span>: Prop</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="in">h </span>: P → Q → R</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬R</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: P</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: Q</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: Q → R</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="in">h6 </span>: R</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>⊢ False</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now we have a contradiction: <code>h2 : ¬R</code> and <code>h6 : R</code>. To complete the proof, we deduce <code>False</code> from these two givens. Either <code>h2 h6</code> or <code>absurd h6 h2</code> would be accepted by Lean as a proof of <code>False</code>:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb13"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_2_4_v2 (P Q R : <span class="kw">Prop</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>(h : P → (Q → R)) : ¬R → (P → ¬Q) := <span class="kw">by</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ¬R</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : P</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h4</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : Q → R := h h3</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : R := h5 h4</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> False <span class="kw">from</span> h2 h6</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb14"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>Goals accomplished 🎉</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Finally, we have two strategies for using a given that is a negative statement:</p>
</section>
<section id="to-use-a-given-of-the-form-p" class="level4">
<h4 class="anchored" data-anchor-id="to-use-a-given-of-the-form-p">To use a given of the form <code>¬P</code>:</h4>
<ol type="1">
<li>Reexpress the given in some other form.</li>
<li>If you are doing a proof by contradiction, you can achieve a contradiction by proving <code>P</code>, since that would contradict the given <code>¬P</code>.</li>
</ol>
<p>Of course, strategy 1 suggests the use of the <code>demorgan</code>, <code>conditional</code>, and <code>double_neg</code> tactics, if they apply. For strategy 2, if you are doing a proof by contradiction and you have a given <code>h : ¬P</code>, then the tactic <code>contradict h</code> will set the goal to be <code>P</code>, which will complete the proof by contradicting <code>h</code>. In fact, this tactic can be used with any given; if you have a given <code>h : P</code>, where <code>P</code> is not a negative statement, then <code>contradict h</code> will set the goal to be <code>¬P</code>. If you’re not doing a proof by contradiction, then the tactic <code>contradict h with h'</code> will first initiate a proof by contradiction by assuming the negation of the goal, giving that assumption the identifier <code>h'</code>, and then it will set the goal to be the negation of <code>h</code>. In other words, <code>contradict h with h'</code> is shorthand for <code>by_contra h'; contradict h</code>.</p>
<p>We can illustrate this with yet another way to write the proof from Example 3.2.4. Our first three steps will be the same as last time:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb15"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_2_4_v3 (P Q R : <span class="kw">Prop</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>(h : P → (Q → R)) : ¬R → (P → ¬Q) := <span class="kw">by</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ¬R</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : P</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h4</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb16"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="in">P Q R </span>: Prop</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="in">h </span>: P → Q → R</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬R</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: P</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: Q</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>⊢ False</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Since we are now doing a proof by contradiction and the given <code>h2 : ¬R</code> is a negative statement, a likely way to proceed is to try to prove <code>R</code>, which would contradict <code>h2</code>. So we use the tactic <code>contradict h2</code>:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb17"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_2_4_v3 (P Q R : <span class="kw">Prop</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>(h : P → (Q → R)) : ¬R → (P → ¬Q) := <span class="kw">by</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ¬R</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : P</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h4</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">contradict</span> h2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb18"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="in">P Q R </span>: Prop</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="in">h </span>: P → Q → R</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬R</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: P</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: Q</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>⊢ R</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>As before, we can now prove <code>R</code> by combining <code>h</code>, <code>h3</code>, and <code>h4</code>. In fact, we could do it in one step: by modus ponens, <code>h h3</code> is a proof of <code>Q → R</code>, and therefore, by another application of modus ponens, <code>(h h3) h4</code> is a proof of <code>R</code>. The parentheses here are not necessary; Lean will interpret <code>h h3 h4</code> as <code>(h h3) h4</code>, so we can complete the proof like this:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb19"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_2_4_v3 (P Q R : <span class="kw">Prop</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>(h : P → (Q → R)) : ¬R → (P → ¬Q) := <span class="kw">by</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ¬R</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : P</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h4</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">contradict</span> h2</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> R <span class="kw">from</span> h h3 h4</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb20"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>Goals accomplished 🎉</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>You could shorten this proof slightly by replacing the lines <code>by_contra h4</code> and <code>contradict h2</code> with the single line <code>contradict h2 with h4</code>.</p>
<p>There is one more idea that is introduced in Section 3.2 of <em>HTPI</em>. The last example in that section illustrates how you can sometimes use rules of inference to work backwards. Here’s a similar example in Lean:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb21"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_2_5</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>(U : <span class="kw">Type</span>) (A B C : Set U) (a : U)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>(h1 : a ∈ A) (h2 : a ∉ A \ B)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>(h3 : a ∈ B → a ∈ C) : a ∈ C := <span class="kw">by</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb22"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: a ∈ A</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬a ∈ A \ B</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: a ∈ B → a ∈ C</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>⊢ a ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The goal is <code>a ∈ C</code>, and the only given that even mentions <code>C</code> is <code>h3 : a ∈ B → a ∈ C</code>. If only we could prove <code>a ∈ B</code>, then we could apply <code>h3</code>, using modus ponens, to reach our goal. So it would make sense to work toward the goal of proving <code>a ∈ B</code>.</p>
<p>To get Lean to use this proof strategy, we use the tactic <code>apply h3 _</code>. The underscore here represents a blank to be filled in by Lean. You might think of this tactic as asking Lean the question: If we want <code>h3 _</code> to be a proof of the goal <code>a ∈ C</code>, what do we have to put in the blank? Lean is able to figure out that the answer is: a proof of <code>a ∈ B</code>. So it sets the goal to be <code>a ∈ B</code>, since a proof of that goal, when inserted into the blank in <code>h3 _</code>, would prove the original goal <code>a ∈ C</code>:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb23"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_2_5</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>(U : <span class="kw">Type</span>) (A B C : Set U) (a : U)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>(h1 : a ∈ A) (h2 : a ∉ A \ B)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>(h3 : a ∈ B → a ∈ C) : a ∈ C := <span class="kw">by</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> h3 _</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb24"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C</span>: Set U</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: a ∈ A</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬a ∈ A \ B</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: a ∈ B → a ∈ C</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>⊢ a ∈ B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>It may not be clear what to do next, but the given <code>h2</code> is a negative statement, so perhaps reexpressing it will help. Writing out the definition of set difference, <code>h2</code> means <code>¬(a ∈ A ∧ a ∉ B)</code>, and then one of De Morgan’s laws and a conditional law allow us to rewrite it first as <code>(a ∉ A ∨ a ∈ B)</code> and then as <code>(a ∈ A → a ∈ B)</code>. Of course, we have tactics to accomplish all of these reexpressions:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb25"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_2_5</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>(U : <span class="kw">Type</span>) (A B C : Set U) (a : U)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>(h1 : a ∈ A) (h2 : a ∉ A \ B)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>(h3 : a ∈ B → a ∈ C) : a ∈ C := <span class="kw">by</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> h3 _</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">demorgan</span> <span class="kw">at</span> h2; <span class="kw">conditional</span> <span class="kw">at</span> h2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb26"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: a ∈ A</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: a ∈ A → a ∈ B</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: a ∈ B → a ∈ C</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>⊢ a ∈ B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>And now it is easy to complete the proof by applying modus ponens, using <code>h2</code> and <code>h1</code>:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb27"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_2_5</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>(U : <span class="kw">Type</span>) (A B C : Set U) (a : U)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>(h1 : a ∈ A) (h2 : a ∉ A \ B)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>(h3 : a ∈ B → a ∈ C) : a ∈ C := <span class="kw">by</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> h3 _</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">demorgan</span> <span class="kw">at</span> h2; <span class="kw">conditional</span> <span class="kw">at</span> h2</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a ∈ B <span class="kw">from</span> h2 h1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb28"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>Goals accomplished 🎉</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We will see many more uses of the <code>apply</code> tactic later in this book.</p>
<p>Sections 3.1 and 3.2 of <em>HTPI</em> contain several proofs that involve algebraic reasoning. Although one can do such proofs in Lean, it requires ideas that we are not ready to introduce yet. So for the moment we will stick to proofs involving only logic and set theory.</p>
</section>
</section>
<section id="proofs-involving-quantifiers" class="level2">
<h2 class="anchored" data-anchor-id="proofs-involving-quantifiers">3.3. Proofs Involving Quantifiers</h2>
<p>In the notation used in <em>HTPI</em>, if <span class="math inline">\(P(x)\)</span> is a statement about <span class="math inline">\(x\)</span>, then <span class="math inline">\(\forall x\, P(x)\)</span> means “for all <span class="math inline">\(x\)</span>, <span class="math inline">\(P(x)\)</span>,” and <span class="math inline">\(\exists x\, P(x)\)</span> means “there exists at least one <span class="math inline">\(x\)</span> such that <span class="math inline">\(P(x)\)</span>.” The letter <span class="math inline">\(P\)</span> here does not stand for a proposition; it is only when it is applied to some object <span class="math inline">\(x\)</span> that we get a proposition. We will say that <span class="math inline">\(P\)</span> is a <em>predicate</em>, and when we apply <span class="math inline">\(P\)</span> to an object <span class="math inline">\(x\)</span> we get a proposition <span class="math inline">\(P(x)\)</span>. You might want to think of the predicate <span class="math inline">\(P\)</span> as representing some property that an object might have, and the proposition <span class="math inline">\(P(x)\)</span> asserts that <span class="math inline">\(x\)</span> has that property.</p>
<p>To use a predicate in Lean, you must tell Lean the type of objects to which it applies. If <code>U</code> is a type, then <code>Pred U</code> is the type of predicates that apply to objects of type <code>U</code>. If <code>P</code> has type <code>Pred U</code> (that is, <code>P</code> is a predicate applying to objects of type <code>U</code>) and <code>x</code> has type <code>U</code>, then to apply <code>P</code> to <code>x</code> we just write <code>P x</code> (with a space but no parentheses). Thus, if we have <code>P : Pred U</code> and <code>x : U</code>, then <code>P x</code> is an expression of type <code>Prop</code>. That is, <code>P x</code> is a proposition, and its meaning is that <code>x</code> has the property represented by the predicate <code>P</code>.</p>
<p>There are a few differences between the way quantified statements are written in <em>HTPI</em> and the way they are written in Lean. First of all, when we apply a quantifier to a variable in Lean we will specify the type of the variable explicitly. Also, Lean requires that after specifying the variable and its type, you must put a comma before the proposition to which the quantifier is applied. Thus, if <code>P</code> has type <code>Pred U</code>, then to say that <code>P</code> holds for all objects of type <code>U</code> we would write <code>∀ (x : U), P x</code>. Similarly, <code>∃ (x : U), P x</code> is the proposition asserting that there exists at least one <code>x</code> of type <code>U</code> such that <code>P x</code>.</p>
<p>And there is one more important difference between the way quantified statements are written in <em>HTPI</em> and Lean. In <em>HTPI</em>, a quantifier is interpreted as applying to as little as possible. Thus, <span class="math inline">\(\forall x\, P(x) \wedge Q(x)\)</span> is interpreted as <span class="math inline">\((\forall x\, P(x)) \wedge Q(x)\)</span>; if you want the quantifier <span class="math inline">\(\forall x\)</span> to apply to the entire statement <span class="math inline">\(P(x) \wedge Q(x)\)</span> you must use parentheses and write <span class="math inline">\(\forall x(P(x) \wedge Q(x))\)</span>. The convention in Lean is exactly the opposite: a quantifier applies to as much as possible. Thus, Lean will interpret <code>∀ (x : U), P x ∧ Q x</code> as meaning <code>∀ (x : U), (P x ∧ Q x)</code>. If you want the quantifier to apply to only <code>P x</code>, then you must use parentheses and write <code>(∀ (x : U), P x) ∧ Q x</code>.</p>
<p>With this preparation, we are ready to consider how to write proofs involving quantifiers in Lean. The most common way to prove a goal of the form <code>∀ (x : U), P x</code> is to use the following strategy:</p>
<section id="to-prove-a-goal-of-the-form-x-u-p-x" class="level4">
<h4 class="anchored" data-anchor-id="to-prove-a-goal-of-the-form-x-u-p-x">To prove a goal of the form <code>∀ (x : U), P x</code>:</h4>
<div class="ind">
<p>Let <code>x</code> stand for an arbitrary object of type <code>U</code> and prove <code>P x</code>. If the letter <code>x</code> is already being used in the proof to stand for something, then you must choose an unused variable, say <code>y</code>, to stand for the arbitrary object, and prove <code>P y</code>.</p>
</div>
<p>To do this in Lean, you should use the tactic <code>fix x : U</code>, which tells Lean to treat <code>x</code> as standing for some fixed but arbitrary object of type <code>U</code>. This has the following effect on the tactic state:</p>
<div class="lftrt">
<div class="bef">
<div class="sourceCode" id="cb29"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span> ⋮</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>⊢ ∀ (x : U), P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="aft">
<div class="sourceCode" id="cb30"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span> ⋮</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>⊢ P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>To use a given of the form <code>∀ (x : U), P x</code>, we usually apply a rule of inference called <em>universal instantiation</em>, which is described by the following proof strategy:</p>
</section>
<section id="to-use-a-given-of-the-form-x-u-p-x" class="level4">
<h4 class="anchored" data-anchor-id="to-use-a-given-of-the-form-x-u-p-x">To use a given of the form <code>∀ (x : U), P x</code>:</h4>
<div class="ind">
<p>You may plug in any value of type <code>U</code>, say <code>a</code>, for <code>x</code> and use this given to conclude that <code>P a</code> is true.</p>
</div>
<p>This strategy says that if you have <code>h : ∀ (x : U), P x</code> and <code>a : U</code>, then you can infer <code>P a</code>. Indeed, in this situation Lean will recognize <code>h a</code> as a proof of <code>P a</code>. For example, you can write <code>have h' : P a := h a</code> in a Lean tactic-mode proof, and Lean will add <code>h' : P a</code> to the tactic state.</p>
<p>Let’s try these strategies out in a Lean proof. In Lean, if you don’t want to give a theorem a name, you can simply call it an <code>example</code> rather than a <code>theorem</code>, and then there is no need to give it a name. In the following theorem, you can enter the symbol <code>∀</code> by typing <code>\forall</code> or <code>\all</code>, and you can enter <code>∃</code> by typing <code>\exists</code> or <code>\ex</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb31"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), P x → ¬Q x)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>(h2 : ∀ (x : U), Q x) :</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>¬∃ (x : U), P x := <span class="kw">by</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb32"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x → ¬Q x</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ (x : U), Q x</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>⊢ ¬∃ x, P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>(In the tactic state, why doesn’t Lean show the type of the variable <code>x</code> after the existential quantifier in the goal? I don’t know. Sometimes you can leave out the type of a quantified variable and Lean is able to figure it out on its own. But sometimes Lean is unable to figure out the type if it is not supplied, and you will get an error message if you leave it out. To avoid confusion, we will always include the type of the quantified variable when we enter a quantified statement into Lean, but you will notice that Lean generally leaves out the type when it displays existentially quantified statements in the tactic state.)</p>
<p>To use the givens <code>h1</code> and <code>h2</code>, we will probably want to use universal instantiation. But to do that we would need an object of type <code>U</code> to plug in for <code>x</code> in <code>h1</code> and <code>h2</code>, and there is no object of type <code>U</code> in the tactic state. So at this point, we can’t apply universal instantiation to <code>h1</code> and <code>h2</code>. We should watch for an object of type <code>U</code> to come up in the course of the proof, and consider applying universal instantiation if one does. Until then, we turn our attention to the goal.</p>
<p>The goal is a negative statement, so we begin by reexpressing it as an equivalent positive statement, using a quantifier negation law. The tactic <code>quant_neg</code> applies a quantifier negation law to rewrite the goal. As with the other tactics for applying logical equivalences, you can write <code>quant_neg at h</code> if you want to apply a quantifier negation law to a given <code>h</code>. The effect of the tactic can be summarized as follows:</p>
<div style="margin: 0% 10%">
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"><code>quant_neg</code> Tactic</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>¬∀ (x : U), P x</code></td>
<td style="text-align: center;">is changed to</td>
<td style="text-align: center;"><code>∃ (x : U), ¬P x</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>¬∃ (x : U), P x</code></td>
<td style="text-align: center;">is changed to</td>
<td style="text-align: center;"><code>∀ (x : U), ¬P x</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>∀ (x : U), P x</code></td>
<td style="text-align: center;">is changed to</td>
<td style="text-align: center;"><code>¬∃ (x : U), ¬P x</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>∃ (x : U), P x</code></td>
<td style="text-align: center;">is changed to</td>
<td style="text-align: center;"><code>¬∀ (x : U), ¬P x</code></td>
</tr>
</tbody>
</table>
</div>
<p>Using the <code>quant_neg</code> tactic leads to the following result.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb33"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), P x → ¬Q x)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>(h2 : ∀ (x : U), Q x) :</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>¬∃ (x : U), P x := <span class="kw">by</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">quant_neg</span>     <span class="co">--Goal is now ∀ (x : U), ¬P x</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb34"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x → ¬Q x</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ (x : U), Q x</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>⊢ ∀ (x : U), ¬P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now the goal starts with <code>∀</code>, so we use the strategy above and introduce an arbitrary object of type <code>U</code>. Since the variable <code>x</code> occurs as a bound variable in several statements in this theorem, it might be best to use a different letter for the arbitrary object; this isn’t absolutely necessary, but it may help to avoid confusion. So our next tactic is <code>fix y : U</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb35"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), P x → ¬Q x)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>(h2 : ∀ (x : U), Q x) :</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>¬∃ (x : U), P x := <span class="kw">by</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">quant_neg</span>     <span class="co">--Goal is now ∀ (x : U), ¬P x</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb36"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x → ¬Q x</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ (x : U), Q x</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>⊢ ¬P y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now we have an object of type <code>U</code> in the tactic state, namely, <code>y</code>. So let’s try applying universal instantiation to <code>h1</code> and <code>h2</code> and see if it helps.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb37"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), P x → ¬Q x)</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>(h2 : ∀ (x : U), Q x) :</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>¬∃ (x : U), P x := <span class="kw">by</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">quant_neg</span>     <span class="co">--Goal is now ∀ (x : U), ¬P x</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : P y → ¬Q y := h1 y</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : Q y := h2 y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb38"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x → ¬Q x</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ (x : U), Q x</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: P y → ¬Q y</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: Q y</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>⊢ ¬P y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We’re almost done, because the goal now follows easily from <code>h3</code> and <code>h4</code>. If we use the contrapositive law to rewrite <code>h3</code> as <code>Q y → ¬P y</code>, then we can apply modus ponens to the rewritten <code>h3</code> and <code>h4</code> to reach the goal:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb39"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), P x → ¬Q x)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>(h2 : ∀ (x : U), Q x) :</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>¬∃ (x : U), P x := <span class="kw">by</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">quant_neg</span>     <span class="co">--Goal is now ∀ (x : U), ¬P x</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : P y → ¬Q y := h1 y</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : Q y := h2 y</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">contrapos</span> <span class="kw">at</span> h3  <span class="co">--Now h3 : Q y → ¬P y</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ¬P y <span class="kw">from</span> h3 h4</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb40"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>Goals accomplished 🎉</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Our next example is a theorem of set theory. You already know how to type a few set theory symbols in Lean, but you’ll need a few more for our next example. Here’s a summary of the most important set theory symbols and how to type them in Lean.</p>
<div style="margin: 0% 10%">
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">Symbol</th>
<th style="text-align: center;">How To Type It</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>∈</code></td>
<td style="text-align: center;"><code>\in</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>∉</code></td>
<td style="text-align: center;"><code>\notin</code> or <code>\inn</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>⊆</code></td>
<td style="text-align: center;"><code>\sub</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>⊈</code></td>
<td style="text-align: center;"><code>\subn</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>∪</code></td>
<td style="text-align: center;"><code>\union</code> or <code>\cup</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>∩</code></td>
<td style="text-align: center;"><code>\inter</code> or <code>\cap</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>\</code></td>
<td style="text-align: center;"><code>\\</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>△</code></td>
<td style="text-align: center;"><code>\bigtriangleup</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>𝒫</code></td>
<td style="text-align: center;"><code>\powerset</code></td>
</tr>
</tbody>
</table>
</div>
<p>With this preparation, we can turn to our next example.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb41"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>(h2 : ∀ x : U, x ∈ A → x ∉ B) : A ⊆ C := <span class="kw">by</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb42"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B ∪ C</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ (x : U),</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  x ∈ A → ¬x ∈ B</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>⊢ A ⊆ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We begin by using the <code>define</code> tactic to write out the definition of the goal.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb43"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>(h2 : ∀ x : U, x ∈ A → x ∉ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>  <span class="co">--Goal: ∀ {a : U}, a ∈ A → a ∈ C</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb44"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C</span>: Set U</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B ∪ C</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ (x : U),</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  x ∈ A → ¬x ∈ B</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>⊢ ∀ {a : U},</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  a ∈ A → a ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Notice that Lean’s definition of the goal starts with <code>∀ {a : U}</code>, not <code>∀ (a : U)</code>. Why did Lean use curly braces rather than parentheses? We’ll return to that question shortly. The difference doesn’t affect our next steps, which are to introduce an arbitrary object <code>y</code> of type <code>U</code> and assume <code>y ∈ A</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb45"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>(h2 : ∀ x : U, x ∈ A → x ∉ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>  <span class="co">--Goal: ∀ {a : U}, a ∈ A → a ∈ C</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb46"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B ∪ C</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ (x : U),</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  x ∈ A → ¬x ∈ B</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: y ∈ A</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>⊢ y ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now we can combine <code>h2</code> and <code>h3</code> to conclude that <code>¬y ∈ B</code>. Since we have <code>y : U</code>, by universal instantiation, <code>h2 y</code> is a proof of <code>y ∈ A → ¬y ∈ B</code>, and therefore by modus ponens, <code>h2 y h3</code> is a proof of <code>¬y ∈ B</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb47"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>(h2 : ∀ x : U, x ∈ A → x ∉ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>  <span class="co">--Goal: ∀ {a : U}, a ∈ A → a ∈ C</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ A</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : y ∉ B := h2 y h3</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb48"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B ∪ C</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ (x : U),</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  x ∈ A → ¬x ∈ B</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: y ∈ A</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: ¬y ∈ B</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>⊢ y ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We should be able to use similar reasoning to combine <code>h1</code> and <code>h3</code>, if we first write out the definition of <code>h1</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb49"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>(h2 : ∀ x : U, x ∈ A → x ∉ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>  <span class="co">--Goal: ∀ {a : U}, a ∈ A → a ∈ C</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ A</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : y ∉ B := h2 y h3</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1  <span class="co">--h1 : ∀ {a : U}, a ∈ U → a ∈ B ∪ C</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb50"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ {a : U},</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  a ∈ A → a ∈ B ∪ C</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ (x : U),</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  x ∈ A → ¬x ∈ B</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: y ∈ A</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: ¬y ∈ B</span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>⊢ y ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Once again, Lean has used curly braces to define <code>h1</code>, and now we are ready to explain what they mean. If the definition had been <code>h1 : ∀ (a : U), a ∈ A → a ∈ B ∪ C</code>, then exactly as in the previous step, <code>h1 y h3</code> would be a proof of <code>y ∈ B ∪ C</code>. The use of curly braces in the definition <code>h1 : ∀ {a : U}, a ∈ A → a ∈ B ∪ C</code> means that you don’t need to tell Lean that <code>y</code> is being plugged in for <code>a</code> in the universal instantiation step; Lean will figure that out on its own. Thus, you can just write <code>h1 h3</code> as a proof of <code>y ∈ B ∪ C</code>. Indeed, if you write <code>h1 y h3</code> then you will get an error message, because Lean expects <em>not</em> to be told what to plug in for <code>a</code>. You might think of the definition of <code>h1</code> as meaning <code>h1 : _ ∈ A → _ ∈ B ∪ C</code>, where the blanks can be filled in with anything of type <code>U</code> (with the same thing being put in both blanks). When you ask Lean to apply modus ponens by combining this statement with <code>h3 : y ∈ A</code>, Lean figures out that in order for modus ponens to apply, the blanks must be filled in with <code>y</code>.</p>
<p>In this situation, the <code>a</code> in <code>h1</code> is called an <em>implicit argument</em>. What this means is that, when <code>h1</code> is applied to make an inference in a proof, the value to be assigned to <code>a</code> is not specified explicitly; rather, the value is implicit. We will see many more examples of implicit arguments later in this book.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb51"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>(h2 : ∀ x : U, x ∈ A → x ∉ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>  <span class="co">--Goal: ∀ {a : U}, a ∈ A → a ∈ C</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ A</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : y ∉ B := h2 y h3</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1  <span class="co">--h1 : ∀ {a : U}, a ∈ U → a ∈ B ∪ C</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : y ∈ B ∪ C := h1 h3</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb52"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ {a : U},</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  a ∈ A → a ∈ B ∪ C</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ (x : U),</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  x ∈ A → ¬x ∈ B</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: y ∈ A</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: ¬y ∈ B</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: y ∈ B ∪ C</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>⊢ y ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now we’re almost done, because we can combine <code>h4</code> and <code>h5</code> to reach our goal. To see how, we first write out the definition of <code>h5</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb53"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>(h2 : ∀ x : U, x ∈ A → x ∉ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>  <span class="co">--Goal: ∀ {a : U}, a ∈ A → a ∈ C</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ A</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : y ∉ B := h2 y h3</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1  <span class="co">--h1 : ∀ {a : U}, a ∈ U → a ∈ B ∪ C</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : y ∈ B ∪ C := h1 h3</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h5  <span class="co">--h5 : y ∈ B ∨ y ∈ C</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb54"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ {a : U},</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  a ∈ A → a ∈ B ∪ C</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ (x : U),</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  x ∈ A → ¬x ∈ B</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: y ∈ A</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: ¬y ∈ B</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: y ∈ B ∨ y ∈ C</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>⊢ y ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>A conditional law will convert <code>h5</code> to <code>¬y ∈ B → y ∈ C</code>, and then modus ponens with <code>h4</code> will complete the proof.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb55"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>(h2 : ∀ x : U, x ∈ A → x ∉ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>  <span class="co">--Goal: ∀ {a : U}, a ∈ A → a ∈ C</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ A</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : y ∉ B := h2 y h3</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1  <span class="co">--h1 : ∀ {a : U}, a ∈ U → a ∈ B ∪ C</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : y ∈ B ∪ C := h1 h3</span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h5  <span class="co">--h5 : y ∈ B ∨ y ∈ C</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">conditional</span> <span class="kw">at</span> h5  <span class="co">--h5 : ¬y ∈ B → y ∈ C</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> y ∈ C <span class="kw">from</span> h5 h4</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb56"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>Goals accomplished 🎉</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Next we turn to strategies for working with existential quantifiers.</p>
</section>
<section id="to-prove-a-goal-of-the-form-x-u-p-x-1" class="level4">
<h4 class="anchored" data-anchor-id="to-prove-a-goal-of-the-form-x-u-p-x-1">To prove a goal of the form <code>∃ (x : U), P x</code>:</h4>
<div class="ind">
<p>Find a value of <code>x</code>, say <code>a</code>, for which you think <code>P a</code> is true, and prove <code>P a</code>.</p>
</div>
<p>This strategy is based on the fact that if you have <code>a : U</code> and <code>h : P a</code>, then you can infer <code>∃ (x : U), P x</code>. Indeed, in this situation the expression <code>Exists.intro a h</code> is a Lean term-mode proof of <code>∃ (x : U), P x</code>. The name <code>Exists.intro</code> indicates that this is a rule for introducing an existential quantifier.</p>
<p>As suggested by the strategy above, we will often want to use this rule in situations in which our goal is <code>∃ (x : U), P x</code> and we have an object <code>a</code> of type <code>U</code> that we think makes <code>P a</code> true, but we don’t yet have a proof of <code>P a</code>. In that situation we can use the tactic <code>apply Exists.intro a _</code>. Recall that the <code>apply</code> tactic asks Lean to figure out what to put in the blank to turn <code>Exists.intro a _</code> into a proof of the goal. Lean will figure out that what needs to go in the blank is a proof of <code>P a</code>, so it sets <code>P a</code> to be the goal. In other words, the tactic <code>apply Exists.intro a _</code> has the following effect on the tactic state:</p>
<div class="lftrt">
<div class="bef">
<div class="sourceCode" id="cb57"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span> ⋮</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (x : U), P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="aft">
<div class="sourceCode" id="cb58"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span> ⋮</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>⊢ P a</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Our strategy for using an existential given is a rule that is called <em>existential instantiation</em> in <em>HTPI</em>:</p>
</section>
<section id="to-use-a-given-of-the-form-x-u-p-x-1" class="level4">
<h4 class="anchored" data-anchor-id="to-use-a-given-of-the-form-x-u-p-x-1">To use a given of the form <code>∃ (x : U), P x</code>:</h4>
<div class="ind">
<p>Introduce a new variable, say <code>a</code>, into the proof to stand for an object of type <code>U</code> for which <code>P a</code> is true.</p>
</div>
<p>Suppose that, in a Lean proof, you have <code>h : ∃ (x : U), P x</code>. To apply the existential instantiation rule, you would use the tactic <code>obtain (a : U) (h' : P a) from h</code>. This tactic introduces into the tactic state both a new variable <code>a</code> of type <code>U</code> and also the identifier <code>h'</code> for the new given <code>P a</code>.</p>
<p>Often, if your goal is an existential statement <code>∃ (x : U), P x</code>, you won’t be able to use the strategy above for existential goals right away, because you won’t know what object <code>a</code> to use in the tactic <code>apply Exists.intro a _</code>. You may have to wait until a likely candidate for <code>a</code> pops up in the course of the proof. On the other hand, it is usually best to use the <code>obtain</code> tactic right away if you have an existential given. This is illustrated in our next example.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb59"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>(h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>∃ (x : U), ¬P x := <span class="kw">by</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb60"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), ∃ y,</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  P x → ¬Q y</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ x, ∀ (y : U),</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  P x → Q y</span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>⊢ ∃ x, ¬P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The goal is the existential statement <code>∃ (x : U), ¬P x</code>, and our strategy for existential goals says that we should try to find an object <code>a</code> of type <code>U</code> that we think would make the statement <code>¬P a</code> true. But we don’t have any objects of type <code>U</code> in the tactic state, so it looks like we can’t use that strategy yet. Similarly, we can’t use the given <code>h1</code> yet, since we have nothing to plug in for <code>x</code> in <code>h1</code>. However, <code>h2</code> is an existential given, and we can use it right away.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb61"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>(h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>∃ (x : U), ¬P x := <span class="kw">by</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : U)</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>    (h3 : ∀ (y : U), P a → Q y) <span class="kw">from</span> h2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb62"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), ∃ y,</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  P x → ¬Q y</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ x, ∀ (y : U),</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  P x → Q y</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∀ (y : U), P a → Q y</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>⊢ ∃ x, ¬P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now that we have <code>a : U</code>, we can apply universal instantiation to <code>h1</code>, plugging in <code>a</code> for <code>x</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb63"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>(h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>∃ (x : U), ¬P x := <span class="kw">by</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : U)</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>    (h3 : ∀ (y : U), P a → Q y) <span class="kw">from</span> h2</span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : ∃ (y : U), P a → ¬ Q y := h1 a</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb64"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), ∃ y,</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  P x → ¬Q y</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ x, ∀ (y : U),</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  P x → Q y</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∀ (y : U), P a → Q y</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: ∃ y, P a → ¬Q y</span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>⊢ ∃ x, ¬P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Our new given <code>h4</code> is another existential statement, so again we use it right away to introduce another object of type <code>U</code>. Since this object might not be the same as <code>a</code>, we must give it a different name. (Indeed, if you try to use the name <code>a</code> again, Lean will give you an error message.)</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb65"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>(h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>∃ (x : U), ¬P x := <span class="kw">by</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : U)</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>    (h3 : ∀ (y : U), P a → Q y) <span class="kw">from</span> h2</span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : ∃ (y : U), P a → ¬ Q y := h1 a</span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (b : U) (h5 : P a → ¬ Q b) <span class="kw">from</span> h4</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb66"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), ∃ y,</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  P x → ¬Q y</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ x, ∀ (y : U),</span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  P x → Q y</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∀ (y : U), P a → Q y</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: ∃ y, P a → ¬Q y</span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a><span class="in">b </span>: U</span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: P a → ¬Q b</span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>⊢ ∃ x, ¬P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We have not yet used <code>h3</code>. We could plug in either <code>a</code> or <code>b</code> for <code>y</code> in <code>h3</code>, but a little thought should show you that plugging in <code>b</code> is more useful.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb67"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>(h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>∃ (x : U), ¬P x := <span class="kw">by</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : U)</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>    (h3 : ∀ (y : U), P a → Q y) <span class="kw">from</span> h2</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : ∃ (y : U), P a → ¬ Q y := h1 a</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (b : U) (h5 : P a → ¬ Q b) <span class="kw">from</span> h4</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : P a → Q b := h3 b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb68"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), ∃ y,</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  P x → ¬Q y</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ x, ∀ (y : U),</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  P x → Q y</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∀ (y : U), P a → Q y</span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: ∃ y, P a → ¬Q y</span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a><span class="in">b </span>: U</span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: P a → ¬Q b</span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a><span class="in">h6 </span>: P a → Q b</span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>⊢ ∃ x, ¬P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now look at <code>h5</code> and <code>h6</code>. They show that <code>P a</code> leads to contradictory conclusions, <code>¬Q b</code> and <code>Q b</code>. This means that <code>P a</code> must be false. We finally know what value of <code>x</code> to use to prove the goal.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb69"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>(h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>∃ (x : U), ¬P x := <span class="kw">by</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : U)</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>    (h3 : ∀ (y : U), P a → Q y) <span class="kw">from</span> h2</span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : ∃ (y : U), P a → ¬ Q y := h1 a</span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (b : U) (h5 : P a → ¬ Q b) <span class="kw">from</span> h4</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : P a → Q b := h3 b</span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro a _</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb70"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), ∃ y,</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  P x → ¬Q y</span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ x, ∀ (y : U),</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  P x → Q y</span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∀ (y : U), P a → Q y</span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: ∃ y, P a → ¬Q y</span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a><span class="in">b </span>: U</span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: P a → ¬Q b</span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a><span class="in">h6 </span>: P a → Q b</span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a>⊢ ¬P a</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Since the goal is now a negative statement that cannot be reexpressed as a positive statement, we use proof by contradiction.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb71"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>(h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>∃ (x : U), ¬P x := <span class="kw">by</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : U)</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>    (h3 : ∀ (y : U), P a → Q y) <span class="kw">from</span> h2</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : ∃ (y : U), P a → ¬ Q y := h1 a</span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (b : U) (h5 : P a → ¬ Q b) <span class="kw">from</span> h4</span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : P a → Q b := h3 b</span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro a _</span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h7</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb72"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), ∃ y,</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  P x → ¬Q y</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ x, ∀ (y : U),</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  P x → Q y</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∀ (y : U), P a → Q y</span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: ∃ y, P a → ¬Q y</span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a><span class="in">b </span>: U</span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: P a → ¬Q b</span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a><span class="in">h6 </span>: P a → Q b</span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a><span class="in">h7 </span>: P a</span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>⊢ False</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now <code>h5 h7</code> is a proof of <code>¬Q b</code> and <code>h6 h7</code> is a proof of <code>Q b</code>, so <code>(h5 h7) (h6 h7)</code> is a proof of <code>False</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb73"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>(h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>∃ (x : U), ¬P x := <span class="kw">by</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : U)</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>    (h3 : ∀ (y : U), P a → Q y) <span class="kw">from</span> h2</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : ∃ (y : U), P a → ¬ Q y := h1 a</span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (b : U) (h5 : P a → ¬ Q b) <span class="kw">from</span> h4</span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : P a → Q b := h3 b</span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro a _</span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h7</span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> False <span class="kw">from</span> (h5 h7) (h6 h7)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb74"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>Goals accomplished 🎉</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We conclude this section with the theorem from Example 3.3.5 in <em>HTPI</em>. That theorem concerns a union of a family of sets. In <em>HTPI</em>, such a union is written using a large union symbol, <span class="math inline">\(\bigcup\)</span>. Lean uses the symbol <code>∪₀</code>, which is entered by typing <code>\U0</code> (that is, backslash-capital U-zero). For an intersection of a family of sets, Lean uses <code>∩₀</code>, typed as <code>\I0</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb75"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_3_5 (U : <span class="kw">Type</span>) (B : Set U)</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>(F : Set (Set U)) : ⋃₀F ⊆ B → F ⊆ 𝒫 B := <span class="kw">by</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb76"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a><span class="in">F </span>: Set (Set U)</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>⊢ ⋃₀F ⊆ B → F ⊆ 𝒫 B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Note that <code>F</code> has type <code>Set (Set U)</code>, which means that it is a set whose elements are sets of objects of type <code>U</code>. Since the goal is a conditional statement, we assume the antecedent and set the consequent as our goal. We’ll also write out the definition of the new goal.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb77"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_3_5 (U : <span class="kw">Type</span>) (B : Set U)</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>(F : Set (Set U)) : ⋃₀F ⊆ B → F ⊆ 𝒫 B := <span class="kw">by</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : ∪₀F ⊆ B</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb78"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a><span class="in">F </span>: Set (Set U)</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ⋃₀F ⊆ B</span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>⊢ ∀ {a : Set U},</span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  a ∈ F → a ∈ 𝒫 B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Based on the form of the goal, we introduce an arbitrary object <code>x</code> of type <code>Set U</code> and assume <code>x ∈ F</code>. The new goal will be <code>x ∈ 𝒫 B</code>. The <code>define</code> tactic works out that this means <code>x ⊆ B</code>, which can be further expanded to <code>∀ {a : U}, a ∈ x → a ∈ B</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb79"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_3_5 (U : <span class="kw">Type</span>) (B : Set U)</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>(F : Set (Set U)) : ⋃₀F ⊆ B → F ⊆ 𝒫 B := <span class="kw">by</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : ∪₀F ⊆ B</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : Set U</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : x ∈ F</span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb80"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="in">F </span>: Set (Set U)</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ⋃₀F ⊆ B</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: Set U</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: x ∈ F</span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>⊢ ∀ {a : U},</span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  a ∈ x → a ∈ B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Once again the form of the goal dictates our next steps: introduce an arbitrary <code>y</code> of type <code>U</code> and assume <code>y ∈ x</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb81"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_3_5 (U : <span class="kw">Type</span>) (B : Set U)</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>(F : Set (Set U)) : ⋃₀F ⊆ B → F ⊆ 𝒫 B := <span class="kw">by</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : ∪₀F ⊆ B</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : Set U</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : x ∈ F</span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb82"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a><span class="in">F </span>: Set (Set U)</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ⋃₀F ⊆ B</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: Set U</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: x ∈ F</span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: y ∈ x</span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>⊢ y ∈ B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The goal can be analyzed no further, so we turn to the givens. We haven’t used <code>h1</code> yet. To see how to use it, we write out its definition.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb83"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_3_5 (U : <span class="kw">Type</span>) (B : Set U)</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>(F : Set (Set U)) : ⋃₀F ⊆ B → F ⊆ 𝒫 B := <span class="kw">by</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : ∪₀F ⊆ B</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : Set U</span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : x ∈ F</span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ x</span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb84"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a><span class="in">F </span>: Set (Set U)</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ {a : U},</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  a ∈ ⋃₀F → a ∈ B</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: Set U</span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: x ∈ F</span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: y ∈ x</span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>⊢ y ∈ B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now we see that we can try to use <code>h1</code> to reach our goal. Indeed, <code>h1 _</code> would be a proof of the goal if we could fill in the blank with a proof of <code>y ∈ ∪₀F</code>. So we use the <code>apply h1 _</code> tactic.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb85"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_3_5 (U : <span class="kw">Type</span>) (B : Set U)</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>(F : Set (Set U)) : ⋃₀F ⊆ B → F ⊆ 𝒫 B := <span class="kw">by</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : ∪₀F ⊆ B</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : Set U</span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : x ∈ F</span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ x</span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> h1 _</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb86"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a><span class="in">F </span>: Set (Set U)</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ {a : U},</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  a ∈ ⋃₀F → a ∈ B</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: Set U</span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: x ∈ F</span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: y ∈ x</span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a>⊢ y ∈ ⋃₀F</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Once again we have a goal that can be analyzed by using the <code>define</code> tactic.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb87"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_3_5 (U : <span class="kw">Type</span>) (B : Set U)</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>(F : Set (Set U)) : ⋃₀F ⊆ B → F ⊆ 𝒫 B := <span class="kw">by</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : ∪₀F ⊆ B</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : Set U</span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : x ∈ F</span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ x</span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> h1 _</span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb88"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a><span class="in">F </span>: Set (Set U)</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ {a : U},</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  a ∈ ⋃₀F → a ∈ B</span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: Set U</span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: x ∈ F</span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: y ∈ x</span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>⊢ ∃ a, a ∈ F ∧ y ∈ a</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Our goal is now an existential statement, so we look for a value of <code>a</code> that will make the statement <code>a ∈ F ∧ y ∈ a</code> true. The givens <code>h2</code> and <code>h3</code> tell us that <code>x</code> is such a value, so as described earlier our next tactic should be <code>apply Exists.intro x _</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb89"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_3_5 (U : <span class="kw">Type</span>) (B : Set U)</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>(F : Set (Set U)) : ⋃₀F ⊆ B → F ⊆ 𝒫 B := <span class="kw">by</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : ∪₀F ⊆ B</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : Set U</span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : x ∈ F</span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ x</span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> h1 _</span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro x _</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb90"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a><span class="in">F </span>: Set (Set U)</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ {a : U},</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>  a ∈ ⋃₀F → a ∈ B</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: Set U</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: x ∈ F</span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: y ∈ x</span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ F ∧ y ∈ x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Clearly the goal now follows from <code>h2</code> and <code>h3</code>, but how do we write the proof in Lean? Since we need to introduce the “and” symbol <code>∧</code>, you shouldn’t be surprised to learn that the rule we need is called <code>And.intro</code>. Proof strategies for statements involving “and” will be the subject of the next section.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb91"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_3_5 (U : <span class="kw">Type</span>) (B : Set U)</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>(F : Set (Set U)) : ⋃₀F ⊆ B → F ⊆ 𝒫 B := <span class="kw">by</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : ∪₀F ⊆ B</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : Set U</span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : x ∈ F</span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ x</span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> h1 _</span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro x _</span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> x ∈ F ∧ y ∈ x <span class="kw">from</span> And.intro h2 h3</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb92"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>Goals accomplished 🎉</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>You might want to compare the Lean proof above to the way the proof was written in <em>HTPI</em>. Here are the theorem and proof from <em>HTPI</em>:</p>
<div class="thm">
<p>Suppose <span class="math inline">\(B\)</span> is a set and <span class="math inline">\(\mathcal{F}\)</span> is a family of sets. If <span class="math inline">\(\bigcup\mathcal{F} \subseteq B\)</span> then <span class="math inline">\(\mathcal{F} \subseteq \mathscr{P}(B)\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Suppose <span class="math inline">\(\bigcup \mathcal{F} \subseteq B\)</span>. Let <span class="math inline">\(x\)</span> be an arbitrary element of <span class="math inline">\(\mathcal{F}\)</span>. Let <span class="math inline">\(y\)</span> be an arbitrary element of <span class="math inline">\(x\)</span>. Since <span class="math inline">\(y \in x\)</span> and <span class="math inline">\(x \in \mathcal{F}\)</span>, by the definition of <span class="math inline">\(\bigcup \mathcal{F}\)</span>, <span class="math inline">\(y \in \bigcup \mathcal{F}\)</span>. But then since <span class="math inline">\(\bigcup \mathcal{F} \subseteq B\)</span>, <span class="math inline">\(y \in B\)</span>. Since <span class="math inline">\(y\)</span> was an arbitrary element of <span class="math inline">\(x\)</span>, we can conclude that <span class="math inline">\(x \subseteq B\)</span>, so <span class="math inline">\(x \in \mathscr{P}(B)\)</span>. But <span class="math inline">\(x\)</span> was an arbitrary element of <span class="math inline">\(\mathcal{F}\)</span>, so this shows that <span class="math inline">\(\mathcal{F} \subseteq \mathscr{P}(B)\)</span>, as required.</p>
</div>
</section>
</section>
<section id="proofs-involving-conjunctions-and-biconditionals" class="level2">
<h2 class="anchored" data-anchor-id="proofs-involving-conjunctions-and-biconditionals">3.4. Proofs Involving Conjunctions and Biconditionals</h2>
<p>The strategies in <em>HTPI</em> for working with conjunctions are very simple.</p>
<section id="to-prove-a-goal-of-the-form-p-q-1" class="level4">
<h4 class="anchored" data-anchor-id="to-prove-a-goal-of-the-form-p-q-1">To prove a goal of the form <code>P ∧ Q</code>:</h4>
<div class="ind">
<p>Prove <code>P</code> and <code>Q</code> separately.</p>
</div>
<p>We already saw an example, at the end of the last section, of the use of the rule <code>And.intro</code> to prove a conjunction. In general, if you have <code>h1 : P</code> and <code>h2 : Q</code>, then <code>And.intro h1 h2</code> is a proof of <code>P ∧ Q</code>. It follows that if your goal is <code>P ∧ Q</code> but you don’t yet have proofs of <code>P</code> and <code>Q</code>, then you can use the tactic <code>apply And.intro _ _</code>. Lean will figure out that the blanks need to be filled in with proofs of <code>P</code> and <code>Q</code>, so it will ask you to prove <code>P</code> and <code>Q</code> separately, as suggested by the strategy above.</p>
<p>If you already have a proof of either <code>P</code> or <code>Q</code>, then you can fill in one of the blanks in the <code>apply</code> tactic. For example, if you have <code>h : P</code>, then you can write <code>apply And.intro h _</code>, and Lean will tell you that you just have to prove <code>Q</code> to complete the proof. Similarly, if you have <code>h : Q</code>, then <code>apply And.intro _ h</code> will lead to just the single goal <code>P</code>. There is also a shortcut you can use with the <code>apply</code> tactic: any blanks that come at the end of the tactic can be left out. So instead of <code>apply And.intro _ _</code>, you can just write <code>apply And.intro</code>, and instead of <code>apply And.intro h _</code>, you can write <code>apply And.intro h</code>. On the other hand, <code>apply And.intro _ h</code> can’t be shortened; it is only blanks <em>at the end</em> that can be left out.</p>
<p>The strategy for a given that is a conjunction is similar.</p>
</section>
<section id="to-use-a-given-of-the-form-p-q-1" class="level4">
<h4 class="anchored" data-anchor-id="to-use-a-given-of-the-form-p-q-1">To use a given of the form <code>P ∧ Q</code>:</h4>
<div class="ind">
<p>Treat this as two separate givens: <code>P</code>, and <code>Q</code>.</p>
</div>
<p>If you have a given <code>h : P ∧ Q</code>, then Lean will recognize <code>h.left</code> as a proof of <code>P</code>, and <code>h.right</code> as a proof of <code>Q</code>.</p>
<p>Here’s an example that illustrates these strategies. It is similar to Example 3.4.1 in <em>HTPI</em></p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb93"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_4_1 (U : <span class="kw">Type</span>)</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>(A B C D : Set U) (h1 : A ⊆ B)</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>(h2 : ¬∃ (c : U), c ∈ C ∩ D) : A ∩ C ⊆ B \ D := <span class="kw">by</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb94"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C D </span>: Set U</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ c, c ∈ C ∩ D</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>⊢ A ∩ C ⊆ B \ D</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The <code>define</code> tactic will rewrite the goal as <code>∀ {a : U}, a ∈ A ∩ C → a ∈ B \ D</code>, and then we can introduce an arbitrary <code>x : U</code> and assume <code>x ∈ A ∩ C</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb95"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_4_1 (U : <span class="kw">Type</span>)</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>(A B C D : Set U) (h1 : A ⊆ B)</span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>(h2 : ¬∃ (c : U), c ∈ C ∩ D) : A ∩ C ⊆ B \ D := <span class="kw">by</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : x ∈ A ∩ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb96"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C D </span>: Set U</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B</span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ c, c ∈ C ∩ D</span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: x ∈ A ∩ C</span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ B \ D</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now let’s take a look at the definitions of <code>h3</code> and the goal:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb97"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_4_1 (U : <span class="kw">Type</span>)</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>(A B C D : Set U) (h1 : A ⊆ B)</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>(h2 : ¬∃ (c : U), c ∈ C ∩ D) : A ∩ C ⊆ B \ D := <span class="kw">by</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : x ∈ A ∩ C</span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h3; <span class="kw">define</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb98"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C D </span>: Set U</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B</span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ c, c ∈ C ∩ D</span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: x ∈ A ∧ x ∈ C</span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ B ∧ ¬x ∈ D</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Since the goal is now a conjuction, we use the strategy above by using the tactic <code>apply And.intro</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb99"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_4_1 (U : <span class="kw">Type</span>)</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>(A B C D : Set U) (h1 : A ⊆ B)</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>(h2 : ¬∃ (c : U), c ∈ C ∩ D) : A ∩ C ⊆ B \ D := <span class="kw">by</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : x ∈ A ∩ C</span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h3; <span class="kw">define</span></span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb100"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> left</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a><span class="in">A B C D </span>: Set U</span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B</span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ c, c ∈ C ∩ D</span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: x ∈ A ∧ x ∈ C</span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ B</span>
<span id="cb100-9"><a href="#cb100-9" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> right</span>
<span id="cb100-10"><a href="#cb100-10" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb100-11"><a href="#cb100-11" aria-hidden="true" tabindex="-1"></a><span class="in">A B C D </span>: Set U</span>
<span id="cb100-12"><a href="#cb100-12" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B</span>
<span id="cb100-13"><a href="#cb100-13" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ c, c ∈ C ∩ D</span>
<span id="cb100-14"><a href="#cb100-14" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb100-15"><a href="#cb100-15" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: x ∈ A ∧ x ∈ C</span>
<span id="cb100-16"><a href="#cb100-16" aria-hidden="true" tabindex="-1"></a>⊢ ¬x ∈ D</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Look carefully at the tactic state. Lean has listed <em>two</em> goals, one after the other, and it has helpfully labeled them “case left” and “case right,” indicating that the first goal is proving the left side of the conjunction and the second is proving the right. The given information in both cases is the same, but in the first case the goal is <code>x ∈ B</code>, and in the second it is <code>¬x ∈ D</code>. As we continue with the proof, Lean will interpret our tactics as applying to the first goal, until we achieve that goal. Once we achieve it, Lean will move on to the second goal. To make the proof more readable, we will add comments indicating which steps give the proof of the first goal and which prove the second.</p>
<p>The first goal is easy: We have <code>h1 : A ⊆ B</code> and, as explained above, <code>h3.left : x ∈ A</code>. As we have seen in several previous examples, the tactic <code>define at h1</code> will rewrite <code>h1</code> as <code>∀ {a : U}, a ∈ A → a ∈ B</code>, and then <code>h1 h3.left</code> will be a proof of <code>x ∈ B</code>. And now we’ll let you in on a little secret: the <code>define</code> tactic isn’t really necessary. <em>You</em> may find the <code>define</code> tactic to be useful in many situations, because it helps you see what a statement means. But <em>Lean</em> doesn’t need to be told to work out what the statement means; it will do that automatically. So we can skip the define tactic and just give <code>h1 h3.left</code> as a proof of <code>x ∈ B</code>. In general, if you have <code>h1 : A ⊆ B</code> and <code>h2 : x ∈ A</code>, then Lean will recognize <code>h1 h2</code> as a proof of <code>x ∈ B</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb101"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_4_1 (U : <span class="kw">Type</span>)</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>(A B C D : Set U) (h1 : A ⊆ B)</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>(h2 : ¬∃ (c : U), c ∈ C ∩ D) : A ∩ C ⊆ B \ D := <span class="kw">by</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : x ∈ A ∩ C</span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h3; <span class="kw">define</span></span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Proof that x ∈ B:</span></span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> x ∈ B <span class="kw">from</span> h1 h3.left</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb102"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> right</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a><span class="in">A B C D </span>: Set U</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B</span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ c, c ∈ C ∩ D</span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: x ∈ A ∧ x ∈ C</span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a>⊢ ¬x ∈ D</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Note that Lean has recognized that the first goal has been achieved, so it has moved on to the second goal. This goal is a negative statement, and the given <code>h2</code> is also a negative statement. This suggests using proof by contradiction, and achieving the contradiction by contradicting <code>h2</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb103"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_4_1 (U : <span class="kw">Type</span>)</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>(A B C D : Set U) (h1 : A ⊆ B)</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>(h2 : ¬∃ (c : U), c ∈ C ∩ D) : A ∩ C ⊆ B \ D := <span class="kw">by</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : x ∈ A ∩ C</span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h3; <span class="kw">define</span></span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Proof that x ∈ B:</span></span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> x ∈ B <span class="kw">from</span> h1 h3.left</span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Proof that ¬x ∈ C:</span></span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">contradict</span> h2 <span class="kw">with</span> h4</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb104"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> right</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a><span class="in">A B C D </span>: Set U</span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B</span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ c, c ∈ C ∩ D</span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: x ∈ A ∧ x ∈ C</span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: x ∈ D</span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true" tabindex="-1"></a>⊢ ∃ c, c ∈ C ∩ D</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The goal is now an existential statement, and looking at <code>h3</code> and <code>h4</code> it is clear that the right value to plug in for <code>c</code> in the goal is <code>x</code>. The tactic <code>apply Exists.intro x</code> will change the goal to <code>x ∈ C ∩ D</code> (we have again left off the unnecessary blank at the end of the <code>apply</code> tactic).</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb105"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_4_1 (U : <span class="kw">Type</span>)</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>(A B C D : Set U) (h1 : A ⊆ B)</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>(h2 : ¬∃ (c : U), c ∈ C ∩ D) : A ∩ C ⊆ B \ D := <span class="kw">by</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : x ∈ A ∩ C</span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h3; <span class="kw">define</span></span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Proof that x ∈ B:</span></span>
<span id="cb105-10"><a href="#cb105-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> x ∈ B <span class="kw">from</span> h1 h3.left</span>
<span id="cb105-11"><a href="#cb105-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Proof that ¬x ∈ C:</span></span>
<span id="cb105-12"><a href="#cb105-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">contradict</span> h2 <span class="kw">with</span> h4</span>
<span id="cb105-13"><a href="#cb105-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb106"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> right</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a><span class="in">A B C D </span>: Set U</span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B</span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ c, c ∈ C ∩ D</span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: x ∈ A ∧ x ∈ C</span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: x ∈ D</span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ C ∩ D</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The <code>define</code> tactic would now rewrite the goal as <code>x ∈ C ∧ x ∈ D</code>, and we could prove this goal by combining <code>h3.right</code> and <code>h4</code>, using the <code>And.intro</code> rule. But since we know what the result of the <code>define</code> tactic will be, there is really no need to use it. We can just use <code>And.intro</code> right away to complete the proof.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb107"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_4_1 (U : <span class="kw">Type</span>)</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>(A B C D : Set U) (h1 : A ⊆ B)</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>(h2 : ¬∃ (c : U), c ∈ C ∩ D) : A ∩ C ⊆ B \ D := <span class="kw">by</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : x ∈ A ∩ C</span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h3; <span class="kw">define</span></span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Proof that x ∈ B:</span></span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> x ∈ B <span class="kw">from</span> h1 h3.left</span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Proof that ¬x ∈ C:</span></span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">contradict</span> h2 <span class="kw">with</span> h4</span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro x</span>
<span id="cb107-14"><a href="#cb107-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> x ∈ C ∩ D <span class="kw">from</span> And.intro h3.right h4</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb108"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!!</span>Goals accomplished 🎉</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Since <code>P ↔︎ Q</code> is shorthand for <code>(P → Q) ∧ (Q → P)</code>, the strategies given above for conjunctions lead immediately to the following strategies for biconditionals:</p>
</section>
<section id="to-prove-a-goal-of-the-form-p-q-2" class="level4">
<h4 class="anchored" data-anchor-id="to-prove-a-goal-of-the-form-p-q-2">To prove a goal of the form <code>P ↔︎ Q</code>:</h4>
<div class="ind">
<p>Prove <code>P → Q</code> and <code>Q → P</code> separately.</p>
</div>
</section>
<section id="to-use-a-given-of-the-form-p-q-2" class="level4">
<h4 class="anchored" data-anchor-id="to-use-a-given-of-the-form-p-q-2">To use a given of the form <code>P ↔︎ Q</code>:</h4>
<div class="ind">
<p>Treat this as two separate givens: <code>P → Q</code>, and <code>Q → P</code>.</p>
</div>
<p>The methods for using these strategies in Lean are similar to those we used above for conjunctions. If we have <code>h1 : P → Q</code> and <code>h2 : Q → P</code>, then <code>Iff.intro h1 h2</code> is a proof of <code>P ↔︎ Q</code>. Thus, if the goal is <code>P ↔︎ Q</code>, then the tactic <code>apply Iff.intro _ _</code> will convert this into two separate goals, <code>P → Q</code> and <code>Q → P</code>. Once again, you can fill in one of these blanks if you already have a proof of either <code>P → Q</code> or <code>Q → P</code>, and you can leave out any blanks at the end of the tactic. If you have a given <code>h : P ↔︎ Q</code>, then <code>h.ltr</code> is a proof of the left-to-right direction of the biconditional, <code>P → Q</code>, and <code>h.rtl</code> is a proof of the right-to-left direction, <code>Q → P</code>.</p>
<p>Let’s try these strategies out in an example.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb109"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), P x ↔ Q x) :</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>(∃ (x : U), P x) ↔ ∃ (x : U), Q x := <span class="kw">by</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb110"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x ↔ Q x</span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>⊢ (∃ x, P x) ↔ ∃ x, Q x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The goal is a biconditional statement, so we begin with the tactic <code>apply Iff.intro</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb111"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), P x ↔ Q x) :</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>(∃ (x : U), P x) ↔ ∃ (x : U), Q x := <span class="kw">by</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb112"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mp</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x ↔ Q x</span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a>⊢ (∃ x, P x) → ∃ x, Q x</span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mpr</span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x ↔ Q x</span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a>⊢ (∃ x, Q x) → ∃ x, P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Once again, we have two goals. (The case labels this time aren’t very intuitive; “mp” stands for “modus ponens” and “mpr” stands for “modus ponens reverse”.) As in <em>HTPI</em>, we’ll label the proofs of the two goals with <code>(→)</code> and <code>(←)</code>, representing the two directions of the biconditional symbol <code>↔︎</code>. (You can type <code>←</code> in VS Code by typing <code>\l</code>, short for “left”.) The first goal is a conditional statement, so we assume the antecedent. In the displays below, we’ll just show the tactic state for the first goal, since that’s all that’s relevant for figuring out our next steps.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb113"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), P x ↔ Q x) :</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>(∃ (x : U), P x) ↔ ∃ (x : U), Q x := <span class="kw">by</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (→)</span></span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ∃ (x : U), P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb114"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mp</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x ↔ Q x</span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ x, P x</span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>⊢ ∃ x, Q x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>As usual, when we have an existential given, we use it right away.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb115"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), P x ↔ Q x) :</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>(∃ (x : U), P x) ↔ ∃ (x : U), Q x := <span class="kw">by</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (→)</span></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ∃ (x : U), P x</span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (u : U) (h3 : P u) <span class="kw">from</span> h2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb116"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mp</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x ↔ Q x</span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ x, P x</span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a><span class="in">u </span>: U</span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: P u</span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a>⊢ ∃ x, Q x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now that we have an object of type <code>U</code> in the tactic state, we can use <code>h1</code> by applying universal instantiation.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb117"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), P x ↔ Q x) :</span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>(∃ (x : U), P x) ↔ ∃ (x : U), Q x := <span class="kw">by</span></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (→)</span></span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ∃ (x : U), P x</span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (u : U) (h3 : P u) <span class="kw">from</span> h2</span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : P u ↔ Q u := h1 u</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb118"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mp</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x ↔ Q x</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ x, P x</span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a><span class="in">u </span>: U</span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: P u</span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: P u ↔ Q u</span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>⊢ ∃ x, Q x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Looking at <code>h3</code> and <code>h4</code>, we can now see that we will be able to complete the proof if we assign the value <code>u</code> to <code>x</code> in the goal. So our next step is the tactic <code>apply Exists.intro u</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb119"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), P x ↔ Q x) :</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>(∃ (x : U), P x) ↔ ∃ (x : U), Q x := <span class="kw">by</span></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (→)</span></span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ∃ (x : U), P x</span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (u : U) (h3 : P u) <span class="kw">from</span> h2</span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : P u ↔ Q u := h1 u</span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro u</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb120"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mp</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x ↔ Q x</span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ x, P x</span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a><span class="in">u </span>: U</span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: P u</span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: P u ↔ Q u</span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a>⊢ Q u</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>To complete the proof, we use the left-to-right direction of <code>h4</code>. We have <code>h4.ltr : P u → Q u</code> and <code>h3 : P u</code>, so by modus ponens, <code>h4.ltr h3</code> proves the goal <code>Q u</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb121"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), P x ↔ Q x) :</span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>(∃ (x : U), P x) ↔ ∃ (x : U), Q x := <span class="kw">by</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (→)</span></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ∃ (x : U), P x</span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (u : U) (h3 : P u) <span class="kw">from</span> h2</span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : P u ↔ Q u := h1 u</span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro u</span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> Q u <span class="kw">from</span> h4.ltr h3</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb122"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mpr</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x ↔ Q x</span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>⊢ (∃ x, Q x) → ∃ x, P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>This completes the <code>(→)</code> half of the proof; the tactic state now lists only the goal for the <code>(←)</code> half. The second half of the proof is similar to the first. We begin by assuming <code>h2 : ∃ (x : U), Q x</code>, and then we use that assumption to obtain <code>u : U</code> and <code>h3 : Q u</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb123"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), P x ↔ Q x) :</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>(∃ (x : U), P x) ↔ ∃ (x : U), Q x := <span class="kw">by</span></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (→)</span></span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ∃ (x : U), P x</span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (u : U) (h3 : P u) <span class="kw">from</span> h2</span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : P u ↔ Q u := h1 u</span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro u</span>
<span id="cb123-10"><a href="#cb123-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> Q u <span class="kw">from</span> h4.ltr h3</span>
<span id="cb123-11"><a href="#cb123-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (←)</span></span>
<span id="cb123-12"><a href="#cb123-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ∃ (x : U), Q x</span>
<span id="cb123-13"><a href="#cb123-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (u : U) (h3 : Q u) <span class="kw">from</span> h2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb124"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mpr</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x ↔ Q x</span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ x, Q x</span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a><span class="in">u </span>: U</span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: Q u</span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a>⊢ ∃ x, P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We can actually shorten the proof by packing a lot into a single step. See if you can figure out the last line of the completed proof below; we’ll give an explanation after the proof.</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>(h1 : ∀ (x : U), P x ↔ Q x) :</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>(∃ (x : U), P x) ↔ ∃ (x : U), Q x := <span class="kw">by</span></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (→)</span></span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ∃ (x : U), P x</span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (u : U) (h3 : P u) <span class="kw">from</span> h2</span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : P u ↔ Q u := h1 u</span>
<span id="cb125-9"><a href="#cb125-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro u</span>
<span id="cb125-10"><a href="#cb125-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> Q u <span class="kw">from</span> h4.ltr h3</span>
<span id="cb125-11"><a href="#cb125-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (←)</span></span>
<span id="cb125-12"><a href="#cb125-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ∃ (x : U), Q x</span>
<span id="cb125-13"><a href="#cb125-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (u : U) (h3 : Q u) <span class="kw">from</span> h2</span>
<span id="cb125-14"><a href="#cb125-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ∃ (x : U), P x <span class="kw">from</span> Exists.intro u ((h1 u).rtl h3)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To understand the last step, start with the fact that <code>h1 u</code> is a proof of <code>P u ↔︎ Q u</code>. Therefore <code>(h1 u).rtl</code> is a proof of <code>Q u → P u</code>, so by modus ponens, <code>(h1 u).rtl h3</code> is a proof of <code>P u</code>. It follows that <code>Exists.intro u ((h1 u).rtl h3)</code> is a proof of <code>∃ (x : U), P x</code>, which was the goal.</p>
<p>There is one more style of reasoning that is sometimes used in proofs of biconditional statements. It is illustrated in Example 3.4.5 of <em>HTPI</em>. Here is that theorem, as it is presented in <em>HTPI</em>.</p>
<div class="nthm" data-arguments="Theorem (Example 3.4.5)">
<p>Suppose <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, and <span class="math inline">\(C\)</span> are sets. Then <span class="math inline">\(A \cap (B \setmin C) = (A \cap B) \setmin C\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Let <span class="math inline">\(x\)</span> be arbitrary. Then <span class="math display">\[\begin{align*}
x \in A \cap (B \setmin C) &amp;\text{ iff } x \in A \wedge x \in B \setmin C\\
&amp;\text{ iff } x \in A \wedge x \in B \wedge x \notin C\\
&amp;\text{ iff } x \in (A \cap B) \wedge x \notin C\\
&amp;\text{ iff } x \in (A \cap B) \setmin C.
\end{align*}\]</span> Thus, <span class="math inline">\(\forall x(x \in A \cap (B \setmin C) \leftrightarrow x \in (A \cap B) \setmin C)\)</span>, so <span class="math inline">\(A \cap (B \setmin C) = (A \cap B) \setmin C\)</span>.</p>
</div>
<p>This proof is based on a fundamental principle of set theory that says that if two sets have exactly the same elements, then they are equal. This principle is called the <em>axiom of extensionality</em>, and it is what justifies the inference, in the last sentence, from <span class="math inline">\(\forall x(x \in A \cap (B \setmin C) \leftrightarrow x \in (A \cap B) \setmin C)\)</span> to <span class="math inline">\(A \cap (B \setmin C) = (A \cap B) \setmin C\)</span>.</p>
<p>The heart of the proof is a string of equivalences that establish the biconditional statement <span class="math inline">\(x \in A \cap (B \setmin C) \leftrightarrow x \in (A \cap B) \setmin C\)</span>. That style of proving a biconditional can also be done in Lean. This time we’ll simply present the complete proof first, and then explain it afterwards.</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_4_5 (U : <span class="kw">Type</span>)</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>(A B C : Set U) : A ∩ (B \ C) = (A ∩ B) \ C := <span class="kw">by</span></span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> x ∈ A ∩ (B \ C) ↔ x ∈ (A ∩ B) \ C <span class="kw">from</span></span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span></span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a>      x ∈ A ∩ (B \ C) ↔ x ∈ A ∧ (x ∈ B ∧ x ∉ C) := Iff.refl _</span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a>                    _ ↔ (x ∈ A ∧ x ∈ B) ∧ x ∉ C := And.assoc.symm</span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a>                    _ ↔ x ∈ (A ∩ B) \ C := Iff.refl _</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The name of the axiom of extensionality in Lean is <code>Set.ext</code>, and it is applied in the first step of the Lean proof. As usual, the <code>apply</code> tactic works backwards from the goal. In other words, after the first line of the proof, the goal is <code>∀ (x : U), x ∈ A ∩ (B \ C) ↔︎ x ∈ (A ∩ B) \ C</code>, because by <code>Set.ext</code>, the conclusion of the theorem would follow from this statement. The rest of the proof then proves this goal by introducing an arbitrary <code>x</code> of type <code>U</code> and then proving the biconditional by stringing together several equivalences, exactly as in the <em>HTPI</em> proof.</p>
<p>The proof of the biconditional is called a <em>calculational proof</em>, and it is introduced by the keyword <code>calc</code>. The calculational proof consists of a list of biconditional statements, each of which is provided with a proof. You can think of the underscore on the left-hand side of each biconditional after the first as standing for the right-hand side of the previous biconditional.</p>
<p>The proofs of the individual equivalences in the calculational proof require some explanation.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./IntroLean.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Introduction to Lean</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->



</body></html>