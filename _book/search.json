[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "How To Prove It With Lean",
    "section": "",
    "text": "This book is intended to accompany my book How To Prove It (henceforth called HTPI), which is published by Cambridge University Press. Although this book is self-contained, we will sometimes have occasion to refer to passages in HTPI, so this book will be easiest to understand if you have a copy of HTPI available to you.\nHTPI explains a systematic approach to constructing mathematical proofs. The purpose of this book is to show you how to use a computer software package called Lean to help you master the techniques presented in HTPI. Lean is free software that is available for Windows, MacOS, and Unix computers. To get the most out of this book, you will need to download and install Lean on your computer. We will explain how to do that below.\nThe chapters and sections of this book are numbered to match the sections of HTPI to which they correspond. The first two chapters of HTPI cover preliminary topics in elementary logic and set theory that are needed to understand the proof techniques presented in later chapters. We assume that you are already familiar with that material (if not, go read those chapters in HTPI !), so Chapters 1 and 2 of this book will just briefly summarize the most important points. Those chapters are followed by an introduction to Lean that explains the basics of using Lean to write proofs. The presentation of proof techniques in HTPI begins in earnest in Chapter 3, so that is where we will begin to discuss how Lean can be used to master those techniques.\nIf you are reading this book online, then you will find a search box in the left margin. You can use that box to search for any word or phrase anywhere in the book. Below the search box is a list of the chapters of the book. Click on any chapter to go to that chapter. Within each chapter, a table of contents in the right margin lists the sections in that chapter. Again, you can go to any section by clicking on it. At the end of each chapter there are links to take you to the next or previous chapter.\n\n\n\nLean is a kind of software package called a proof assistant. What that means is that Lean can help you to write proofs. As we will see over the course of this book, there are several ways in which Lean can be helpful. First of all, if you type a proof into Lean, then Lean can check the correctness of the proof and point out errors. As you are typing a proof into Lean, it will keep track of what has been accomplished so far in the proof and what remains to be done to finish the proof, and it will display that information for you. That can keep you moving in the right direction as you are figuring out a proof. And sometimes Lean can fill in small details of the proof for you.\nOf course, to make this possible you must type your proof in a format that Lean understands. Much of this book will be taken up with explaining how to write a proof so that Lean will understand it.\n\n\n\nWe will be using Visual Studio Code to run Lean, so you will need to install VS Code first. VS Code is free and can be downloaded here.\nYou will also need the Lean package that accompanies this book, which can be downloaded from https://github.com/djvelleman/HTPILeanPackage. After following the link, click on the green “Code” button and, in the pop-up menu, select “Download ZIP”. Open the downloaded zip file to create a folder containing the HTPI Lean package. You can put this folder wherever you want on your computer.\nNow open VS Code. You should see a window that looks something like this:\n\nClick on the Extensions icon on the left side of the window, which is circled in red in the image above. That will bring up a list of available extensions:\n\nIn the Search Extensions in Marketplace field, type “lean4”. VS Code should find the Lean 4 extension and display it:\n\nClick on “Install” to install the Lean 4 extension.\nNext, in VS Code, select “Open Folder …” from the File menu and open the folder containing the HTPI Lean package that you downloaded earlier. Under the heading “Explorer” on the left side of the window, you should see a list of the files in the package. (If you don’t see the list, try clicking on the Explorer icon, circled in red below.)\n\nClick on the file “Blank.lean” in the file list. You should see a warning that VS Code failed to start the ‘lean’ language server:\n\n\n\n\n\nClick on the “Install Lean using Elan” button, and the Lean server should be installed. This may take a while, and there may be messages asking you to do things. If anything goes wrong, try quiting VS Code and restarting. Eventually your window should look like this:\n\nIf you don’t see the Infoview pane on the right side of the window, click on the icon circled in red in the image above, and the Infoview pane should appear.\nYour installation is now complete."
  },
  {
    "objectID": "Chap1.html",
    "href": "Chap1.html",
    "title": "1  Sentential Logic",
    "section": "",
    "text": "Symbol\nMeaning\n\n\n\n\n\\(\\neg\\)\nnot\n\n\n\\(\\wedge\\)\nand\n\n\n\\(\\vee\\)\nor\n\n\n\\(\\to\\)\nif … then\n\n\n\\(\\leftrightarrow\\)\nif and only if\n\n\n\n\nAs we will see, Lean uses the same symbols, with the same meanings. This chapter also establishes a number of logical equivalences that will be useful to us later:\n\n\n\n\n\n\n\n\n\n\nName\n\nEquivalence\n\n\n\n\n\nDe Morgan’s Laws\n\\(\\neg (P \\wedge Q)\\)\nis equivalent to\n\\(\\neg P \\vee \\neg Q\\)\n\n\n\n\\(\\neg (P \\vee Q)\\)\nis equivalent to\n\\(\\neg P \\wedge \\neg Q\\)\n\n\nDouble Negation Law\n\\(\\neg\\neg P\\)\nis equivalent to\n\\(P\\)\n\n\nConditional Laws\n\\(P \\to Q\\)\nis equivalent to\n\\(\\neg P \\vee Q\\)\n\n\n\n\\(P \\to Q\\)\nis equivalent to\n\\(\\neg(P \\wedge \\neg Q)\\)\n\n\nContrapositive Law\n\\(P \\to Q\\)\nis equivalent to\n\\(\\neg Q \\to \\neg P\\)\n\n\n\n\nFinally, Chapter 1 of HTPI introduces some concepts from set theory. A set is a collection of objects; the objects in the collection are called elements of the set. If \\(P(x)\\) is a statement about \\(x\\), then \\(\\{x \\mid P(x)\\}\\) denotes the set whose elements are the objects \\(x\\) for which \\(P(x)\\) is true. The notation \\(x \\in A\\) means that \\(x\\) is an element of \\(A\\). Two sets \\(A\\) and \\(B\\) are equal if they have exactly the same elements. We say that \\(A\\) is a subset of \\(B\\), denoted \\(A \\subseteq B\\), if every element of \\(A\\) is an element of \\(B\\). And we have the following operations on sets:\n\n\\(A \\cap B = \\{x \\mid x \\in A \\wedge x \\in B\\} = {}\\) the intersection of \\(A\\) and \\(B\\),\n\\(A \\cup B = \\{x \\mid x \\in A \\vee x \\in B\\} = {}\\) the union of \\(A\\) and \\(B\\),\n\\(A \\mathbin{\\backslash} B = \\{x \\mid x \\in A \\wedge x \\notin B\\} = {}\\) the difference of \\(A\\) and \\(B\\),\n\\(A \\bigtriangleup B = (A \\mathbin{\\backslash} B) \\cup (B \\mathbin{\\backslash} A) = {}\\) the symmetric difference of \\(A\\) and \\(B\\)."
  },
  {
    "objectID": "Chap2.html",
    "href": "Chap2.html",
    "title": "2  Quantificational Logic",
    "section": "",
    "text": "\\(\\forall x\\,P(x)\\) means “for all \\(x\\), \\(P(x)\\),”\n\nand\n\n\\(\\exists x\\,P(x)\\) means “there exists some \\(x\\) such that \\(P(x)\\).”\n\nLean also uses these symbols, although we will see that quantified statements are written slightly differently in Lean from the way they are written in HTPI. In the statement \\(P(x)\\), the variable \\(x\\) is called a free variable. But in \\(\\forall x\\,P(x)\\) or \\(\\exists x\\,P(x)\\), it is a bound variable; we say that the quantifiers \\(\\forall\\) and \\(\\exists\\) bind the variable.\nOnce again, there are logical equivalences involving these symbols that will be useful to us later:\n\n\n\n\n\n\n\n\n\nName\n\nEquivalence\n\n\n\n\n\nQuantifier Negation Laws\n\\(\\neg \\exists x\\,P(x)\\)\nis equivalent to\n\\(\\forall x\\,\\neg P(x)\\)\n\n\n\n\\(\\neg \\forall x\\,P(x)\\)\nis equivalent to\n\\(\\exists x\\,\\neg P(x)\\)\n\n\n\nChapter 2 of HTPI also introduces some more advanced set theory operations. For any set \\(A\\),\n\n\\(\\mathscr{P}(A) = \\{X \\mid X \\subseteq A\\} = {}\\) the power set of \\(A\\).\n\nAlso, if \\(\\mathcal{F}\\) is a family of sets—that is, a set whose elements are sets—then\n\n\\(\\bigcap \\mathcal{F} = \\{x \\mid \\forall A(A \\in \\mathcal{F} \\to x \\in A)\\} = {}\\) the intersection of the family \\(\\mathcal{F}\\),\n\\(\\bigcup \\mathcal{F} = \\{x \\mid \\exists A(A \\in \\mathcal{F} \\wedge x \\in A)\\} = {}\\) the union of the family \\(\\mathcal{F}\\).\n\nFinally, Chapter 2 introduces the notation \\(\\exists ! x\\,P(x)\\) to mean “there is exactly one \\(x\\) such that \\(P(x).\\)” This can be thought of as an abbreviation for \\(\\exists x(P(x) \\wedge \\neg\\exists y(P(y) \\wedge y \\ne x))\\). By the quantifier negation, De Morgan, and conditional laws, this is equivalent to \\(\\exists x(P(x) \\wedge \\forall y(P(y) \\to y = x))\\)."
  },
  {
    "objectID": "IntroLean.html",
    "href": "IntroLean.html",
    "title": "Introduction to Lean",
    "section": "",
    "text": "If you are reading this book in conjunction with How To Prove It, you should complete Section 3.2 of HTPI before reading this chapter. Once you have reached that point in HTPI, you are ready to start learning about Lean. In this chapter we’ll explain the basics of writing proofs in Lean and getting feedback from Lean."
  },
  {
    "objectID": "IntroLean.html#a-first-example",
    "href": "IntroLean.html#a-first-example",
    "title": "Introduction to Lean",
    "section": "A First Example",
    "text": "A First Example\nWe’ll start with Example 3.2.4 in How To Prove It. Here is how the theorem and proof in that example appear in HTPI (consult HTPI if you want to see how this proof was constructed):\n\nSuppose \\(P \\to (Q \\to R)\\). Then \\(\\neg R \\to (P \\to \\neg Q)\\).\n\n\nProof. Suppose \\(\\neg R\\). Suppose \\(P\\). Since \\(P\\) and \\(P \\to (Q \\to R)\\), it follows that \\(Q \\to R\\). But then, since \\(\\neg R\\), we can conclude \\(\\neg Q\\). Thus, \\(P \\to \\neg Q\\). Therefore \\(\\neg R \\to (P \\to \\neg Q)\\).\n\nAnd here is how we would write the proof in Lean:\ntheorem Example_3_2_4\n(P Q R : Prop) (h : P → (Q → R)) : ¬R → (P → ¬Q) := by\n  assume h2 : ¬R\n  assume h3 : P\n  have h4 : Q → R := h h3\n  contrapos at h4            --Now h4 : ¬R → ¬Q\n  show ¬Q from h4 h2\nLet’s go through this Lean proof line-by-line and see what it means. The first line tells Lean that we are going to prove a theorem, and it gives the theorem a name, Example_3_2_4. The next line states the theorem. In the theorem as stated in HTPI, the letters \\(P\\), \\(Q\\), and \\(R\\) are used to stand for statements that are either true or false. In logic, such statements are often called propositions. The expression (P Q R : Prop) on the second line tells Lean that P, Q, and R will be used in this theorem to stand for propositions. The next parenthetical expression, (h : P → (Q → R)), states the hypothesis of the theorem and gives it the name h; the technical term that Lean uses is that h is an identifier for the hypothesis. Assigning an identifier to the hypothesis gives us a way to refer to it when it is used later in the proof. Almost any string of characters that doesn’t begin with a digit can be used as an identifier, but it is traditional to use identifiers beginning with the letter h for hypotheses. After the statement of the hypothesis there is a colon followed by the conclusion of the theorem, ¬R → (P → ¬Q). Finally, at the end of the second line, the expression := by signals the beginning of the proof.\nEach of the remaining lines is a step in the proof. The first line of the proof introduces the assumption ¬R and gives it the identifier h2. Of course, this corresponds precisely to the first sentence of the proof in HTPI. Similarly, the second line, corresponding to the second sentence of the HTPI proof, assigns the identifier h3 to the assumption P. The next line makes the inference Q → R, giving it the identifier h4. The inference is justified by combining statements h and h3—that is, the statements P → (Q → R) and P—exactly as in the third sentence of the proof in HTPI.\nThe next step of the proof in HTPI combines the statements \\(Q \\to R\\) and \\(\\neg R\\) to draw the inference \\(\\neg Q\\). This reasoning is justified by the contrapositive law, which says that \\(Q \\to R\\) is equivalent to its contrapositive, \\(\\neg R \\to \\neg Q\\). In the Lean proof, this inference is broken up into two steps. In the fourth line of the proof, we ask Lean to rewrite statement h4—that is, Q → R—using the contrapositive law. Two hyphens in a row tell Lean that the rest of the line is a comment. Lean ignores comments and displays them in green. The comment on line four serves as a reminder that h4 now stands for the statement ¬R → ¬Q. Finally, in the last line of the proof, we combine the new h4 with h2 to infer ¬Q. There is no need to give this statement an identifier, because it completes the proof. In the proof in HTPI, there are a couple of final sentences explaining why this completes the proof, but Lean doesn’t require this explanation."
  },
  {
    "objectID": "IntroLean.html#term-mode",
    "href": "IntroLean.html#term-mode",
    "title": "Introduction to Lean",
    "section": "Term Mode",
    "text": "Term Mode\nNow that you have seen an example of a proof in Lean, it is time for you to write your first proof. Lean has two modes for writing proofs, called term mode and tactic mode. The example above was written in tactic mode, and that is the mode we will use for most proofs in this book. But before we study the construction of proofs in tactic mode, it will be helpful to learn a bit about term mode. Term mode is best for simple proofs, so we begin with a few very short proofs.\nIf you have not yet installed Lean on your computer, go back and follow the instructions for installing it now. Then in VS Code, open the folder for the HTPI Lean Package that you downloaded and click on the file Blank.lean. The file starts with the line import HTPIDefs. Click on the blank line at the end of the file; this is where you will be typing your first proofs.\nNow type in the following theorem and proof:\ntheorem extremely_easy (P : Prop) (h : P) : P := h\nThis theorem and proof are so short we have put everything on one line. In this theorem, the letter P is used to stand for a proposition. The theorem has one hypothesis, P, which has been given the identifier h, and the conclusion of the theorem is also P. The notation := indicates that what follows will be a proof in term mode.\nOf course, the proof of the theorem is extremely easy: to prove P, we just have to point out that it is given as the hypothesis h. And so the proof in Lean consists of just one letter: h.\nEven though this example is a triviality, there are some things to be learned from it. First of all, although we have been describing the letter h as an identifier for the hypothesis P, this example illustrates that Lean also considers h to be a proof of P. In general, when we see h : P in a Lean proof, where P is a proposition, we can think of it as meaning, not just that h is an identifier for the statement P, but also that h is a proof of P.\nWe can learn something else from this example by changing it slightly. If you change the final h to a different letter—say, f—you will see that Lean puts a red squiggly line under the f, like this:\ntheorem extremely_easy (P : Prop) (h : P) : P := !!f!!\nThis indicates that Lean has detected an error in the proof. Lean always indicates errors by putting a red squiggle under the offending text. Lean also puts a message in the Lean Infoview pane explaining what the error is. (If you don’t see the Infoview pane, choose “Command Palette …” in the “View” menu, and then type “Lean” in the text box that appears. You will see a list of commands that start with “Lean”. Click on “Lean 4: Infoview: Toggle” to make the Infoview pane appear.) In this case, the message is unknown identifier 'f'. The message is introduced by a heading, in red, that identifies the file, the line number, and the character position on that line where the error appears. If you change f back to h, the red squiggle and error message go away.\nLet’s try a slightly less trivial example. To type the → symbol in the next example, type \\to and then hit either the space bar or the tab key; when you type either space or tab, the \\to will change to →. Alternatively, you can type \\r (short for “right arrow”) or \\imp (short for “implies”), again followed by either space or tab. Or, you can type ->, and Lean will interpret it as →.\ntheorem very_easy\n(P Q : Prop) (h1 : P → Q) (h2 : P) : Q := h1 h2\nThis time there are two hypotheses, h1 : P → Q and h2 : P. As explained in Section 3.2 of HTPI, the conclusion Q follows from these hypotheses by the logical rule modus ponens. To use modus ponens to complete this proof in term mode, we simply write the identifiers of the two hypotheses—which, as we have just seen, can also be thought of as proofs of the two hypotheses—one after the other, with a space between them. It is important to write the proof of the conditional hypothesis first, so the proof is written h1 h2; if you try writing this proof as h2 h1, you will get a red squiggle. In general, if a is a proof of any conditional statement X → Y, and b is a proof of the antecedent X, then a b is a proof of the consequent Y. The proofs a and b need not be simply identifiers; any proofs of a conditional statement and its antecedent can be combined in this way.\nWe’ll try one more proof in term mode:\ntheorem easy (P Q R : Prop) (h1 : P → Q)\n(h2 : Q → R) (h3 : P) : R :=\nNote that in the statement of the theorem, you can break the lines however you please; this time we have put the declaration of P, Q, and R and the first hypothesis on the first line and the other two hypotheses on the second line. How can we prove the conclusion R? Well, we have h2 : Q → R, so if we could prove Q then we could use modus ponens to reach the desired conclusion. In other words, h2 _ will be a proof of R, if we can fill in the blank with a proof of Q. Can we prove Q? Yes, Q follows from P → Q and P by modus ponens, so h1 h3 is a proof of Q. Filling in the blank, we conclude that h2 (h1 h3) is a proof of R. Type it in, and you’ll see that Lean will accept it. Note that the parentheses are important; if you write h2 h1 h3 then Lean will interpret it as (h2 h1) h3, which doesn’t make sense, and you’ll get an error."
  },
  {
    "objectID": "IntroLean.html#tactic-mode",
    "href": "IntroLean.html#tactic-mode",
    "title": "Introduction to Lean",
    "section": "Tactic Mode",
    "text": "Tactic Mode\nFor more complicated proofs, it is easier to use tactic mode. Type the following theorem into Lean; to type the symbol ¬, type \\not, followed again by either space or tab. Alternatively, if you type Not P, Lean will interpret it as meaning ¬P.\ntheorem two_imp (P Q R : Prop)\n(h1 : P → Q) (h2 : Q → ¬R) : R → ¬P :=\nLean is now waiting for you to type a proof in term mode. To switch to tactic mode, type by after :=. Although it is not necessary, we find it helpful to set off a tactic proof from the surrounding text by indenting it, and also by marking where the proof ends. To do this, leave a blank line after the statement of the theorem and begin the next line with a tab; VS Code will indent two spaces. Then type done. You will type your proof between the statement of the theorem and the line containing done, so click on the blank line between them to position the cursor there.\nOne of the advantages of tactic mode is that Lean displays, in the Lean Infoview pane, information about the status of the proof as your write it. As soon as you position your cursor on the blank line, Lean displays what it calls the “tactic state” in the Infoview pane. Your screen should look like this:\n\n\nLean File\ntheorem two_imp (P Q R : Prop)\n(h1 : P → Q) (h2 : Q → ¬R) : R → ¬P := by\n\n  !!done!!\n\n\nTactic State in Infoview\nP Q R : Prop\nh1 : P → Q\nh2 : Q → ¬R\n⊢ R → ¬P\n\n\nThe red squiggle under done indicates that Lean knows that the proof isn’t done. The tactic state in the Infoview pane is very similar to the lists of givens and goals that are used in HTPI. The tactic state above says that P, Q, and R stand for propositions, and we have two givens, h1 : P → Q and h2 : Q → ¬R. The symbol ⊢ in the last line labels the goal, R → ¬P.\nFrom the hypotheses h1 and h2 it shouldn’t be hard to prove P → ¬R, but the goal is R → ¬P. This suggests that we should prove the contrapositive of the goal. Type tab to indent two spaces and then contrapos to tell Lean that you want to replace the goal with its contrapositive. (You won’t have to type tab to indent later lines; VS Code maintains the same indenting until you delete the tab at the beginning of a line to return to unindented text.) As soon as you type contrapos, Lean will update the tactic state to reflect the change in the goal. You should now see this:\n\n\nLean File\ntheorem two_imp (P Q R : Prop)\n(h1 : P → Q) (h2 : Q → ¬R) : R → ¬P := by\n  contrapos\n  !!done!!\n\n\nTactic State in Infoview\nP Q R : Prop\nh1 : P → Q\nh2 : Q → ¬R\n⊢ P → ¬R\n\n\nIf you want to make your proof a little more readable, you could add a comment saying that the goal has been changed to P → ¬R. To prove the new goal, we will assume P and prove ¬R. So type assume h3 : P on a new line (after contrapos, but before done). Once again, the tactic state is immediately updated. Lean adds the new given h3 : P, and it knows, without having to be told, that the goal should now be ¬R:\n\n\nLean File\ntheorem two_imp (P Q R : Prop)\n(h1 : P → Q) (h2 : Q → ¬R) : R → ¬P := by\n  contrapos           --Goal is now P → ¬R\n  assume h3 : P\n  !!done!!\n\n\nTactic State in Infoview\nP Q R : Prop\nh1 : P → Q\nh2 : Q → ¬R\nh3 : P\n⊢ ¬R\n\n\nWe can now use modus ponens to infer Q from h1 : P → Q and h3 : P. As we saw earlier, this means that h1 h3 is a term-mode proof of Q. So on the next line, type have h4 : Q := h1 h3. To make an inference, you need to provide a justification, so := here is followed by the term-mode proof of Q. Usually we will use have to make easy inferences for which we can give simple term-mode proofs. (We’ll see later that it is also possible to use have to make an inference justified by a tactic-mode proof.) Of course, Lean updates the tactic state by adding the new given h4 : Q:\n\n\nLean File\ntheorem two_imp (P Q R : Prop)\n(h1 : P → Q) (h2 : Q → ¬R) : R → ¬P := by\n  contrapos           --Goal is now P → ¬R\n  assume h3 : P\n  have h4 : Q := h1 h3\n  !!done!!\n\n\nTactic State in Infoview\nP Q R : Prop\nh1 : P → Q\nh2 : Q → ¬R\nh3 : P\nh4 : Q\n⊢ ¬R\n\n\nFinally, to complete the proof, we can infer the goal ¬R from h2 : Q → ¬R and h4 : Q, using the term-mode proof h2 h4. Type show ¬R from h2 h4 to complete the proof. You’ll notice two changes in the display: the red squiggle will disappear from the word done, and the tactic state will say “Goals accomplished”:\n\n\nLean File\ntheorem two_imp (P Q R : Prop)\n(h1 : P → Q) (h2 : Q → ¬R) : R → ¬P := by\n  contrapos           --Goal is now P → ¬R\n  assume h3 : P\n  have h4 : Q := h1 h3\n  show ¬R from h2 h4\n  done\n\n\nTactic State in Infoview\n!!Goals accomplished 🎉\n\n\nCongratulations! You’ve written your first proof in tactic mode. If you move your cursor around in the proof, you will see that Lean always displays in the Infoview the tactic state at the point in the proof where the cursor is located. Try clicking on different lines of the proof to see how the tactic state changes over the course of the proof. If you want to try another example, you could try typing in the first example in this chapter.\nWe have now seen four tactics: contrapos, assume, have, and show. If the goal is a conditional statement, the contrapos tactic replaces it with its contrapositive. If h is a given that is a conditional statement, then contrapos at h will replace h with its contrapositive. If the goal is a conditional statement P → Q, you can use the assume tactic to assume the antecedent P, and Lean will set the goal to be the consequent Q. You can use the have tactic to make an inference from your givens, as long as you can justify the inference with a proof. The show tactic is similar, but it is used to infer the goal, thus completing the proof. And we have learned how to use one rule of inference in term mode: modus ponens. In the rest of this book we will learn about other tactics and other term-mode rules.\nBefore continuing, it might be useful to summarize how you type statements into Lean. We have already told you how to type the symbols → and ¬, but you will want to know how to type all of the logical connectives. In each case, the command to produce the symbol must be followed by space or tab, but there is also a plain text alternative:\n\n\n\n\nSymbol\nHow To Type It\nPlain Text Alternative\n\n\n\n\n¬\n\\not or \\n\nNot\n\n\n∧\n\\and\n/\\\n\n\n∨\n\\or or \\v\n\\/\n\n\n→\n\\to or \\r or \\imp\n->\n\n\n↔︎\n\\iff or \\lr\n<->\n\n\n\n\nLean has conventions that it follows to interpret a logical statement when there are not enough parentheses to indicate how terms are grouped in the statement, . For our purposes, the most important of these conventions is that P → Q → R is interpreted as P → (Q → R), not (P → Q) → R. The reason for this is simply that statements of the form P → (Q → R) come up much more often in proofs than statements of the form (P → Q) → R. Of course, when in doubt about how to type a statement, you can always put in extra parentheses to avoid confusion.\nWe will be using tactics to apply several logical equivalences. Here are tactics corresponding to all of the logical laws listed in Chapter 1:\n\n\n\n\n\n\n\n\n\n\nLogical Law\nTactic\n\nTransformation\n\n\n\n\n\nContrapositive Law\ncontrapos\nP → Q\nis changed to\n¬Q → ¬P\n\n\nDe Morgan’s Laws\ndemorgan\n¬(P ∧ Q)\nis changed to\n¬P ∨ ¬Q\n\n\n\n\n¬(P ∨ Q)\nis changed to\n¬P ∧ ¬Q\n\n\n\n\nP ∧ Q\nis changed to\n¬(¬P ∨ ¬Q)\n\n\n\n\nP ∨ Q\nis changed to\n¬(¬P ∧ ¬Q)\n\n\nConditional Laws\nconditional\nP → Q\nis changed to\n¬P ∨ Q\n\n\n\n\n¬(P → Q)\nis changed to\nP ∧ ¬Q\n\n\n\n\nP ∨ Q\nis changed to\n¬P → Q\n\n\n\n\nP ∧ Q\nis changed to\n¬(P → ¬Q)\n\n\nDouble Negation Law\ndouble_neg\n¬¬P\nis changed to\nP\n\n\n\nAll of these tactics work the same way as the contrapos tactic: by default, the transformation is applied to the goal; to apply it to a given h, add at h after the tactic name."
  },
  {
    "objectID": "IntroLean.html#types",
    "href": "IntroLean.html#types",
    "title": "Introduction to Lean",
    "section": "Types",
    "text": "Types\nAll of our examples so far have just used letters to stand for propositions. To prove theorems with mathematical content, we will need to introduce one more idea.\nThe underlying theory on which Lean is based is called type theory. We won’t go very deeply into type theory, but we will need to make use of the central idea of the theory: every variable in Lean must have a type. What this means is that, when you introduce a variable to stand for a mathematical object in a theorem or proof, you must specify what type of object the variable stands for. We have already seen this idea in action: in our first example, the expression (P Q R : Prop) told Lean that the variables P, Q, and R have type Prop, which means they stand for propositions. There are types for many kinds of mathematical objects. For example, Nat is the type of natural numbers, and Real is the type of real numbers. So if you want to state a theorem about real numbers x and y, the statement of your theorem might start with (x y : Real). You must include such a type declaration before you can use the variables x and y as free variables in the hypotheses or conclusion of your theorem.\nWhat about sets? If you want to prove a theorem about a set A, can you say that A has type Set? No, Lean is fussier than that. Lean wants to know, not only that A is a set, but also what the type of the elements of A is. So you can say that A has type Set Nat if A is a set whose elements are natural numbers, or Set Real if it is a set of real numbers, or even Set (Set Nat) if it is a set whose elements are sets of natural numbers. Here is an example of a simple theorem about sets; it is a simplified version of Example 3.2.5 in HTPI. To type the symbols ∈, ∉, and \\ in this theorem, type \\in, \\notin, and \\\\, respectively.\n\n\nLean File\ntheorem Example_3_2_5_simple\n(A B : Set Nat) (a : Nat)\n(h1 : a ∈ A) (h2 : a ∉ A \\ B) : a ∈ B := by\n\n  !!done!!\n\n\nTactic State in Infoview\nA B : Set ℕ\na : ℕ\nh1 : a ∈ A\nh2 : ¬a ∈ A \\ B\n⊢ a ∈ B\n\n\nThe second line of this theorem statement declares that the variables A and B stand for sets of natural numbers, and a stands for a natural number. The third line states the two hypotheses of the theorem, a ∈ A and a ∉ A \\ B, and the conclusion, a ∈ B.\nTo figure out this proof, we’ll imitate the reasoning in Example 3.2.5 in HTPI. We begin by writing out the meaning of the given h2. Fortunately, we have a tactic for that. The tactic define writes out the definition of the goal, and as usual we can add at to apply the tactic to a given rather than the goal. Here’s the situation after using the tactic define at h2:\n\n\nLean File\ntheorem Example_3_2_5_simple\n(A B : Set Nat) (a : Nat)\n(h1 : a ∈ A) (h2 : a ∉ A \\ B) : a ∈ B := by\n  define at h2       --Now h2 : ¬(a ∈ A ∧ ¬a ∈ B)\n  !!done!!\n\n\nTactic State in Infoview\nA B : Set ℕ\na : ℕ\nh1 : a ∈ A\nh2 : ¬(a ∈ A ∧ ¬a ∈ B)\n⊢ a ∈ B\n\n\nWe see that Lean has written out the meaning of set difference in h2. And now we can see that, as in Example 3.2.5 in HTPI, we can put h2 into a more useful form by applying first one of De Morgan’s laws to rewrite it as ¬a ∈ A ∨ a ∈ B and then a conditional law to change it to a ∈ A → a ∈ B:\n\n\nLean File\ntheorem Example_3_2_5_simple\n(A B : Set Nat) (a : Nat)\n(h1 : a ∈ A) (h2 : a ∉ A \\ B) : a ∈ B := by\n  define at h2       --Now h2 : ¬(a ∈ A ∧ ¬a ∈ B)\n  demorgan at h2     --Now h2 : ¬a ∈ A ∨ a ∈ B\n  conditional at h2  --Now h2 : a ∈ A → a ∈ B\n  !!done!!\n\n\nTactic State in Infoview\nA B : Set ℕ\na : ℕ\nh1 : a ∈ A\nh2 : a ∈ A → a ∈ B\n⊢ a ∈ B\n\n\nOccasionally, you may feel that the application of two tactics one after the other should be thought of as a single step. To allow for this, Lean lets you put two tactics on the same line, separated by a semicolon. For example, in this proof you could write the use of De Morgan’s law and the conditional law as a single step by writing demorgan at h2; conditional at h2. Now the rest is easy: we can apply modus ponens to reach the goal:\n\n\nLean File\ntheorem Example_3_2_5_simple\n(A B : Set Nat) (a : Nat)\n(h1 : a ∈ A) (h2 : a ∉ A \\ B) : a ∈ B := by\n  define at h2       --Now h2 : ¬(a ∈ A ∧ ¬a ∈ B)\n  demorgan at h2; conditional at h2\n                     --Now h2 : a ∈ A → a ∈ B\n  show a ∈ B from h2 h1\n  done\n\n\nTactic State in Infoview\n!!Goals accomplished 🎉\n\n\nThere is one unfortunate feature of this theorem: We have stated it as a theorem about sets of natural numbers, but the proof has nothing to do with natural numbers. Exactly the same reasoning would prove a similar theorem about sets of real numbers, or sets of objects of any other type. Do we need to write a different theorem for each of these cases? No, fortunately there is a way to write one theorem that covers all the cases:\ntheorem Example_3_2_5_simple_general\n(U : Type) (A B : Set U) (a : U)\n(h1 : a ∈ A) (h2 : a ∉ A \\ B) : a ∈ B := by\nIn this version of the theorem, we have introduced a new variable U, whose type is … Type! So U can stand for any type. You can think of the variable U as playing the role of the universe of discourse, an idea that was introduced in Section 1.3 of HTPI. The sets A and B contain elements from that universe of discourse, and a belongs to the universe. You can prove the new version of the theorem by using exactly the same sequence of tactics as before."
  },
  {
    "objectID": "Chap3.html",
    "href": "Chap3.html",
    "title": "3  Proofs",
    "section": "",
    "text": "Sections 3.1 and 3.2 of How To Prove It present strategies for dealing with givens and goals involving negations and conditionals. We restate those strategies here, and explain how to use them with Lean.\nSection 3.1 gives two strategies for proving a goal of the form P → Q:\n\n\n\nAssume P is true and prove Q.\nAssume Q is false and prove that P is false.\n\nWe’ve already seen how to carry out both of these strategies in Lean. For the first strategy, use the assume tactic to introduce the assumption P and assign an identifier to it; Lean will automaticall set Q as the goal. We can summarize the effect of using this strategy by showing how the tactic state changes if you use the tactic assume h : P:\n\n\nTactic State Before Using Strategy\n!! ⋮\n⊢ P → Q\n\n\nTactic State After Using Strategy\n!! ⋮\nh : P\n⊢ Q\n\n\nThe second strategy is justified by the contrapositive law. In Lean, you can use the contrapos tactic to rewrite the goal as ¬Q → ¬P and then use the tactic assume h : ¬Q. The net effect of these two tactics is:\n\n\nTactic State Before Using Strategy\n!! ⋮\n⊢ P → Q\n\n\nTactic State After Using Strategy\n!! ⋮\nh : ¬Q\n⊢ ¬P\n\n\nSection 3.2 gives two strategies for using givens of the form P → Q, with the second once again being a variation on the first based on the contrapositive law:\n\n\n\n\nIf you are also given P, or you can prove that P is true, then you can use this given to conclude that Q is true.\nIf you are also given ¬Q, or you can prove that Q is false, then you can use this given to conclude that P is false.\n\nThe first strategy is the modus ponens rule of inference, and we saw in the last chapter that if you have h1 : P → Q and h2 : P, then h1 h2 is a (term-mode) proof of Q; often we use this rule with the have or show tactic. For the second strategy, if you have h1 : P → Q and h2 : ¬Q, then the contrapos at h1 tactic will change h1 to h1 : ¬Q → ¬P, and then h1 h2 will be a proof of ¬P.\nAll of the strategies listed above for working with conditional statements as givens or goals were illustrated in examples in the last chapter.\nSection 3.2 of HTPI offers two strategies for proving negative goals:\n\n\n\n\nReexpress the goal in some other form.\nUse proof by contradiction: assume P is true and try to deduce a contradiction.\n\nFor the first strategy, the tactics demorgan, conditional, and double_neg may be useful, and we saw how those tactics work in the last chapter. But how do you write a proof by contradiction in Lean? The answer is to use a tactic called by_contra. If the goal is ¬P, then the tactic by_contra h will introduce the assumption h : P and set the goal to be False, like this:\n\n\nTactic State Before Using Strategy\n!! ⋮\n⊢ ¬P\n\n\nTactic State After Using Strategy\n!! ⋮\nh : P\n⊢ False\n\n\nIn Lean, False represents a statement that is always false—that is, a contradiction, as that term is defined in Section 1.2 of HTPI. The by_contra tactic can actually be used even if the goal is not a negative statement. If the goal is a statement P that is not a negative statement, then by_contra h will initiate a proof by contradiction by introducing the assumption h : ¬P and setting the goal to be False.\nYou will usually complete a proof by contradiction by deducing two contradictory statements—say, h1 : Q and h2 : ¬Q. But how do you convince Lean that the proof is over? You must be able to prove the goal False from the two givens h1 and h2. There are two ways to do this. The first is based on the fact that Lean treats a statement of the form ¬Q as meaning the same thing as Q → False. This makes sense, because these statements are logically equivalent, as shown by the following truth table:\n\n\n\n\nQ\n¬Q\n(Q\n→\nFalse)\n\n\n\n\nF\nT\nF\nT\n    F\n\n\nT\nF\nT\nF\n    F\n\n\n\n\nThinking of h2 : ¬Q as meaning h2 : Q → False, we can combine it with h1 : Q using modus ponens to deduce False. In other words, h2 h1 is a proof of False.\nBut there is a second way of completing the proof that it is worthwhile to know about. From contradictory statements h1 : Q and h2 : ¬Q you can validly deduce any statement. This follows from the definition of a valid argument in Section 1.1 of HTPI. According to that definition, you can validly infer a conclusion R from premises h1 : Q and h2 : ¬Q if the premises cannot both be true without the conclusion also being true. In this case, that standard is met, for the simple reason that the premises cannot both be true! (This gives part of the answer to exercise 18 in Section 1.2 of HTPI.) Thus, Lean has a rule that allows you to prove any statement from contradictory premises. If you have h1 : Q and h2 : ¬Q, then Lean will recognize absurd h1 h2 as a (term-mode) proof of any statement.\nTo summarize, if you have h1 : Q and h2 : ¬Q, then there are two ways to prove False. Lean will recognize h2 h1 as a proof of False, and it will recognize absurd h1 h2 as a proof of any statement, including False. Notice the difference in the order in which h1 and h2 are listed in these two proofs: In the first one, the negative statement h2 must come first, just as the conditional statement must come first in an application of modus ponens. But in a proof using absurd, the negative statement must come second.\nTo illustrate proof by contradiction in Lean, let’s redo our first example from the last Chapter in a different way. That example was based on Example 3.2.4 in HTPI. We’ll begin with the same first two steps, introducing two assumptions. (We won’t bother to include the done line in the displays below.)\n\n\nLean File\ntheorem Example_3_2_4_v2 (P Q R : Prop)\n(h : P → (Q → R)) : ¬R → (P → ¬Q) := by\n  assume h2 : ¬R\n  assume h3 : P\n\n\nTactic State in Infoview\nP Q R : Prop\nh : P → Q → R\nh2 : ¬R\nh3 : P\n⊢ ¬Q\n\n\nNow the goal is a negative statement, so we use the tactic by_contra h4 to introduce the assumption h4 : Q and set the goal to be False:\n\n\nLean File\ntheorem Example_3_2_4_v2 (P Q R : Prop)\n(h : P → (Q → R)) : ¬R → (P → ¬Q) := by\n  assume h2 : ¬R\n  assume h3 : P\n  by_contra h4\n\n\nTactic State in Infoview\nP Q R : Prop\nh : P → Q → R\nh2 : ¬R\nh3 : P\nh4 : Q\n⊢ False\n\n\nUsing the givens h, h3, and h4 we can deduce first Q → R and then R by two applications of modus ponens:\n\n\nLean File\ntheorem Example_3_2_4_v2 (P Q R : Prop)\n(h : P → (Q → R)) : ¬R → (P → ¬Q) := by\n  assume h2 : ¬R\n  assume h3 : P\n  by_contra h4\n  have h5 : Q → R := h h3\n  have h6 : R := h5 h4\n\n\nTactic State in Infoview\nP Q R : Prop\nh : P → Q → R\nh2 : ¬R\nh3 : P\nh4 : Q\nh5 : Q → R\nh6 : R\n⊢ False\n\n\nNow we have a contradiction: h2 : ¬R and h6 : R. To complete the proof, we deduce False from these two givens. Either h2 h6 or absurd h6 h2 would be accepted by Lean as a proof of False:\n\n\nLean File\ntheorem Example_3_2_4_v2 (P Q R : Prop)\n(h : P → (Q → R)) : ¬R → (P → ¬Q) := by\n  assume h2 : ¬R\n  assume h3 : P\n  by_contra h4\n  have h5 : Q → R := h h3\n  have h6 : R := h5 h4\n  show False from h2 h6\n\n\nTactic State in Infoview\n!!Goals accomplished 🎉\n\n\nFinally, we have two strategies for using a given that is a negative statement:\n\n\n\n\nReexpress the given in some other form.\nIf you are doing a proof by contradiction, you can achieve a contradiction by proving P, since that would contradict the given ¬P.\n\nOf course, strategy 1 suggests the use of the demorgan, conditional, and double_neg tactics, if they apply. For strategy 2, if you are doing a proof by contradiction and you have a given h : ¬P, then the tactic contradict h will set the goal to be P, which will complete the proof by contradicting h. In fact, this tactic can be used with any given; if you have a given h : P, where P is not a negative statement, then contradict h will set the goal to be ¬P. If you’re not doing a proof by contradiction, then the tactic contradict h with h' will first initiate a proof by contradiction by assuming the negation of the goal, giving that assumption the identifier h', and then it will set the goal to be the negation of h. In other words, contradict h with h' is shorthand for by_contra h'; contradict h.\nWe can illustrate this with yet another way to write the proof from Example 3.2.4. Our first three steps will be the same as last time:\n\n\nLean File\ntheorem Example_3_2_4_v3 (P Q R : Prop)\n(h : P → (Q → R)) : ¬R → (P → ¬Q) := by\n  assume h2 : ¬R\n  assume h3 : P\n  by_contra h4\n\n\nTactic State in Infoview\nP Q R : Prop\nh : P → Q → R\nh2 : ¬R\nh3 : P\nh4 : Q\n⊢ False\n\n\nSince we are now doing a proof by contradiction and the given h2 : ¬R is a negative statement, a likely way to proceed is to try to prove R, which would contradict h2. So we use the tactic contradict h2:\n\n\nLean File\ntheorem Example_3_2_4_v3 (P Q R : Prop)\n(h : P → (Q → R)) : ¬R → (P → ¬Q) := by\n  assume h2 : ¬R\n  assume h3 : P\n  by_contra h4\n  contradict h2\n\n\nTactic State in Infoview\nP Q R : Prop\nh : P → Q → R\nh2 : ¬R\nh3 : P\nh4 : Q\n⊢ R\n\n\nAs before, we can now prove R by combining h, h3, and h4. In fact, we could do it in one step: by modus ponens, h h3 is a proof of Q → R, and therefore, by another application of modus ponens, (h h3) h4 is a proof of R. The parentheses here are not necessary; Lean will interpret h h3 h4 as (h h3) h4, so we can complete the proof like this:\n\n\nLean File\ntheorem Example_3_2_4_v3 (P Q R : Prop)\n(h : P → (Q → R)) : ¬R → (P → ¬Q) := by\n  assume h2 : ¬R\n  assume h3 : P\n  by_contra h4\n  contradict h2\n  show R from h h3 h4\n\n\nTactic State in Infoview\n!!Goals accomplished 🎉\n\n\nYou could shorten this proof slightly by replacing the lines by_contra h4 and contradict h2 with the single line contradict h2 with h4.\nThere is one more idea that is introduced in Section 3.2 of HTPI. The last example in that section illustrates how you can sometimes use rules of inference to work backwards. Here’s a similar example in Lean:\n\n\nLean File\ntheorem Like_Example_3_2_5\n(U : Type) (A B C : Set U) (a : U)\n(h1 : a ∈ A) (h2 : a ∉ A \\ B)\n(h3 : a ∈ B → a ∈ C) : a ∈ C := by\n\n\nTactic State in Infoview\nU : Type\nA B C : Set U\na : U\nh1 : a ∈ A\nh2 : ¬a ∈ A \\ B\nh3 : a ∈ B → a ∈ C\n⊢ a ∈ C\n\n\nThe goal is a ∈ C, and the only given that even mentions C is h3 : a ∈ B → a ∈ C. If only we could prove a ∈ B, then we could apply h3, using modus ponens, to reach our goal. So it would make sense to work toward the goal of proving a ∈ B.\nTo get Lean to use this proof strategy, we use the tactic apply h3 _. The underscore here represents a blank to be filled in by Lean. You might think of this tactic as asking Lean the question: If we want h3 _ to be a proof of the goal a ∈ C, what do we have to put in the blank? Lean is able to figure out that the answer is: a proof of a ∈ B. So it sets the goal to be a ∈ B, since a proof of that goal, when inserted into the blank in h3 _, would prove the original goal a ∈ C:\n\n\nLean File\ntheorem Like_Example_3_2_5\n(U : Type) (A B C : Set U) (a : U)\n(h1 : a ∈ A) (h2 : a ∉ A \\ B)\n(h3 : a ∈ B → a ∈ C) : a ∈ C := by\n  apply h3 _\n\n\nTactic State in Infoview\nU : Type\nA B C: Set U\na : U\nh1 : a ∈ A\nh2 : ¬a ∈ A \\ B\nh3 : a ∈ B → a ∈ C\n⊢ a ∈ B\n\n\nIt may not be clear what to do next, but the given h2 is a negative statement, so perhaps reexpressing it will help. Writing out the definition of set difference, h2 means ¬(a ∈ A ∧ a ∉ B), and then one of De Morgan’s laws and a conditional law allow us to rewrite it first as (a ∉ A ∨ a ∈ B) and then as (a ∈ A → a ∈ B). Of course, we have tactics to accomplish all of these reexpressions:\n\n\nLean File\ntheorem Like_Example_3_2_5\n(U : Type) (A B C : Set U) (a : U)\n(h1 : a ∈ A) (h2 : a ∉ A \\ B)\n(h3 : a ∈ B → a ∈ C) : a ∈ C := by\n  apply h3 _\n  define at h2\n  demorgan at h2; conditional at h2\n\n\nTactic State in Infoview\nU : Type\nA B C : Set U\na : U\nh1 : a ∈ A\nh2 : a ∈ A → a ∈ B\nh3 : a ∈ B → a ∈ C\n⊢ a ∈ B\n\n\nAnd now it is easy to complete the proof by applying modus ponens, using h2 and h1:\n\n\nLean File\ntheorem Like_Example_3_2_5\n(U : Type) (A B C : Set U) (a : U)\n(h1 : a ∈ A) (h2 : a ∉ A \\ B)\n(h3 : a ∈ B → a ∈ C) : a ∈ C := by\n  apply h3 _\n  define at h2\n  demorgan at h2; conditional at h2\n  show a ∈ B from h2 h1\n\n\nTactic State in Infoview\n!!Goals accomplished 🎉\n\n\nWe will see many more uses of the apply tactic later in this book.\nSections 3.1 and 3.2 of HTPI contain several proofs that involve algebraic reasoning. Although one can do such proofs in Lean, it requires ideas that we are not ready to introduce yet. So for the moment we will stick to proofs involving only logic and set theory."
  }
]