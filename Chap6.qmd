# Mathematical Induction

## 6.1.  Proof by Mathematical Induction

Section 6.1 of *HTPI* introduces a new proof technique called *mathematical induction*.  It is used for proving statements of the form `∀ (n : Nat), P n`.  Here is how it works:

#### To prove a goal of the form `∀ (n : Nat), P n`:

::: {.ind}
First prove `P 0`, and then prove `∀ (n : Nat), P n → P (n + 1)`.  The first of these proofs is sometimes called the *base case* and the second the *induction step*.
:::

For an explanation of why this strategy works to establish the truth of `∀ (n : Nat), P n`, see *HTPI*.  Here we focus on using mathematical induction in Lean.

To use mathematical induction in a Lean proof, we will use the tactic `by_induc`.  If the goal has the form `∀ (n : Nat), P n`, then the `by_induc` tactic leaves the list of givens unchanged, but it replaces the goal with the goals for the base case and induction step.  Thus, the effect of the tactic can be summarized as follows:

::: {.lftrt}
::: {.bef}
```state
>> ⋮
⊢ ∀ (n : ℕ), P n
```
:::

::: {.aft}
```state
case Base_Case
>> ⋮
⊢ P 0
case Induction_Step
>> ⋮
⊢ ∀ (n : ℕ), P n → P (n + 1)
```
:::
:::

To illustrate proof by mathematical induction in Lean, we turn first to Example 6.1.2 in *HTPI*, which gives a proof of the statement $\forall n \in \mathbb{N} (3 \mid (n^3 - n))$.  For reasons that we will explain a little later, we will prove a slightly different theorem:  $\forall n \in \mathbb{N} (3 \mid (n^3 + 2n))$.  Here is a proof of the theorem, modeled on the proof in Example 6.1.2 of *HTPI*.

::: {.thm}
For every natural number $n$, $3 \mid (n^3 + 2n)$.
:::

::: {.proof}
We use mathematical induction.

Base Case:  If $n = 0$, then $n^3 + 2n = 0 = 3 \cdot 0$, so $3 \mid (n^3 + 2n)$.

Induction Step:  Let $n$ be an arbitrary natural number and suppose $3 \mid (n^3 + 2n)$.  Then we can choose an integer $k$ such that $3k = n^3 + 2n$.  Thus,
\begin{align*}
(n+1)^3 + 2(n+1) &= n^3 + 3n^2 + 3n + 1 + 2n + 2\\
&= (n^3 + 2n) + 3n^2 + 3n + 3\\
&= 3k + 3n^2 + 3n + 3\\
&= 3(k + n^2 + n + 1).
\end{align*}
Therefore $3 \mid ((n+1)^3 + 2(n+1))$, as required. [&nbsp;□]{.excl}\qedhere
:::

Now let's try writing the same proof in Lean.  We start, of course, with the `by_induc` tactic.

::: {.inout}
::: {.inpt}
```lean
theorem Like_Example_6_1_2 :
    ∀ (n : Nat), 3 ∣ n ^ 3 + 2 * n := by
  by_induc
  **done::
```
:::

::: {.outpt}
```state
case Base_Case
⊢ 3 ∣ 0 ^ 3 + 2 * 0
case Induction_Step
⊢ ∀ (n : ℕ),
>>  3 ∣ n ^ 3 + 2 * n →
>>  3 ∣ (n + 1) ^ 3 +
>>      2 * (n + 1)
```
:::
:::

The base case is easy:  The `define` tactic tells us that the goal means `∃ (c : Nat), 0 ^ 3 + 2 * 0 = 3 * c`, and then `apply Exists.intro 0` changes the goal to `0 ^ 3 + 2 * 0 = 3 * 0`.  Both sides are definitionally equal to `0`, so `rfl` finishes off the base case.  For the induction step, we begin, as in the *HTPI* proof, by introducing an arbitrary natural number `n` and assuming `3 ∣ n ^ 3 + 2 * n`.  This assumption is called the *inductive hypothesis*, so in the Lean proof we give it the identifier `ih`.  Our goal now is to prove `3 ∣ (n + 1) ^ 3 + 2 * (n + 1)`.

::: {.inout}
::: {.inpt}
```lean
theorem Like_Example_6_1_2 :
    ∀ (n : Nat), 3 ∣ n ^ 3 + 2 * n := by
  by_induc
  · -- Base Case
    define
    apply Exists.intro 0
    rfl
    done
  · -- Induction Step
    fix n : Nat
    assume ih : 3 ∣ n ^ 3 + 2 * n
    **done::
  done
```
:::

::: {.outpt}
```state
case Induction_Step
n : ℕ
ih : 3 ∣ n ^ 3 + 2 * n
⊢ 3 ∣ (n + 1) ^ 3 +
>>      2 * (n + 1)
```
:::
:::

The rest of the Lean proof follows the model of the *HTPI* proof:  we use the inductive hypothesis to introduce a `k` such that `n ^ 3 + 2 * n = 3 * k`, and then we use a calculational proof to show that `(n + 1) ^ 3 + 2 * (n + 1) = 3 * (k + n ^ 2 + n + 1)`.

```lean
theorem Like_Example_6_1_2 :
    ∀ (n : Nat), 3 ∣ n ^ 3 + 2 * n := by
  by_induc
  · -- Base Case
    define         --Goal: ∃ (c : ℕ), 0 ^ 3 + 2 * 0 = 3 * c
    apply Exists.intro 0
    rfl
    done
  · -- Induction Step
    fix n : Nat
    assume ih : 3 ∣ n ^ 3 + 2 * n
    define at ih   --ih: ∃ (c : ℕ), n ^ 3 + 2 * n = 3 * c
    obtain (k : Nat) (h1 : n ^ 3 + 2 * n = 3 * k) from ih
    define         --Goal: ∃ (c : ℕ), (n + 1) ^ 3 + 2 * (n + 1) = 3 * c
    apply Exists.intro (k + n ^ 2 + n + 1)
    show (n + 1) ^ 3 + 2 * (n + 1) = 3 * (k + n ^ 2 + n + 1) from
      calc (n + 1) ^ 3 + 2 * (n + 1)
          = n ^ 3 + 2 * n + 3 * n ^ 2 + 3 * n + 3 := by ring
        _ = 3 * k + 3 * n ^ 2 + 3 * n + 3 := by rw [h1]
        _ = 3 * (k + n ^ 2 + n + 1) := by ring
    done
  done
```

Next we'll look at Example 6.1.1 in *HTPI*, which proves that for every natural number $n$, $2^0 + 2^1 + \cdots + 2^n = 2^{n+1} - 1$.  Once again, we will change the theorem slightly before proving it in Lean.  What we will prove is that for every $n$, $(2^0 + 2^1 + \cdots + 2^n) + 1 = 2^{n+1}$.  To understand this theorem you must be able to recognize what the "$\cdots$" stands for.  A human reader will probably realize that the numbers being added up here are the numbers of the form $2^i$, where $i$ runs through all of the natural numbers from 0 to $n$.  But Lean can't be expected to figure out this pattern, so we must be more explicit.

Section 6.3 of *HTPI* introduces the explicit notation that mathematicians usually use for such sums.  If $f$ is a function whose domain is the natural numbers, then
$$
\sum_{i=0}^n f(i) = f(0) + f(1) + \cdots + f(n).
$$
More generally, if $k \le n$ then
$$
\sum_{i=k}^n f(i) = f(k) + f(k+1) + \cdots + f(n).
$$

The notation we will use in Lean for this sum is `Sum i from k to n, f i`.  Thus, a mathematician would state our theorem like this:

::: {.thm}
For every natural number $n$,
$$
\left(\sum_{i=0}^n 2^i\right) + 1 = 2^{n+1}.
$$
:::

And to state the same theorem in Lean, we will write:

```lean
theorem Like_Example_6_1_1 :
    ∀ (n : Nat), (Sum i from 0 to n, 2 ^ i) + 1 = 2 ^ (n + 1)
```

We will have more to say later about how the notation `Sum i from k to n, f i` is defined.  But to use the notation in a proof, we will just need to know a couple of theorems.  The `#check` command will tell us the meanings of the theorems `sum_base`, `sum_step`, and `sum_from_zero_step`:

::: {.ind}
```
@sum_base : ∀ {A : Type} [inst : AddZeroClass A] {k : ℕ} {f : ℕ → A},
            Sum i from k to k, f i = f k
@sum_step : ∀ {A : Type} [inst : AddZeroClass A] {k n : ℕ} {f : ℕ → A},
            k ≤ n → Sum i from k to n + 1, f i =
              (Sum i from k to n, f i) + f (n + 1)
@sum_from_zero_step :
            ∀ {A : Type} [inst : AddZeroClass A] {n : ℕ} {f : ℕ → A},
            Sum i from 0 to n + 1, f i =
              (Sum i from 0 to n, f i) + f (n + 1)
```
:::

As usual, we don't need to pay too much attention to the implicit arguments in the first line of each statement.  What is important is that `sum_base` can be used to prove any statement of the form

::: {.ind}
```
Sum i from k to k, f i = f k
```
:::

and `sum_step` proves any statement of the form

::: {.ind}
```
k ≤ n → Sum i from k to n + 1, f i = (Sum i from k to n, f i) + f (n + 1)
```
:::

In the case `k = 0`, we have the simpler theorem `sum_from_zero_step`, which proves

::: {.ind}
```
Sum i from 0 to n + 1, f i = (Sum i from 0 to n, f i) + f (n + 1)
```
:::

With that preparation, we can start on the proof.  Once again we begin with the `by_induc` tactic.  Our goal for the base case is `(Sum i from 0 to 0, 2 ^ i) + 1 = 2 ^ (0 + 1)`.  To deal with the term `Sum i from 0 to 0, 2 ^ i`, we use that fact that `sum_base` proves `Sum i from 0 to 0, 2 ^ i = 2 ^ 0`.  It follows that the tactic `rewrite [sum_base]` will change the goal to `2 ^ 0 + 1 = 2 ^ (0 + 1)`.  Of course, this means `2 = 2`, so `rfl` finishes the base case.  For the induction step, we start by introducing an arbitrary natural number `n` and assuming the inductive hypothesis.

```lean
theorem Like_Example_6_1_1 :
    ∀ (n : Nat), (Sum i from 0 to n, 2 ^ i) + 1 = 2 ^ (n + 1) := by
  by_induc
  · -- Base Case
    rewrite [sum_base]
    rfl
    done
  · -- Induction Step
    fix n : Nat
    assume ih : (Sum i from 0 to n, 2 ^ i) + 1 = 2 ^ (n + 1)
    **done::
  done
```

Our goal is now `(Sum i from 0 to n + 1, 2 ^ i) + 1 = 2 ^ (n + 1 + 1)`, and we use a calculational proof to prove this.  Often the key to the proof of the induction step is to find a relationship between the inductive hypothesis and the goal.  In this case, that means finding a relationship between `Sum i from 0 to n, 2 ^ i` and `Sum i from 0 to n + 1, 2 ^ i`.  The relationship we need is given by the theorem `sum_from_zero_step`.  The tactic `rewrite [sum_from_zero_step]` will replace `Sum i from 0 to n + 1, 2 ^ i` with `(Sum i from 0 to n, 2 ^ i) + 2 ^ (n + 1)`.  The rest of the calculation proof involves straightforward algebra, handled by the `ring` tactic, together with an application of the inductive hypothesis.

```lean
theorem Like_Example_6_1_1 :
    ∀ (n : Nat), (Sum i from 0 to n, 2 ^ i) + 1 = 2 ^ (n + 1) := by
  by_induc
  · -- Base Case
    rewrite [sum_base]
    rfl
    done
  · -- Induction Step
    fix n : Nat
    assume ih : (Sum i from 0 to n, 2 ^ i) + 1 = 2 ^ (n + 1)
    show (Sum i from 0 to n + 1, 2 ^ i) + 1 = 2 ^ (n + 1 + 1) from
      calc (Sum i from 0 to n + 1, 2 ^ i) + 1
          = (Sum i from 0 to n, 2 ^ i) + 2 ^ (n + 1) + 1 :=
            by rw [sum_from_zero_step]
        _ = (Sum i from 0 to n, 2 ^ i) + 1 + 2 ^ (n + 1) := by ring
        _ = 2 ^ (n + 1) + 2 ^ (n + 1) := by rw [ih]
        _ = 2 ^ (n + 1 + 1) := by ring
    done
  done
```

The last example in Section 6.1 of *HTPI* gives a proof of the statement $\forall n \ge 5 (2^n > n^2)$.  The proof is by mathematical induction, but since we are only interested in natural numbers greater than or equal to 5, it uses 5 in the base case instead of 0.  Here are the theorem and proof from *HTPI*:

::: {.thm}
For every natural number $n \ge 5$, $2^n > n^2$.
:::

::: {.proof}
By mathematical induction.

Base case:  When $n = 5$ we have $2^n = 32 > 25 = n^2$.

Induction step:  Let $n \ge 5$ be arbitrary, and suppose that $2^n > n^2$.  Then
\begin{align*}
2^{n+1} &= 2 \cdot 2^n\\
&> 2n^2 &&\text{(inductive hypothesis)}\\
&= n^2 + n^2\\
&\ge n^2 + 5n &&\text{(since $n \ge 5$)}\\
&= n^2 + 2n + 3n\\
&> n^2 + 2n + 1 = (n+1)^2. &&\Box
\end{align*}
\renewcommand{\qed}{}
:::

Notice that the sequence of calculations at the end of the proof mixes $=$, $>$, and $\ge$ in a way that establishes the final conclusion $2^{n+1} > (n+1)^2$.  As we'll see, such a mixture is allowed in calculational proofs in Lean as well.

To write this proof in Lean, there is no need to specify that the base case should be `n = 5`; the `by_induc` tactic is smart enough to figure that out on its own, as you can see in the tactic state below:

::: {.inout}
::: {.inpt}
```lean
theorem Example_6_1_3 :
    ∀ n ≥ 5, 2 ^ n > n ^ 2 := by
  by_induc
  **done::
```
:::

::: {.outpt}
```state
case Base_Case
⊢ 2 ^ 5 > 5 ^ 2
case Induction_Step
⊢ ∀ (n : ℕ), n ≥ 5 →
>>  2 ^ n > n ^ 2 →
>>  2 ^ (n + 1) >
>>      (n + 1) ^ 2
```
:::
:::

To complete this proof we'll use two tactics we haven't used before: `norm_num` and `linarith`.  The base case can be proven by simply doing the arithmetic necessary to check that the inequality holds when `n = 5`.  The tactic `norm_num` does such numerical calculations, and it proves the base case.

For the induction step, we introduce an arbitrary natural number `n`, assume `n ≥ 5`, and assume the inductive hypothesis, `2 ^ n > n ^ 2`.  Then we use a calculational proof to imitate the reasoning at the end of the *HTPI* proof.  The tactic `linarith` makes inferences that involve combining linear equations and inequalities.  It is able to prove almost all of the inequalities in the calculational proof.  The exception is `n * n ≥ 5 * n` (which is not linear because of the term `n * n`).  So we prove that inequality separately, using a theorem from Lean's library, `Nat.mul_le_mul_right`.  The command `#check @Nat.mul_le_mul_right` tells us the meaning of that theorem:

::: {.ind}
```
@Nat.mul_le_mul_right : ∀ {n m : ℕ} (k : ℕ), n ≤ m → n * k ≤ m * k
```
:::

Thus, `Nat.mul_le_mul_right n` can be used to prove the statement `5 ≤ n → 5 * n ≤ n * n`.  Lean recognizes `x ≥ y` as meaning the same thing as `y ≤ x`, so we can apply this statement to our assumption `n ≥ 5` to prove that `n * n ≥ 5 * n`.  Once we have proven that inequality, the `linarith` tactic can use it to complete the required inequality reasoning.

```lean
theorem Example_6_1_3 : ∀ n ≥ 5, 2 ^ n > n ^ 2 := by
  by_induc
  · -- Base Case
    norm_num
    done
  · -- Induction Step
    fix n : Nat
    assume h1 : n ≥ 5
    assume ih : 2 ^ n > n ^ 2
    have h2 : n * n ≥ 5 * n := Nat.mul_le_mul_right n h1
    show 2 ^ (n + 1) > (n + 1) ^ 2 from
      calc 2 ^ (n + 1)
          = 2 * 2 ^ n := by ring
        _ > n ^ 2 + 2 * n + 1 := by linarith
        _ = (n + 1) ^ 2 := by ring
    done
  done
```

Finally, we turn to the question of why we made small changes in two of the examples from *HTPI*.  Perhaps you have guessed by now that we were trying to avoid the use of subtraction.  All of the numbers in the examples in this section were natural numbers, and subtraction of natural numbers is problematic.  In the natural numbers, `3 - 2` is equal to `1`, but what is `2 - 3`?  Lean's answer is `0`.

```lean
++#eval:: 2 - 3     --Answer: 0
```

In Lean, if `a` and `b` are natural numbers and `a < b`, then `a - b` is defined to be `0`.  As a result, the algebraic laws of natural number subtraction are complicated.  For example, `2 - 3 + 1 = 0 + 1 = 1`, but `2 + 1 - 3 = 3 - 3 = 0`, so it is not true that for all natural numbers `a`, `b`, and `c`, `a - b + c = a + c - b`.

If you thought that the answer to the subtraction problem `2 - 3` was `-1`, then you automatically switched from the natural numbers to the integers.  (Recall that the natural numbers are the numbers 0, 1, 2, ..., while the integers are the numbers ..., –3, –2, –1, 0, 1, 2, 3, ....)  To a human mathematician, this is a perfectly natural thing to do: the natural numbers are a subset of the integers, so `2` and `3` are not only natural numbers but also integers, and we can compute `2 - 3` in the integers.

However, that's not how things work in Lean.  In Lean, different types are completely separate.  In particular, `Nat` and `Int` are separate types, and therefore the natural numbers are not a subset of the integers.  Of course, there is an integer 2, but it is different from the natural number 2.  By default, Lean assumes that `2` denotes the natural number 2, but you can specify that you want the integer 2 by writing `(2 : Int)`.  Subtraction of integers in Lean is the subtraction you are familiar with, and it has all the algebraic properties you would expect.  If we want to use subtraction in the theorems in this section, we are better off using familiar integer subtraction rather than funky natural number subtraction.

To prove the theorem in Example 6.1.1 as it appears in *HTPI*, we could state the theorem like this:

```lean
theorem Example_6_1_1 :
    ∀ (n : Nat), Sum i from 0 to n, (2 : Int) ^ i =
    (2 : Int) ^ (n + 1) - (1 : Int)
```

The expression `Sum i from 0 to n, (2 : Int) ^ i` denotes a sum of integers, so it is an integer.  Similarly, the right side of the equation is an integer, and the equation asserts the equality of two integers.  The subtraction on the right side of the equation is integer subtraction, so we can use the usual algebraic laws to reason about it.  In fact, the proof of the theorem in this form is not hard:

```lean
theorem Example_6_1_1 :
    ∀ (n : Nat), Sum i from 0 to n, (2 : Int) ^ i =
    (2 : Int) ^ (n + 1) - (1 : Int) := by
  by_induc
  · -- Base Case
    rewrite [sum_base]
    rfl
    done
  · -- Induction Step
    fix n : Nat
    assume ih : Sum i from 0 to n, (2 : Int) ^ i =
      (2 : Int) ^ (n + 1) - (1 : Int)
    rewrite [sum_from_zero_step, ih]
      --Goal: 2 ^ (n + 1) - 1 + 2 ^ (n + 1) = 2 ^ (n + 1 + 1) - 1
    ring
    done
  done
```

If you change `(2 : Int)` and `(1 : Int)` to `2` and `1`, then the right side of the equation will be a difference of two natural numbers, and Lean will interpret the subtraction as natural number subtraction.  The proof won't work because the `ring` tactic is not able to deal with the peculiar algebraic properties of natural number subtraction.  (The theorem is still true, but the proof is harder.)

### Exercises

::: {.numex arguments="1"}
```lean
theorem Like_Exercise_6_1_1 :
    ∀ (n : Nat), 2 * Sum i from 0 to n, i = n * (n + 1) := sorry
```
:::

::: {.numex arguments="2"}
```lean
theorem Like_Exercise_6_1_4 :
    ∀ (n : Nat), Sum i from 0 to n, 2 * i + 1 = (n + 1) ^ 2 := sorry
```
:::

::: {.numex arguments="3"}
```lean
theorem Exercise_6_1_9a : ∀ (n : Nat), 2 ∣ n ^ 2 + n := sorry
```
:::

::: {.numex arguments="4"}
```lean
theorem Exercise_6_1_13 :
    ∀ (a b : Int) (n : Nat), (a - b) ∣ (a ^ n - b ^ n) := sorry
```
:::

::: {.numex arguments="5"}
```lean
theorem Exercise_6_1_15 : ∀ n ≥ 10, 2 ^ n > n ^ 3 := sorry
```
:::

For the next exercise you will need the following definitions:

```lean
def even_nat (n : Nat) : Prop := ∃ (k : Nat), n = 2 * k
def odd_nat (n : Nat) : Prop := ∃ (k : Nat), n = 2 * k + 1
```

::: {.numex arguments="6"}
```lean
theorem Exercise_6_1_16a : ∀ (n : Nat), even_nat n ∨ odd_nat n := sorry
```
:::

## 6.2. More Examples

We saw in the last section that mathematical induction can be used to prove theorems about calculations involving natural numbers.  But mathematical induction has a much wider range of uses.  Section 6.2 of *HTPI* illustrates this by proving two theorems about finite sets.

How can mathematical induction be used to prove a statement about finite sets?  To say that a set is finite means that it has $n$ elements, for some natural number $n$.  Thus, to say that all finite sets have some property, we can say that for every natural number $n$, every set with $n$ elements has the property.  Since this statement starts with "for every natural number $n$," we can use mathematical induction to try to prove it.

What does it mean to say that a set "has $n$ elements"?  Section 6.2 of *HTPI* says that for the proofs in that section, "an intuitive understanding of this concept will suffice."  Unfortunately, intuition is not Lean's strong suit!  So we'll need to be more explicit about how to talk about finite sets in Lean.

In Chapter 8, we'll define `numElts X n` to be a proposition saying that the set `X` has `n` elements, and we'll prove several theorems involving that proposition.  Those theorems make precise and explicit the intuitive ideas that we'll need in this section.  We'll state those theorems here and use them in our proofs, but you'll have to wait until Chapter 8 to see how they are proven.  Here are the theorems we'll need:

```lean
theorem zero_elts_iff_empty {A : Type} (X : Set A) :
    numElts X 0 ↔ empty X

theorem one_elt_iff_singleton {A : Type} (X : Set A) :
    numElts X 1 ↔ ∃ (x : A), X = {x}

theorem nonempty_of_pos_numElts {A : Type} {X : Set A} {n : Nat}
    (h1 : numElts X n) (h2 : n > 0) : ∃ (x : A), x ∈ X

theorem remove_one_numElts {A : Type} {X : Set A} {n : Nat} {x : A}
    (h1 : numElts X (n + 1)) (h2 : x ∈ X) : numElts (X \ {x}) n
```

These theorems should make intuitive sense.  The first says that a set has zero elements if and only if it is empty, and the second says that a set has one element if and only if it is a singleton set.  The third theorem says that if a set has a positive number of elements, then there is something in the set.  And the fourth says that if a set has $n + 1$ elements and you remove one element, then the resulting set has $n$ elements.  You can probably guess that we'll be using the last theorem in the induction steps of our proofs.

Our first theorem about finite sets says that if $R$ is a partial order on $A$, then every finite, nonempty subset of $A$ has an $R$-minimal element.  (This is not true in general for infinite subsets of $A$.  Can you think of an example of an infinite subset of a partially ordered set that has no minimal element?)  To say that a set is finite and nonempty we can say that it has $n$ elements for some $n \ge 1$.  So here's how we state our theorem in Lean:

```lean
theorem Example_6_2_1 {A : Type} (R : BinRel A) (h : partial_order R) :
    ∀ n ≥ 1, ∀ (B : Set A), numElts B n →
      ∃ (x : A), minimalElt R x B
```

When we use mathematical induction to prove this theorem, the base case will be `n = 1`.  To prove the base case, we start by assuming `B` is a set with one element.  We can then use the theorem `one_elt_iff_singleton` to conclude that `B = {b}`, for some `b` of type `A`.  We need to prove that `B` has a minimal element, and the only possibility for the minimal element is `b`.  Verifying that `minimalElt R b B` is straightforward.  Here is the proof of the base case:

```lean
theorem Example_6_2_1 {A : Type} (R : BinRel A) (h : partial_order R) :
    ∀ n ≥ 1, ∀ (B : Set A), numElts B n →
      ∃ (x : A), minimalElt R x B := by
  by_induc
  · -- Base Case
    fix B : Set A
    assume h2 : numElts B 1
    rewrite [one_elt_iff_singleton] at h2
    obtain (b : A) (h3 : B = {b}) from h2
    apply Exists.intro b
    define         --Goal: b ∈ B ∧ ¬∃ (x : A), x ∈ B ∧ R x b ∧ x ≠ b
    apply And.intro
    · -- Proof that b ∈ B
      rewrite [h3]    --Goal: b ∈ {b}
      define
      rfl
      done
    · -- Proof that nothing in B is smaller than b
      by_contra h4
      obtain (x : A) (h5 : x ∈ B ∧ R x b ∧ x ≠ b) from h4
      have h6 : x ∈ B := h5.left
      rewrite [h3] at h6   --h6: x ∈ {b}
      define at h6         --h6: x = b
      show False from h5.right.right h6
      done
    done
  · -- Induction Step

    **done::
  done
```

Notice that since the definition of `minimalElt R b B` involves a negative statement, we found it convenient to use proof by contradiction to prove it.

For the induction step, we assume that `n ≥ 1` and that every set with `n` elements has an `R`-minimal element.  We must prove that every set with `n + 1` elements has a minimal element, so we let `B` be an arbitrary set with `n + 1` elements.  To apply the inductive hypothesis, we need a set with `n` elements.  So we pick some `b ∈ B` (using the theorem `nonempty_of_pos_numElts`) and then remove it from `B` to get the set `B' = B \ {b}`.  The theorem `remove_one_numElts` tells us that `B'` has `n` elements, so by the inductive hypothesis, we can then let `c` be a minimal element of `B'`.  We now know about two elements of `B`:  `b` and `c`.  Which will be a minimal element of `B`?  As explained in *HTPI*, it depends on whether or not `R b c`.  We'll prove that if `R b c`, then `b` is a minimal element of `B`, and if not, then `c` is a minimal element.  It will be convenient to prove these last two facts separately as lemmas.  The first lemma says that in the situation at this point in the proof, if `R b c`, then `b` is an `R`-minimal element of `B`.  Here is the proof.

```lean
lemma Lemma_6_2_1_1 {A : Type} {R : BinRel A} {B : Set A} {b c : A}
    (h1 : partial_order R) (h2 : b ∈ B) (h3 : minimalElt R c (B \ {b}))
    (h4 : R b c) : minimalElt R b B := by
  define at h3
    --h3: c ∈ B \ {b} ∧ ¬∃ (x : A), x ∈ B \ {b} ∧ R x c ∧ x ≠ c
  define  --Goal: b ∈ B ∧ ¬∃ (x : A), x ∈ B ∧ R x b ∧ x ≠ b
  apply And.intro h2  --Goal: ¬∃ (x : A), x ∈ B ∧ R x b ∧ x ≠ b
  contradict h3.right with h5
  obtain (x : A) (h6 : x ∈ B ∧ R x b ∧ x ≠ b) from h5
  apply Exists.intro x
  apply And.intro
  · -- Proof that x ∈ B \ {b}
    show x ∈ B \ {b} from And.intro h6.left h6.right.right
    done
  · -- Proof that R x c ∧ x ≠ c
    have Rtrans : transitive R := h1.right.left
    have h7 : R x c := Rtrans x b c h6.right.left h4
    apply And.intro h7
    by_contra h8
    rewrite [h8] at h6
    have Rantisymm : antisymmetric R := h1.right.right
    have h9 : c = b := Rantisymm c b h6.right.left h4
    show False from h6.right.right h9
    done
  done
```

The second lemma says that if `¬R b c`, then `c` is an `R`-minimal element of `B`.  We'll leave the proof as an exercise for you:

```lean
lemma Lemma_6_2_1_2 {A : Type} {R : BinRel A} {B : Set A} {b c : A}
    (h1 : partial_order R) (h2 : b ∈ B) (h3 : minimalElt R c (B \ {b}))
    (h4 : ¬R b c) : minimalElt R c B := sorry
```

With this preparation, we are finally ready to give the proof of the induction step of `Example_6_2_1`:

```lean
theorem Example_6_2_1 {A : Type} (R : BinRel A) (h : partial_order R) :
    ∀ n ≥ 1, ∀ (B : Set A), numElts B n →
      ∃ (x : A), minimalElt R x B := by
  by_induc
  · -- Base Case
    ...
  · -- Induction Step
    fix n : Nat
    assume h2 : n ≥ 1
    assume ih : ∀ (B : Set A), numElts B n → ∃ (x : A), minimalElt R x B
    fix B : Set A
    assume h3 : numElts B (n + 1)
    have h4 : n + 1 > 0 := by linarith
    obtain (b : A) (h5 : b ∈ B) from nonempty_of_pos_numElts h3 h4
    let B' : Set A := B \ {b}
    have h6 : numElts B' n := remove_one_numElts h3 h5
    obtain (c : A) (h7 : minimalElt R c B') from ih B' h6
    by_cases h8 : R b c
    · -- Case 1. h8: R b c
      have h9 : minimalElt R b B := Lemma_6_2_1_1 h h5 h7 h8
      show ∃ (x : A), minimalElt R x B from Exists.intro b h9
      done
    · -- Case 2. h8: ¬R b c
      have h9 : minimalElt R c B := Lemma_6_2_1_2 h h5 h7 h8
      show ∃ (x : A), minimalElt R x B from Exists.intro c h9
      done
    done
  done
```

We'll consider one more theorem from Section 6.2 of *HTPI*.  Example 6.2.2 proves that a partial order on a finite set can always be extended to a total order.  Rather than give that proof, we are going to prove the more general theorem that is stated in Exercise 2 in Section 6.2 of *HTPI*.  To explain the theorem in that exercise, it will be helpful to introduce a bit of terminology.  Suppose `R` is a partial order on `A` and `b` has type `A`.  We will say that `b` is *`R`-comparable to everything* if `∀ (x : A), R b x ∨ R x b`.  If `B` is a set of objects of type `A`, we say that `B` is *`R`-comparable to everything* if every element of `B` is `R`-comparable to everything; that is, if `∀ b ∈ B, ∀ (x : A), R b x ∨ R x b`.  Finally, we say that another binary relation `T` *extends* `R` if `∀ (x y : A), R x y → T x y`.  We are going to prove that if `R` is a partial order on `A` and `B` is a finite set of objects of type `A`, then there is a partial order `T` that extends `R` such that `B` is `T`-comparable to everything.  In other words, we are going to prove the following theorem:

```lean
theorem Exercise_6_2_2 {A : Type} (R : BinRel A) (h : partial_order R) :
    ∀ (n : Nat) (B : Set A), numElts B n → ∃ (T : BinRel A),
    partial_order T ∧ (∀ (x y : A), R x y → T x y) ∧
    ∀ x ∈ B, ∀ (y : A), T x y ∨ T y x
```

In the exercises, we will ask you to show that this implies the theorem in Example 6.2.2.

It will be helpful to begin with a warm-up exercise.  We'll show that a partial order can always be extended to make a single object comparable to everthing.  In other words, we'll show that if `R` is a partial order on `A` and `b` has type `A`, then we can define a partial order `T` extending `R` such that `b` is `T`-comparable to everything.  To define `T`, we will need to make sure that for every `x` of type `A`, either `T b x` or `T x b`.  If `R x b`, then since `T` must extend `R`, we must have `T x b`.  If `¬R x b`, then we will define `T` so that `T b x`.  But notice that if we follow this plan, then for any `x` and `y`, if we have `R x b` and `¬R y b`, then we will have `T x b` and `T b y`, and since `T` must be transitive, we must then have `T x y`.  Summing up, if we have `R x y` then we must have `T x y`, and if we have `R x b` and `¬R y b` then we will also need to have `T x y`.  So let's try defining `T x y` to mean `R x y ∨ (R x b ∧ ¬R y b)`.

It will be useful to have a name for this relation `T`.  Since it is an extension of `R` determined by the element `b`, we will give it the name `extendPO R b`.  Here is the definition of this relation:

```lean
def extendPO {A : Type} (R : BinRel A) (b : A) (x y : A) : Prop :=
    R x y ∨ (R x b ∧ ¬R y b)
```

We need to prove a number of things about `extendPO R b`.  First of all, we need to prove that it is a partial order.  We'll leave most of the details as exercises for you:

```lean
lemma extendPO_is_ref {A : Type} (R : BinRel A) (b : A)
    (h : partial_order R) : reflexive (extendPO R b) := sorry

lemma extendPO_is_trans {A : Type} (R : BinRel A) (b : A)
    (h : partial_order R) : transitive (extendPO R b) := sorry

lemma extendPO_is_antisymm {A : Type} (R : BinRel A) (b : A)
    (h : partial_order R) : antisymmetric (extendPO R b) := sorry

lemma extendPO_is_po {A : Type} (R : BinRel A) (b : A)
    (h : partial_order R) : partial_order (extendPO R b) := 
  And.intro (extendPO_is_ref R b h)
    (And.intro (extendPO_is_trans R b h) (extendPO_is_antisymm R b h))
```

It is easy to prove that `extendPO R b` extends `R`:

```lean
lemma extendPO_extends {A : Type} (R : BinRel A) (b : A) (x y : A) :
    R x y → extendPO R b x y := by
  assume h1 : R x y
  define
  show R x y ∨ R x b ∧ ¬R y b from Or.inl h1
  done
```

Finally, we verify that `extendPO R b` does what it was supposed to do: it makes `b` comparable with everything:

```lean
lemma extendPO_all_comp {A : Type} (R : BinRel A) (b : A)
    (h : partial_order R) :
    ∀ (x : A), extendPO R b b x ∨ extendPO R b x b := by
  have Rref : reflexive R := h.left
  fix x : A
  or_left with h1
  define at h1     --h1: ¬(R x b ∨ R x b ∧ ¬R b b)
  demorgan at h1   --h1: ¬R x b ∧ ¬(R x b ∧ ¬R b b)
  define           --Goal: R b x ∨ R b b ∧ ¬R x b
  apply Or.inr
  show R b b ∧ ¬R x b from And.intro (Rref b) h1.left
  done
```

With this preparation, we can finally return to our theorem `Exercise_6_2_2`.  We will prove it by mathematical induction.  In the base case we must show that if `B` has 0 elements then we can extend `R` to make everything in `B` comparable to everything.  Of course, no extension is necessary, since it is vacuously true that all elements of `B` are `R`-comparable to everything.  For the induction step, after assuming the inductive hypothesis, we must prove that if `B` has `n + 1` elements then we can extend `R` to make all elements of `B` comparable to everything.  As before, we choose `b ∈ B` and let `B' = B \ {b}`.  By inductive hypothesis, we can find an extension `T'` of `R` that makes all elements of `B'` comparable to everything, so we just have to extend `T'` further to make `b` comparable to everything.  But as we have just seen, we can do this with `extendPO T' b`.

```lean
theorem Exercise_6_2_2 {A : Type} (R : BinRel A) (h : partial_order R) :
    ∀ (n : Nat) (B : Set A), numElts B n → ∃ (T : BinRel A),
    partial_order T ∧ (∀ (x y : A), R x y → T x y) ∧
    ∀ x ∈ B, ∀ (y : A), T x y ∨ T y x := by
  by_induc
  · -- Base Case
    fix B : Set A
    assume h2 : numElts B 0
    rewrite [zero_elts_iff_empty] at h2
    define at h2     --h2 : ¬∃ (x : A), x ∈ B
    apply Exists.intro R
    apply And.intro h
    apply And.intro
    · -- Proof that R extends R
      fix x : A; fix y : A
      assume h3 : R x y
      show R x y from h3
      done
    · -- Proof that everything in B comparable to everything under R
      fix x : A
      assume h3 : x ∈ B
      contradict h2
      show ∃ (x : A), x ∈ B from Exists.intro x h3
      done
    done
  · -- Induction Step
    fix n : Nat
    assume ih : ∀ (B : Set A), numElts B n → ∃ (T : BinRel A),
      partial_order T ∧ (∀ (x y : A), R x y → T x y) ∧
      ∀ (x : A), x ∈ B → ∀ (y : A), T x y ∨ T y x
    fix B
    assume h2 : numElts B (n + 1)
    have h3 : n + 1 > 0 := by linarith
    obtain (b : A) (h5 : b ∈ B) from nonempty_of_pos_numElts h2 h3
    let B' : Set A := B \ {b}
    have h6 : numElts B' n := remove_one_numElts h2 h5
    have h7 : ∃ (T : BinRel A), partial_order T ∧
      (∀ (x y : A), R x y → T x y) ∧
      ∀ (x : A), x ∈ B' → ∀ (y : A), T x y ∨ T y x := ih B' h6
    obtain (T' : BinRel A)
      (h8 : partial_order T' ∧ (∀ (x y : A), R x y → T' x y) ∧
      ∀ (x : A), x ∈ B' → ∀ (y : A), T' x y ∨ T' y x) from h7
    have h9 : partial_order T' := h8.left
    let T : BinRel A := extendPO T' b
    apply Exists.intro T
    apply And.intro (extendPO_is_po T' b h9)
    apply And.intro
    · -- Proof that T extends R
      fix x : A; fix y : A
      assume h10 : R x y
      have h11 : T' x y := h8.right.left x y h10
      show T x y from (extendPO_extends T' b x y h11)
      done
    · -- Proof that everything in B comparable to everything under T
      fix x : A
      assume h10 : x ∈ B
      by_cases h11 : x = b
      · -- Case 1. h11: x = b
        rewrite [h11]
        show ∀ (y : A), T b y ∨ T y b from extendPO_all_comp T' b h9
        done
      · -- Case 2. h11: x ≠ b
        have h12 : x ∈ B' := And.intro h10 h11
        fix y : A
        have h13 : T' x y ∨ T' y x := h8.right.right x h12 y
        by_cases on h13
        · -- Case 1. h13: T' x y
          show T x y ∨ T y x from
            Or.inl (extendPO_extends T' b x y h13)
          done
        · -- Case 2. h13: T' y x
          show T x y ∨ T y x from
            Or.inr (extendPO_extends T' b y x h13)
          done
        done
      done
    done
  done
```

### Exercises

::: {.numex arguments="1"}
```lean
lemma Lemma_6_2_1_2 {A : Type} {R : BinRel A} {B : Set A} {b c : A}
    (h1 : partial_order R) (h2 : b ∈ B) (h3 : minimalElt R c (B \ {b}))
    (h4 : ¬R b c) : minimalElt R c B := sorry
```
:::

::: {.numex arguments="2"}
```lean
lemma extendPO_is_ref {A : Type} (R : BinRel A) (b : A)
    (h : partial_order R) : reflexive (extendPO R b) := sorry
```
:::

::: {.numex arguments="3"}
```lean
lemma extendPO_is_trans {A : Type} (R : BinRel A) (b : A)
    (h : partial_order R) : transitive (extendPO R b) := sorry
```
:::

::: {.numex arguments="4"}
```lean
lemma extendPO_is_antisymm {A : Type} (R : BinRel A) (b : A)
    (h : partial_order R) : antisymmetric (extendPO R b) := sorry
```
:::

::: {.numex arguments="5"}
```lean
theorem Exercise_6_2_3 (A : Type) (R : BinRel A)
    (h : total_order R) : ∀ n ≥ 1, ∀ (B : Set A),
    numElts B n → ∃ (b : A), smallestElt R b B := sorry
```
:::

::: {.numex arguments="6"}
```lean
theorem Exercise_6_2_4a {A : Type} (R : BinRel A)
    (h : ∀ (x y : A), R x y ∨ R y x) : ∀ n ≥ 1, ∀ (B : Set A),
    numElts B n → ∃ x ∈ B, ∀ y ∈ B, ∃ (z : A), R x z ∧ R z y := sorry
--Hint:  First prove that R is reflexive
```
:::

::: {.numex arguments="7"}
```lean
theorem Like_Exercise_6_2_16 (f : Nat → Nat) (h : one_to_one f) :
    ∀ (n : Nat) (A : Set Nat), numElts A n →
    closed f A → ∀ y ∈ A, ∃ x ∈ A, f x = y := sorry
```
:::

## 6.3. Recursion

In the last two sections, we saw that we can prove that all natural numbers have some property by proving that 0 has the property, and also that for every natural number $n$, if $n$ has the property then so does $n + 1$.  In this section we will see that a similar idea can be used to define a function whose domain is the natural numbers.  We can define a function $f$ with domain $\mathbb{N}$ by specifying the value of $f(0)$, and also saying how to compute $f(n+1)$ if you already know the value of $f(n)$.

For example, we can define a function $f : \mathbb{N} \to \mathbb{N}$ as follows:

::: {.quote}
$f(0) = 1$;<br>\newline
for every $n \in \mathbb{N}$, $f(n+1) = (n+1) \cdot f(n)$.
:::

Here is the same definition written in Lean.  (For reasons that will become clear shortly, we have given the function the name `fact`.)

```lean
def fact (x : Nat) : Nat :=
  match x with
    | 0 => 1
    | n + 1 => (n + 1) * fact n
```

Lean can use this definition to compute `fact x` for any natural number `x`.  The `match` statement tells Lean to try to match the input `x` with one of the two patterns `0` and `n + 1`, and then to use the corresponding formula after `=>` to compute `fact x`.  For example, if we ask Lean for `fact 4`, it first checks if `4` matches `0`.  Since it doesn't, it goes on to the next line and determines that `4` matches the pattern `n + 1`, with `n = 3`, so it uses the formula `fact 4 = 4 * fact 3`.  Of course, now it must compute `fact 3`, which it does in the same way: `3` matches `n + 1` with `n = 2`, so `fact 3 = 3 * fact 2`.  Continuing in this way, Lean determines that

::: {.ind}
```
fact 4 = 4 * fact 3 = 4 * (3 * fact 2) = 4 * (3 * (2 * fact 1))
       = 4 * (3 * (2 * (1 * fact 0))) = 4 * (3 * (2 * (1 * 1))) = 24
```
:::

You can confirm this with the `#eval` command:

```lean
#eval fact 4   --Answer: 24
```

Of course, by now you have probably guessed why we used the name `fact` for his function: `fact x` is `x` factorial---the product of all the numbers from 1 to `x`.

This style of definition is called a *recursive* definition.  If a function is defined by a recursive definition, then theorems about that function are often most easily proven by induction.  For example, here is a theorem about the factorial function.  It is Example 6.3.1 in *HTPI*, and we begin the Lean proof by imitating the proof in *HTPI*.

```lean
theorem ??Example_6_3_1:: : ∀ n ≥ 4, fact n > 2 ^ n := by
  by_induc
  · -- Base Case
    norm_num
    done
  · -- Induction Step
    fix n : Nat
    assume h1 : n ≥ 4
    assume ih : fact n > 2 ^ n
    show fact (n + 1) > 2 ^ (n + 1) from
      calc fact (n + 1)
          = (n + 1) * fact n := by rfl
        _ > (n + 1) * 2 ^ n := sorry
        _ > 2 * 2 ^ n := sorry
        _ = 2 ^ (n + 1) := by ring
    done
  done
```

There are two steps in the calculational proof at the end that require justification.  The first says that `(n + 1) * fact n > (n + 1) * 2 ^ n`, which should follow from the inductive hypothesis `ih : fact n > 2 ^ n` by multiplying both sides by `n + 1`.  Is there a theorem that would justify this inference?

This may remind you a step in `Example_6_1_3` where we used the theorem `Nat.mul_le_mul_right`, which says `∀ {n m : ℕ} (k : ℕ), n ≤ m → n * k ≤ m * k`.  Our situation in this example is similar, but it involves a strict inequality (`>` rather than `≥`) and it involves multiplying on the left rather than the right.  Many theorems about inequalities in Lean's library contain either `le` (for "less than or equal to") or `lt` (for "less than") in their names, but they can also be used to prove statements involving `≥` or `>`.  Perhaps the theorem we need is named something like `Nat.mul_lt_mul_left`.  If you type `#check @Nat.mul_lt_mul` into VS Code, a pop-up window will appear listing several theorems that begin with `Nat.mul_lt_mul`.  There is no `Nat.mul_lt_mul_left`, but there is a theorem called `Nat.mul_lt_mul_of_pos_left`, and its meaning is

::: {.ind}
```
@Nat.mul_lt_mul_of_pos_left : ∀ {n m k : ℕ},
                                n < m → k > 0 → k * n < k * m
```
:::

Lean has correctly reminded us that, to multiply both sides of a strict inequality by a number `k`, we need to know that `k > 0`.  So in our case, we'll need to prove that `n + 1 > 0`.  Once we have that, we can use the theorem `Nat.mul_lt_mul_of_pos_left` to eliminate the first `sorry`.

The second `sorry` is similar: `(n + 1) * 2 ^ n > 2 * 2 ^ n` should follow from `n + 1 > 2` and `2 ^ n > 0`, and you can verify that the theorem that will justify this inference is `Nat.mul_lt_mul_of_pos_right`.

So we have three inequalities that we need to prove before we can justify the steps of the calculational proof:  `n + 1 > 0`, `n + 1 > 2`, and `2 ^ n > 0`.  We'll insert `have` steps before the calculational proof to assert these three inequalities.  If you try it, you'll find that `linarith` can prove the first two, but not the third.

How can we prove `2 ^ n > 0`?  It is often helpful to think about whether there is a general principle that is behind a statement we are trying to prove.  In our case, the inequality `2 ^ n > 0` is an instance of the general fact that if `m` and `n` are any natural numbers with `m > 0`, then `m ^ n > 0`.  Maybe that fact is in Lean's library:

```lean
example (m n : Nat) (h : m > 0) : m ^ n > 0 := by library_search
```

The `library_search` tactic comes up with `exact pow_pos h n`, and `#check @pow_pos` gives the result

::: {.ind}
```
@pow_pos : ∀ {α : Type u_1} [inst : StrictOrderedSemiring α] {a : α},
            0 < a → ∀ (n : ℕ), 0 < a ^ n
```
:::

That means that we can use `pow_pos` to prove `2 ^ n > 0`, but first we'll need to prove that `2 > 0`.  We now have all the pieces we need; putting them together leads to this proof:

```lean
theorem Example_6_3_1 : ∀ n ≥ 4, fact n > 2 ^ n := by
  by_induc
  · -- Base Case
    norm_num
    done
  · -- Induction Step
    fix n : Nat
    assume h1 : n ≥ 4
    assume ih : fact n > 2 ^ n
    have h2 : n + 1 > 0 := by linarith
    have h3 : n + 1 > 2 := by linarith
    have h4 : 2 > 0 := by linarith
    have h5 : 2 ^ n > 0 := pow_pos h4 n
    show fact (n + 1) > 2 ^ (n + 1) from
      calc fact (n + 1)
          = (n + 1) * fact n := by rfl
        _ > (n + 1) * 2 ^ n := Nat.mul_lt_mul_of_pos_left ih h2
        _ > 2 * 2 ^ n := Nat.mul_lt_mul_of_pos_right h3 h5
        _ = 2 ^ (n + 1) := by ring
    done
  done
```

The next example in *HTPI* is a proof of one of the laws of exponents:  `a ^ (m + n) = a ^ m * a ^ n`.  Lean's definition of exponentiation with natural number exponents is recursive.  For some reason, the definitions are slightly different for different kinds of bases.  The definitions Lean uses are essentially as follows:

```lean
-- For natural numbers x and n, x ^ n = nat_pow x n:
def nat_pow (x n : Nat) : Nat :=
  match n with
    | 0 => 1
    | k + 1 => (nat_pow x k) * x

-- For a real number x and a natural number n, x ^ n = real_pow x n:
def real_pow (x : Real) (n : Nat) : Real :=
  match n with
    | 0 => 1
    | k + 1 => x * (real_pow x k)
```

Let's prove the addition law for exponents:

```lean
theorem Example_6_3_2_cheating : ∀ (a : Real) (m n : Nat),
    a ^ (m + n) = a ^ m * a ^ n := by
  fix a : Real; fix m : Nat; fix n : Nat
  ring
  done
```

Well, that wasn't really fair.  The `ring` tactic knows the laws of exponents, so it has no trouble proving this theorem.  But we want to know why the law holds, so let's see if we can prove it without using `ring`.  The following proof is essentially the same as the proof in *HTPI*:

```lean
theorem Example_6_3_2 : ∀ (a : Real) (m n : Nat),
    a ^ (m + n) = a ^ m * a ^ n := by
  fix a : Real; fix m : Nat
    --Goal: ∀ (n : Nat), a ^ (m + n) = a ^ m * a ^ n
  by_induc
  · -- Base Case
    show a ^ (m + 0) = a ^ m * a ^ 0 from
      calc a ^ (m + 0)
          = a ^ m := by rfl
        _ = a ^ m * 1 := (mul_one (a ^ m)).symm
        _ = a ^ m * a ^ 0 := by rfl
    done
  · -- Induction Step
    fix n : Nat
    assume ih : a ^ (m + n) = a ^ m * a ^ n
    show a ^ (m + (n + 1)) = a ^ m * a ^ (n + 1) from
      calc a ^ (m + (n + 1))
          = a ^ ((m + n) + 1) := by rw [add_assoc]
        _ = a * a ^ (m + n) := by rfl
        _ = a * (a ^ m * a ^ n) := by rw [ih]
        _ = a ^ m * (a * a ^ n) :=
            by rw [←mul_assoc, mul_comm a, mul_assoc]
        _ = a ^ m * (a ^ (n + 1)) := by rfl
    done
  done
```

Finally, we'll prove the theorem in Example 6.3.4 of *HTPI*, which again involves exponentiation with natural number exponents.  Here's the beginning of the proof:

::: {.inout}
::: {.inpt}
```lean
theorem Example_6_3_4 : ∀ (x : Real), x > -1 →
    ∀ (n : Nat), (1 + x) ^ n ≥ 1 + n * x := by
  fix x : Real
  assume h1 : x > -1
  **done::
```
:::

::: {.outpt}
```state
x : ℝ
h1 : x > -1
⊢ ∀ (n : ℕ),
>>  (1 + x) ^ n ≥
>>    1 + ↑n * x
```
:::
:::

Look carefully at the goal in the tactic state.  Why is there a `↑` before the last `n`?  The reason has to do with types.  The variable `x` has type `Real` and `n` has type `Nat`, so how can Lean multiply `n` by `x`?  Remember, in Lean, the natural numbers are not a subset of the real numbers.  The two types are completely separate, but for each natural number, there is a corresponding real number.  To multiply `n` by `x`, Lean had to convert `n` to the corresponding real number, through a process called *coercion*.  The notation `↑n` denotes the result of *coercing* (or *casting*) `n` to another type---in this case, `Real`.  Since `↑n` and `x` are both real numbers, Lean can use the multiplication operation on the real numbers to multiply them.  As we will see, the need for coercion in this example will make the proof a bit more complicated, because we'll need to use some theorems about coercions.  Theorems about coercion of natural numbers to some other type often have names that start `Nat.cast`.

Continuing with the proof, let's try mathematical induction:

::: {.inout}
::: {.inpt}
```lean
theorem Example_6_3_4 : ∀ (x : Real), x > -1 →
    ∀ (n : Nat), (1 + x) ^ n ≥ 1 + n * x := by
  fix x : Real
  assume h1 : x > -1
  by_induc
  · -- Base Case

    **done::
  · -- Induction Step

    **done::  
  done
```
:::

::: {.outpt}
```state
case Base_Case
x : ℝ
h1 : x > -1
⊢ (1 + x) ^ 0 ≥
>>  1 + ↑0 * x
```
:::
:::

You might think that `linarith` could prove the goal for the base case, but it can't.  The problem is the `↑0`, which denotes the result of coercing the natural number `0` to a real number.  Of course, that should be the real number `0`, but is it?  Yes, but the `linarith` tactic doesn't know that.  The theorem `Nat.cast_zero` says that `↑0 = 0` (where the `0` on the right side of the equation is the *real number* `0`), so the tactic `rewrite [Nat.cast_zero]` will convert `↑0` to `0`.  After that step, `linarith` can complete the proof of the base case, and we can start on the induction step.

::: {.inout}
::: {.inpt}
```lean
theorem Example_6_3_4 : ∀ (x : Real), x > -1 →
    ∀ (n : Nat), (1 + x) ^ n ≥ 1 + n * x := by
  fix x : Real
  assume h1 : x > -1
  by_induc
  · -- Base Case
    rewrite [Nat.cast_zero]
    linarith
    done
  · -- Induction Step
    fix n : Nat
    assume ih : (1 + x) ^ n ≥ 1 + n * x
    **done::
  done
```
:::

::: {.outpt}
```state
case Induction_Step
x : ℝ
h1 : x > -1
n : ℕ
ih : (1 + x) ^ n ≥
>>    1 + ↑n * x
⊢ (1 + x) ^ (n + 1) ≥
>>  1 + ↑(n + 1) * x
```
:::
:::

Once again, there's a complication caused by coercion.  The inductive hypothesis talks about `↑n`, but the goal involves `↑(n + 1)`.  What is the relationship between these?  Surely it should be the case that `↑(n + 1) = ↑n + 1`; that is, the result of coercing the natural number `n + 1` to a real number should be one larger than the result of coercing `n` to a real number.  The theorem `Nat.cast_succ` says exactly that, so `rewrite [Nat.cast_succ]` will change the `↑(n + 1)` in the goal to `↑n + 1`.  (The number `n + 1` is sometimes called the *successor* of `n`, and `succ` is short for "successor.")  With that change, we can continue with the proof.  The following proof is modeled on the proof in *HTPI*.

```lean
theorem ??Example_6_3_4:: : ∀ (x : Real), x > -1 →
    ∀ (n : Nat), (1 + x) ^ n ≥ 1 + n * x := by
  fix x : Real
  assume h1 : x > -1
  by_induc
  · -- Base Case
    rewrite [Nat.cast_zero]
    linarith
    done
  · -- Induction Step
    fix n : Nat
    assume ih : (1 + x) ^ n ≥ 1 + n * x
    rewrite [Nat.cast_succ]
    show (1 + x) ^ (n + 1) ≥ 1 + (↑n + 1) * x from
      calc (1 + x) ^ (n + 1)
          = (1 + x) * (1 + x) ^ n := by rfl
        _ ≥ (1 + x) * (1 + n * x) := sorry
        _ = 1 + x + n * x + n * x * x := by ring
        _ ≥ 1 + x + n * x + 0 := sorry
        _ = 1 + (n + 1) * x := by ring
    done
  done
```

Note that in the calculational proof, each `n` that is multiplied by `x` is really `↑n`, but we don't need to say so explicitly; Lean fills in coercions automatically when they are required.

All that's left is to replace the two occurrences of `sorry` with justifications.  We'll use two theorems:

::: {.ind}
```
@mul_le_mul_of_nonneg_left : ∀ {α : Type u_1} {a b c : α} [inst : Mul α]
        [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : PosMulMono α],
        b ≤ c → 0 ≤ a → a * b ≤ a * c
@add_le_add_left : ∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α]
        [inst_2 : CovariantClass α α (fun (x x_1 : α) => x + x_1)
        fun (x x_1 : α) => x ≤ x_1] {b c : α},
        b ≤ c → ∀ (a : α), a + b ≤ a + c
```
:::

As usual, we don't need to pay much attention to the long lists of implicit arguments; what is important is the last line of each statement.  Those lines tell us that `mul_le_mul_of_nonneg_left` can be applied to the inductive hypothesis to justify the first `sorry` step, if we can prove `1 + x ≥ 0`.  And then `add_le_add_left` will justify the second `sorry` step, if we can prove `n * x * x ≥ 0`.  So here is our next attempt:

```lean
theorem ??Example_6_3_4:: : ∀ (x : Real), x > -1 →
    ∀ (n : Nat), (1 + x) ^ n ≥ 1 + n * x := by
  fix x : Real
  assume h1 : x > -1
  by_induc
  · -- Base Case
    rewrite [Nat.cast_zero]
    linarith
    done
  · -- Induction Step
    fix n : Nat
    assume ih : (1 + x) ^ n ≥ 1 + n * x
    rewrite [Nat.cast_succ]
    have h2 : 1 + x ≥ 0 := by linarith
    have h3 : n * x * x ≥ 0 := sorry
    show (1 + x) ^ (n + 1) ≥ 1 + (↑n + 1) * x from
      calc (1 + x) ^ (n + 1)
          = (1 + x) * (1 + x) ^ n := by rfl
        _ ≥ (1 + x) * (1 + n * x) := mul_le_mul_of_nonneg_left ih h2
        _ = 1 + x + n * x + n * x * x := by ring
        _ ≥ 1 + x + n * x + 0 := add_le_add_left h3 _
        _ = 1 + (n + 1) * x := by ring
    done
  done
```

The `linarith` tactic is able to prove `1 + x ≥ 0`, since it follows easily from `h1 : x > -1`.  But how can we prove `n * x * x ≥ 0`?  We start with the fact that the square of any real number is nonnegative:

::: {.ind}
```
@mul_self_nonneg : ∀ {α : Type u_1} [inst : LinearOrderedRing α]
                    (a : α), 0 ≤ a * a
```
:::

So `mul_self_nonneg x` is a proof of `x * x ≥ 0`.  To get `n * x * x ≥ 0`, which means `↑n * x * x ≥ 0`, we'll need another application of `mul_le_mul_of_nonneg_left`, and we'll need to know `↑n ≥ 0`.  But if we use the `have` tactic to assert `↑n ≥ 0`, then Lean won't know what we mean.  The problem is that this last statement is ambiguous.  The notation `↑n` means "`n` coerced to some other type," but what is the other type?  Lean can usually figure this out from context, but in the statement `↑n ≥ 0` there is no context to tell Lean what type to use.  So we must say `(↑n : Real) ≥ 0` to eliminate the ambiguity.  The theorem `Nat.cast_nonneg` proves this statement, providing the last piece of the puzzle.  Here's the complete proof:

```lean
theorem Example_6_3_4 : ∀ (x : Real), x > -1 →
    ∀ (n : Nat), (1 + x) ^ n ≥ 1 + n * x := by
  fix x : Real
  assume h1 : x > -1
  by_induc
  · -- Base Case
    rewrite [Nat.cast_zero]
    linarith
    done
  · -- Induction Step
    fix n : Nat
    assume ih : (1 + x) ^ n ≥ 1 + n * x
    rewrite [Nat.cast_succ]
    have h2 : 1 + x ≥ 0 := by linarith
    have h3 : n * x * x ≥ 0 := by
      have h4 : x * x ≥ 0 := mul_self_nonneg x
      have h5 : (↑n : Real) ≥ 0 := Nat.cast_nonneg n
      calc n * x * x
          = n * (x * x) := mul_assoc _ _ _
        _ ≥ n * 0 := mul_le_mul_of_nonneg_left h4 h5
        _ = 0 := by ring
    show (1 + x) ^ (n + 1) ≥ 1 + (↑n + 1) * x from
      calc (1 + x) ^ (n + 1)
          = (1 + x) * (1 + x) ^ n := by rfl
        _ ≥ (1 + x) * (1 + n * x) := mul_le_mul_of_nonneg_left ih h2
        _ = 1 + x + n * x + n * x * x := by ring
        _ ≥ 1 + x + n * x + 0 := add_le_add_left h3 _
        _ = 1 + (n + 1) * x := by ring
    done
  done
```

Before ending this section, we'll return to a topic left unexplained before.  We can now describe how `Sum i from k to n, f i` is defined.  The key is a function `sum_less`, which is defined by recursion:

```lean
def sum_less {A : Type} [AddZeroClass A] (x : Nat) (f : Nat → A) : A :=
  match x with
    | 0 => 0
    | n + 1 => sum_less n f + f n
```

To get an idea of what this definition means, let's try evaluating `sum_less 3 f`:

::: {.ind}
```
sum_less 3 f = sum_less 2 f + f 2
             = sum_less 1 f + f 1 + f 2
             = sum_less 0 f + f 0 + f 1 + f 2
             = 0 + f 0 + f 1 + f 2
```
:::

So `sum_less 3 f` adds up all values of `f i`, for `i < 3`.  More generally, `sum_less x f` gives the sum of all values `f i` for `i < x`.  (The implicit arguments say that the type of `f i` can be any type for which `0` and `+` make sense.)  The notation `Sum i from k to n, f i` is now defined to be a shorthand for `sum_less (n + 1 - k) (fun x => f (k + x))`.  We'll leave it to you to puzzle out why that gives the desired result.

### Exercises

::: {.numex arguments="1"}
```lean
theorem Exercise_6_3_7b (f : Nat → Real) (c : Real) : ∀ (n : Nat),
    Sum i from 0 to n, c * f i = c * Sum i from 0 to n, f i := sorry
```
:::

::: {.numex arguments="2"}
```lean
theorem fact_pos : ∀ (n : Nat), fact n ≥ 1 := sorry
```
:::

::: {.numex arguments="3"}
```lean
--Hint:  Use the theorem fact_pos from the previous exercise
theorem Exercise_6_3_13a (k : Nat) : ∀ (n : Nat),
    fact (k ^ 2 + n) ≥ k ^ (2 * n) := sorry
```
:::

::: {.numex arguments="4"}
```lean
--Hint:  Use the theorem in the previous exercise.
--You may find it useful to first prove a lemma:
--∀ (k : Nat), 2 * k ^ 2 + 1 ≥ k
theorem Exercise_6_3_13b (k : Nat) : ∀ n ≥ 2 * k ^ 2,
    fact n ≥ k ^ n := sorry
```
:::

5\. A sequence is defined recursively as follows:

```lean
def seq_6_3_15 (x : Nat) : Int :=
  match x with
    | 0 => 0
    | n + 1 => 2 * seq_6_3_15 n + n
```

Prove the following theorem about this sequence:

```lean
theorem Exercise_6_3_15 : ∀ (n : Nat),
    seq_6_3_15 n = 2 ^ n - n - 1 := sorry
```

6\. A sequence is defined recursively as follows:

```lean
def seq_6_3_16 (x : Nat) : Nat :=
  match x with
    | 0 => 2
    | n + 1 => (seq_6_3_16 n) ^ 2
```

Find a formula for `seq_6_3_16 n`.  Fill in the blank in the theorem below with your formula and then prove the theorem.

```lean
theorem Exercise_6_3_16 : ∀ (n : Nat),
    seq_6_3_16 n = ___ := sorry
```
